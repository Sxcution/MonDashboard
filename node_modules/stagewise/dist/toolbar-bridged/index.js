var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value);
import * as React from "react";
import React__default, { createContext, useRef, useMemo, useContext, useSyncExternalStore, useCallback, useState, useEffect, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useId as useId$1, StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import { A as AgentStateType, u as useAgents, a as useAppState, b as usePlugins, c as useAgentMessaging, d as usePanels, e as collectUserMessageMetadata, g as getSelectedElementInfo, f as generateId, h as AgentAvailabilityError, C as ConfigProvider, i as AgentProvider, j as AgentMessagingProvider, P as PanelsProvider, k as PluginProvider, H as HotkeyActions, l as hotkeyActionDefinitions, m as getIFrameWindow, n as cn, o as getElementAtPoint, p as getXPathForElement, G as Glassy, q as glassyBoxClassName, r as cva, s as Panel, t as PanelHeader, v as PanelContent, w as PanelFooter, B as Button, x as AppStateProvider } from "index-C6aACILb.js";
import * as ReactDOM from "react-dom";
import config from "@stagewise/toolbar/config";
const appStyle = '/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports ((-webkit-hyphens:none) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-divide-y-reverse:0;--tw-border-style:solid;--tw-gradient-position:initial;--tw-gradient-from:#0000;--tw-gradient-via:#0000;--tw-gradient-to:#0000;--tw-gradient-stops:initial;--tw-gradient-via-stops:initial;--tw-gradient-from-position:0%;--tw-gradient-via-position:50%;--tw-gradient-to-position:100%;--tw-leading:initial;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-ease:initial;--tw-content:""}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-100:oklch(93.6% .032 17.717);--color-red-200:oklch(88.5% .062 18.334);--color-red-500:oklch(63.7% .237 25.331);--color-orange-300:oklch(83.7% .128 66.29);--color-orange-500:oklch(70.5% .213 47.604);--color-yellow-500:oklch(79.5% .184 86.047);--color-lime-200:oklch(93.8% .127 124.321);--color-green-300:oklch(87.1% .15 154.449);--color-green-400:oklch(79.2% .209 151.711);--color-green-500:oklch(72.3% .219 149.579);--color-green-600:oklch(62.7% .194 149.214);--color-emerald-500:oklch(69.6% .17 162.48);--color-teal-300:oklch(85.5% .138 181.071);--color-teal-400:oklch(77.7% .152 181.912);--color-teal-500:oklch(70.4% .14 182.503);--color-cyan-200:oklch(91.7% .08 205.041);--color-sky-100:oklch(95.1% .026 236.824);--color-sky-300:oklch(82.8% .111 230.318);--color-sky-500:oklch(68.5% .169 237.323);--color-blue-50:oklch(97% .014 254.604);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-400:oklch(70.7% .165 254.624);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-blue-950:oklch(28.2% .091 267.935);--color-indigo-200:oklch(87% .065 274.039);--color-indigo-300:oklch(78.5% .115 274.713);--color-indigo-400:oklch(67.3% .182 276.935);--color-indigo-500:oklch(58.5% .233 277.117);--color-violet-400:oklch(70.2% .183 293.541);--color-violet-600:oklch(54.1% .281 293.009);--color-purple-200:oklch(90.2% .063 306.703);--color-purple-500:oklch(62.7% .265 303.9);--color-fuchsia-400:oklch(74% .238 322.16);--color-fuchsia-700:oklch(51.8% .253 323.949);--color-pink-500:oklch(65.6% .241 354.308);--color-rose-300:oklch(81% .117 11.638);--color-rose-600:oklch(58.6% .253 17.585);--color-zinc-50:oklch(98.5% 0 0);--color-zinc-100:oklch(96.7% .001 286.375);--color-zinc-200:oklch(92% .004 286.32);--color-zinc-300:oklch(87.1% .006 286.286);--color-zinc-400:oklch(70.5% .015 286.067);--color-zinc-500:oklch(55.2% .016 285.938);--color-zinc-600:oklch(44.2% .017 285.786);--color-zinc-700:oklch(37% .013 285.805);--color-zinc-900:oklch(21% .006 285.885);--color-zinc-950:oklch(14.1% .005 285.823);--color-black:#000;--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--leading-relaxed:1.625;--radius-sm:.25rem;--radius-md:.375rem;--radius-lg:.5rem;--radius-xl:.75rem;--radius-2xl:1rem;--radius-3xl:1.5rem;--shadow-lg:0 10px 15px -3px #0000001a,0 4px 6px -4px #0000001a;--drop-shadow-xl:0 9px 7px #0000001a;--ease-out:cubic-bezier(0,0,.2,1);--ease-in-out:cubic-bezier(.4,0,.2,1);--animate-spin:spin 1s linear infinite;--animate-pulse:pulse 2s cubic-bezier(.4,0,.6,1)infinite;--blur-sm:8px;--blur-md:12px;--blur-lg:16px;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono);--color-foreground:var(--color-zinc-950);--color-muted-foreground:var(--color-zinc-700);--color-border:var(--color-zinc-500);--ease-spring:linear(0,-.00946,.0219,.0793,.152,.237,.326,.419,.509,.597,.68,.755,.823,.882,.933,.976,1.01,1.04,1.06,1.07,1.08,1.09,1.09,1.09,1.09,1.08,1.07,1.07,1.06,1.05,1.04,1.03,1.03,1.02,1.01,1.01,1,1,.998,.996,.994,.993,.992,.992,.992,.992,.992,.993,.994,.994,.995,.996,.997,.997,.998,.998,.999,.999,1);--ease-spring-soft:linear(0,-.0531,.117,.293,.46,.61,.738,.838,.913,.965,1,1.02,1.03,1.03,1.03,1.03,1.03,1.02,1.01,1.01,1.01,1,1,1,1);--glass-texture:url(data:image/png;base64,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);--gradient:url(data:image/png;base64,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Lkj8yHXZ5TfOBYf9PFMw0sl5YoFYLLSx3MasaKjE08RhRdUo359xWeG8xVktV1nznvyFoZy2kuI6zWHEsIQ4EhAho4oSyrAQoVUjxUSS9qMe/iHHnyCXTK4SGDkWUIEKyfGD/8Hvbs381KSbFIoCnS+2/TEKBHeBRs22v49tu3ECBJ6BK63lr9SB2U/Say0tfAT0bwMX1y1N3gMud4DBJ10yJEcK0PTn88D7GX1TFhi4BbrX3N6a+zh9ANLU1fINcHAIjBUoe93j3V3tvf17ptnfD1oXcp3/D10UAAAN92lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9ImdpbXA6ZG9jaWQ6Z2ltcDozYmQzMGE4My01MzllLTQ4MzYtODM3NC02NDJjZmYwYjMwYTEiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ZDYyMDQ1MTEtZDhhZS00ZWEzLTk4N2QtODcwZmI3ODRlM2ZmIgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZWNmN2VkZGUtY2IyYy00MjY1LWExNTUtOTBlNWJmOTk2MGIxIgogICBkYzpGb3JtYXQ9ImltYWdlL3BuZyIKICAgR0lNUDpBUEk9IjIuMCIKICAgR0lNUDpQbGF0Zm9ybT0iV2luZG93cyIKICAgR0lNUDpUaW1lU3RhbXA9IjE3MTE5MTU5MTA3NTc3NjAiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4yNCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiY2M3MDgxNi1jYjIzLTQxNDItYjg0Yy1lNWMzODhiOGM3ODIiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjQtMDMtMjZUMTA6MTk6MzYiLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZThjNGJjZjEtYmQ4Ni00YjVkLTg5MzktOGJmNzBlY2MyZGZkIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKFdpbmRvd3MpIgogICAgICBzdEV2dDp3aGVuPSIyMDI0LTAzLTMxVDIyOjExOjUwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PlE6FucAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoAx8UCzJJFY2xAAAFJUlEQVRYw3WW0ZbbNgxEL0iQlJymzS/1/5/6JU16dmNbEok+EKJpNZUPjrRaSTMYDAEKf/5lhABNwAx2g+OAxwYfT/h4wI8HPB7AHdiBAzBAPCIQPIR+NH/uAJ4edz8//LyjIB1cxL9p/d1GJ3QYHOeNOn3UHEj8/pWATc+f79pEvD+vtPMdg2ZQDVrroHuDvUKrU+aHX9eJQLjESaBdSFxVayi1MY5mUB14qx4HtGMisE3X53GWIE4AswrtknkcaihbBXEZqgM/dnju/byf4LuDn1H/I+fr49dSMIHyRkS5b73+SK/3dnTwn1uPurlhtksZ5qyaA3BRYCZngF48UVE+7iDB1bJe8/sBP5+wb8Otr9ofk6wziE0ZhktZ5qNNUVH+uTNWghlsrStQ92m5bBfw2c1caps80/McLurYZNCG8v2zK4B0E7Y2ZTuD71PWXOquCIpQMBJGcgJnxHelxKOvgo9fNJDqsf1P41GnED0ygUQgA5lG5qBwDBW0J6kBMhAMooE0FD6mevEmz7vhZBAVhEggoRQSSkLJTqDQyGxkHmTuKKYJbhHWMFXmLAGfTiD+YumcTj+BowMHFiLFCfRfJlAwMpXCRiaTCSnx8bvCl5OAQHqVQeHnRCBMXUqmWgsBQQksBFYiK8oyCGSUjJCdQOZJQUOGr4nn18j+20zAy9AJPFyTOJ15I6VECpGVyG0CX0hDgUgaBA4KmUxcE+1L4vFb5PtJIDsB4SzBfllWMsAjEUVZSawoNyI3v1488kQAEtXNF8nYmthXZV2U7+uFQDhb8Wv0jbUaHLyQWUncPPq1TvJ3+ymJgAKZSmIjETTRSmIriaUoMUdqFijiQo8SyHB4X1JKRlnJI27kQWBxRQqRjJJcJSHRSFS0q6GJPSWKKjkpSw58pmkVRINg6AncP6Oe9RmFlcLNlTgJdPdHsr8VUIRIQ9n9usZIDpEUIzkGlhD4jGHq0E5AvV5lAlwpLBRuLIPMMoEvI/Me4p5p3piMSJZAEiEhJBHKOfCQ1/TF0BuFQmZhfSOwsjiREzy56XRkrgQCASFgRKq35oqwNyGaoAbaILe+9M18x4WBgX5jpfivZ7sMBTp49uV2gqtXuTtGHNQI7IQxmONuxGrEClqNXI3lMO7Rt3rBZ8FXVpf4JFEGpQ6cB3hy6U/wMLXnOu0KAkY4jLgbejTyLpTd+D027sKYA2DoH6xkMmcpCoubLZNHj5vBe94R8exfXaT3T+uamBEfDX0KaROWJ3wVeJrwPfq8MVeguNRl+EEHeBqy944YvS2HAS5Tw27uitaH9IegN6FkWKNxmNAOyNH4pPFsDf3C4pn3pZameqfh9rM14eAyjS0bs7LPyTa2IHGD/AFFjRuGVSEorMH4RmUzJ5Dd5a+s+6TrwPI2K0+Zr4dgXhQh0MbeKP+AKoY1I+xCVthiY7dGbQ3tDjh7el9iycfuuchkVFpoNDff+8A2f+b0R2/MfZtpfxuyNfSLUCLs0ag0jtrQMkmd3eE989dwFocy3xu0aW7YRKaXwFyphgIFQwjop1B+wiZwOIHWGqoOqGNF94/0rBrNBZehRHP7yeQE8Te7AmnSp4+2xo5wGGSDo7VOgIaGUTfxnYB5DjZl+lJCEKqDyyAhw4q9FRvqNLsf+pb1cB0P7EXgZSMbvza23kwUzAFOlcI4y9hPBqB6AZv/7+WL6ATUCVQqei6k5gazIbj53/i9V52jb0q7Uc3rHt72kr1PNBTxHYf5HbxPdMR/Af2SQINNgRTNAAAAAElFTkSuQmCC)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::-moz-placeholder{opacity:1}::placeholder{opacity:1}@supports (not (-webkit-appearance:-apple-pay-button)) or (contain-intrinsic-size:1px){::-moz-placeholder{color:currentColor}::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::-moz-placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){-webkit-appearance:button;-moz-appearance:button;appearance:button}::file-selector-button{-webkit-appearance:button;-moz-appearance:button;appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{min-width:0;min-height:0;position:relative}body{all:initial;color:var(--color-zinc-950);letter-spacing:normal!important;font-family:Inter,Noto Color Emoji,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,SF Compact,SF Pro,Helvetica Neue,sans-serif!important;font-weight:400!important;line-height:normal!important}@supports (font-variation-settings:normal){body{font-optical-sizing:auto!important;font-family:InterVariable,Noto Color Emoji,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,SF Compact,SF Pro,Helvetica Neue,sans-serif!important}}*{scrollbar-color:initial;scrollbar-width:initial}}@layer components{.chat-loading-gradient{background:linear-gradient(#f8fafccc,#f8fafccc) padding-box padding-box,linear-gradient(45deg,#8b5cf6,#06b6d4,#8b5cf6) 0 0/400% 400% border-box;border:2px solid #0000;animation:2s infinite gradient-animation}.chat-success-border{animation:2s ease-out blink-green-fade}.chat-error-border{animation:1s ease-out blink-red-fade}@keyframes blink-green-fade{0%,50%{box-shadow:0 0 0 2px #22c55eb3}to{box-shadow:0 0 0 2px #22c55e00}}@keyframes blink-red-fade{0%,50%{box-shadow:0 0 0 2px #ef4444}to{box-shadow:0 0 0 2px #ef444400}}@property --chat-grad-bg-bg-color{syntax: "<color>"; inherits: true; initial-value: #0d253f;}@property --chat-grad-bg-c1{syntax: "<color>"; inherits: true; initial-value: #1e40af;}@property --chat-grad-bg-c2{syntax: "<color>"; inherits: true; initial-value: #2563eb;}@property --chat-grad-bg-c3{syntax: "<color>"; inherits: true; initial-value: #3b82f6;}@property --chat-grad-bg-c4{syntax: "<color>"; inherits: true; initial-value: #60a5fa;}@property --chat-grad-bg-opacity-slow{syntax: "<number>"; inherits: true; initial-value: 1;}@property --chat-grad-bg-opacity-medium{syntax: "<number>"; inherits: true; initial-value: 0;}@property --chat-grad-bg-opacity-fast{syntax: "<number>"; inherits: true; initial-value: 0;}@property --chat-grad-bg-overall-opacity{syntax: "<number>"; inherits: true; initial-value: 1;}@keyframes chat-grad-bg-move{0%{transform:translate(0)}20%{transform:translate(15vw,-10vh)scale(1.1)}40%{transform:translate(-10vw,15vh)scale(.9)}60%{transform:translate(10vw,10vh)scale(1.2)}80%{transform:translate(5vw,-15vh)scale(1)}to{transform:translate(0)}}.shape-anim{transition:fill 1s ease-in-out;animation-name:chat-grad-bg-move;animation-timing-function:ease-in-out;animation-iteration-count:infinite}.g-slow{opacity:var(--chat-grad-bg-opacity-slow);transition:opacity 1s ease-in-out}.g-medium{opacity:var(--chat-grad-bg-opacity-medium);transition:opacity 1s ease-in-out}.g-fast{opacity:var(--chat-grad-bg-opacity-fast);transition:opacity 1s ease-in-out}}@layer utilities{.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.-inset-\\[25\\%\\]{top:-25%;right:-25%;bottom:-25%;left:-25%}.inset-0{inset:calc(var(--spacing)*0)}.inset-4{inset:calc(var(--spacing)*4)}.top-0{top:calc(var(--spacing)*0)}.top-0\\.5{top:calc(var(--spacing)*.5)}.top-\\[25\\%\\]{top:25%}.right-0{right:calc(var(--spacing)*0)}.right-12{right:calc(var(--spacing)*12)}.bottom-0{bottom:calc(var(--spacing)*0)}.bottom-3{bottom:calc(var(--spacing)*3)}.left-0{left:calc(var(--spacing)*0)}.left-0\\.5{left:calc(var(--spacing)*.5)}.left-3{left:calc(var(--spacing)*3)}.left-12{left:calc(var(--spacing)*12)}.left-\\[25\\%\\]{left:25%}.-z-10{z-index:-10}.z-0{z-index:0}.z-10{z-index:10}.z-50{z-index:50}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.m-0{margin:calc(var(--spacing)*0)}.m-1{margin:calc(var(--spacing)*1)}.mt-0{margin-top:calc(var(--spacing)*0)}.mt-3{margin-top:calc(var(--spacing)*3)}.mr-px{margin-right:1px}.mb-0{margin-bottom:calc(var(--spacing)*0)}.mb-1\\.5{margin-bottom:calc(var(--spacing)*1.5)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.mb-px{margin-bottom:1px}.scrollbar-thin::-webkit-scrollbar-track{background-color:var(--scrollbar-track);border-radius:var(--scrollbar-track-radius)}.scrollbar-thin::-webkit-scrollbar-thumb{background-color:var(--scrollbar-thumb);border-radius:var(--scrollbar-thumb-radius)}.scrollbar-thin::-webkit-scrollbar-corner{background-color:var(--scrollbar-corner);border-radius:var(--scrollbar-corner-radius)}.scrollbar-thin{scrollbar-width:thin;scrollbar-color:var(--scrollbar-thumb,initial)var(--scrollbar-track,initial)}.scrollbar-thin::-webkit-scrollbar{width:8px;height:8px;display:block}.block{display:block}.contents{display:contents}.flex{display:flex}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.aspect-square{aspect-ratio:1}.size-0{width:calc(var(--spacing)*0);height:calc(var(--spacing)*0)}.size-1\\.5{width:calc(var(--spacing)*1.5);height:calc(var(--spacing)*1.5)}.size-1\\/2{width:50%;height:50%}.size-2\\/3{width:66.6667%;height:66.6667%}.size-3{width:calc(var(--spacing)*3);height:calc(var(--spacing)*3)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-6{width:calc(var(--spacing)*6);height:calc(var(--spacing)*6)}.size-8{width:calc(var(--spacing)*8);height:calc(var(--spacing)*8)}.size-10{width:calc(var(--spacing)*10);height:calc(var(--spacing)*10)}.size-12{width:calc(var(--spacing)*12);height:calc(var(--spacing)*12)}.size-auto{width:auto;height:auto}.size-full{width:100%;height:100%}.\\!h-\\[calc-size\\(auto\\,size\\)\\]{height:calc-size(auto,size)!important}.h-0{height:calc(var(--spacing)*0)}.h-3{height:calc(var(--spacing)*3)}.h-5{height:calc(var(--spacing)*5)}.h-6{height:calc(var(--spacing)*6)}.h-8{height:calc(var(--spacing)*8)}.h-12{height:calc(var(--spacing)*12)}.h-16{height:calc(var(--spacing)*16)}.h-\\[1\\.2em\\]{height:1.2em}.h-\\[35vh\\]{height:35vh}.h-\\[50\\%\\]{height:50%}.h-\\[150\\%\\]{height:150%}.h-\\[calc-size\\(auto\\,size\\)\\]{height:calc-size(auto,size)}.h-auto{height:auto}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-48{max-height:calc(var(--spacing)*48)}.max-h-\\[50vh\\]{max-height:50vh}.max-h-full{max-height:100%}.min-h-0{min-height:calc(var(--spacing)*0)}.min-h-48{min-height:calc(var(--spacing)*48)}.min-h-\\[20vh\\]{min-height:20vh}.w-2{width:calc(var(--spacing)*2)}.w-96{width:calc(var(--spacing)*96)}.w-\\[50\\%\\]{width:50%}.w-\\[150\\%\\]{width:150%}.w-auto{width:auto}.w-fit{width:-moz-fit-content;width:fit-content}.w-full{width:100%}.w-max{width:-moz-max-content;width:max-content}.w-screen{width:100vw}.max-w-8{max-width:calc(var(--spacing)*8)}.max-w-24{max-width:calc(var(--spacing)*24)}.max-w-48{max-width:calc(var(--spacing)*48)}.max-w-90{max-width:calc(var(--spacing)*90)}.max-w-\\[calc\\(100\\%-48px\\)\\]{max-width:calc(100% - 48px)}.max-w-full{max-width:100%}.min-w-3{min-width:calc(var(--spacing)*3)}.min-w-24{min-width:calc(var(--spacing)*24)}.min-w-48{min-width:calc(var(--spacing)*48)}.min-w-\\[8rem\\]{min-width:8rem}.min-w-fit{min-width:-moz-fit-content;min-width:fit-content}.flex-1{flex:1}.flex-shrink-0,.shrink-0{flex-shrink:0}.basis-\\[initial\\]{flex-basis:initial}.origin-bottom{transform-origin:bottom}.origin-center{transform-origin:50%}.origin-left{transform-origin:0}.origin-right{transform-origin:100%}.origin-top{transform-origin:top}.-translate-y-2{--tw-translate-y:calc(var(--spacing)*-2);translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-0{--tw-translate-y:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-2{--tw-translate-y:calc(var(--spacing)*2);translate:var(--tw-translate-x)var(--tw-translate-y)}.scale-0{--tw-scale-x:0%;--tw-scale-y:0%;--tw-scale-z:0%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-25{--tw-scale-x:25%;--tw-scale-y:25%;--tw-scale-z:25%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-50{--tw-scale-x:50%;--tw-scale-y:50%;--tw-scale-z:50%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-95{--tw-scale-x:95%;--tw-scale-y:95%;--tw-scale-z:95%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-100{--tw-scale-x:100%;--tw-scale-y:100%;--tw-scale-z:100%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-110{--tw-scale-x:110%;--tw-scale-y:110%;--tw-scale-z:110%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-x-75{--tw-scale-x:75%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-y-0{--tw-scale-y:0%;scale:var(--tw-scale-x)var(--tw-scale-y)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.animate-pulse{animation:var(--animate-pulse)}.animate-spin{animation:var(--animate-spin)}.cursor-copy{cursor:copy}.cursor-default{cursor:default}.cursor-not-allowed{cursor:not-allowed}.cursor-pointer{cursor:pointer}.resize{resize:both}.resize-none{resize:none}.snap-start{scroll-snap-align:start}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-row{flex-direction:row}.flex-row-reverse{flex-direction:row-reverse}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.items-stretch{align-items:stretch}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.justify-start{justify-content:flex-start}.gap-0{gap:calc(var(--spacing)*0)}.gap-0\\.5{gap:calc(var(--spacing)*.5)}.gap-1{gap:calc(var(--spacing)*1)}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*2)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-y-reverse)))}:where(.divide-y>:not(:last-child)){--tw-divide-y-reverse:0;border-bottom-style:var(--tw-border-style);border-top-style:var(--tw-border-style);border-top-width:calc(1px*var(--tw-divide-y-reverse));border-bottom-width:calc(1px*calc(1 - var(--tw-divide-y-reverse)))}:where(.divide-y-reverse>:not(:last-child)){--tw-divide-y-reverse:1}:where(.divide-border\\/20>:not(:last-child)){border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){:where(.divide-border\\/20>:not(:last-child)){border-color:color-mix(in oklab,var(--color-border)20%,transparent)}}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.overflow-y-scroll{overflow-y:scroll}.overscroll-contain{overscroll-behavior:contain}.rounded-2xl{border-radius:var(--radius-2xl)}.rounded-3xl{border-radius:var(--radius-3xl)}.rounded-\\[inherit\\]{border-radius:inherit}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius-lg)}.rounded-md{border-radius:var(--radius-md)}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.rounded-t-3xl{border-top-left-radius:var(--radius-3xl);border-top-right-radius:var(--radius-3xl)}.rounded-t-\\[inherit\\]{border-top-left-radius:inherit;border-top-right-radius:inherit}.rounded-t-lg{border-top-left-radius:var(--radius-lg);border-top-right-radius:var(--radius-lg)}.rounded-t-none{border-top-left-radius:0;border-top-right-radius:0}.rounded-b-3xl{border-bottom-right-radius:var(--radius-3xl);border-bottom-left-radius:var(--radius-3xl)}.rounded-b-\\[inherit\\]{border-bottom-right-radius:inherit;border-bottom-left-radius:inherit}.rounded-b-lg{border-bottom-right-radius:var(--radius-lg);border-bottom-left-radius:var(--radius-lg)}.border{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-dotted{--tw-border-style:dotted;border-style:dotted}.border-none{--tw-border-style:none;border-style:none}.border-black\\/10{border-color:#0000001a}@supports (color:color-mix(in lab,red,red)){.border-black\\/10{border-color:color-mix(in oklab,var(--color-black)10%,transparent)}}.border-black\\/15{border-color:#00000026}@supports (color:color-mix(in lab,red,red)){.border-black\\/15{border-color:color-mix(in oklab,var(--color-black)15%,transparent)}}.border-blue-500{border-color:var(--color-blue-500)}.border-blue-600\\/70{border-color:#155dfcb3}@supports (color:color-mix(in lab,red,red)){.border-blue-600\\/70{border-color:color-mix(in oklab,var(--color-blue-600)70%,transparent)}}.border-border\\/20{border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){.border-border\\/20{border-color:color-mix(in oklab,var(--color-border)20%,transparent)}}.border-green-500{border-color:var(--color-green-500)}.border-orange-500{border-color:var(--color-orange-500)}.border-pink-500{border-color:var(--color-pink-500)}.border-purple-500{border-color:var(--color-purple-500)}.border-red-500{border-color:var(--color-red-500)}.border-transparent{border-color:#0000}.border-yellow-500{border-color:var(--color-yellow-500)}.border-zinc-100{border-color:var(--color-zinc-100)}.border-zinc-200{border-color:var(--color-zinc-200)}.border-zinc-200\\/80{border-color:#e4e4e7cc}@supports (color:color-mix(in lab,red,red)){.border-zinc-200\\/80{border-color:color-mix(in oklab,var(--color-zinc-200)80%,transparent)}}.border-zinc-500{border-color:var(--color-zinc-500)}.border-zinc-500\\/15{border-color:#71717b26}@supports (color:color-mix(in lab,red,red)){.border-zinc-500\\/15{border-color:color-mix(in oklab,var(--color-zinc-500)15%,transparent)}}.border-zinc-500\\/20{border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){.border-zinc-500\\/20{border-color:color-mix(in oklab,var(--color-zinc-500)20%,transparent)}}.border-zinc-600\\/70{border-color:#52525cb3}@supports (color:color-mix(in lab,red,red)){.border-zinc-600\\/70{border-color:color-mix(in oklab,var(--color-zinc-600)70%,transparent)}}.bg-black\\/5{background-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.bg-black\\/5{background-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.bg-black\\/10{background-color:#0000001a}@supports (color:color-mix(in lab,red,red)){.bg-black\\/10{background-color:color-mix(in oklab,var(--color-black)10%,transparent)}}.bg-blue-400\\/10{background-color:#54a2ff1a}@supports (color:color-mix(in lab,red,red)){.bg-blue-400\\/10{background-color:color-mix(in oklab,var(--color-blue-400)10%,transparent)}}.bg-blue-500{background-color:var(--color-blue-500)}.bg-blue-600{background-color:var(--color-blue-600)}.bg-blue-600\\/5{background-color:#155dfc0d}@supports (color:color-mix(in lab,red,red)){.bg-blue-600\\/5{background-color:color-mix(in oklab,var(--color-blue-600)5%,transparent)}}.bg-blue-600\\/10{background-color:#155dfc1a}@supports (color:color-mix(in lab,red,red)){.bg-blue-600\\/10{background-color:color-mix(in oklab,var(--color-blue-600)10%,transparent)}}.bg-blue-950\\/80{background-color:#162456cc}@supports (color:color-mix(in lab,red,red)){.bg-blue-950\\/80{background-color:color-mix(in oklab,var(--color-blue-950)80%,transparent)}}.bg-green-500{background-color:var(--color-green-500)}.bg-orange-500{background-color:var(--color-orange-500)}.bg-pink-500{background-color:var(--color-pink-500)}.bg-purple-500{background-color:var(--color-purple-500)}.bg-red-500{background-color:var(--color-red-500)}.bg-rose-600{background-color:var(--color-rose-600)}.bg-sky-100\\/60{background-color:#dff2fe99}@supports (color:color-mix(in lab,red,red)){.bg-sky-100\\/60{background-color:color-mix(in oklab,var(--color-sky-100)60%,transparent)}}.bg-transparent{background-color:#0000}.bg-white{background-color:var(--color-white)}.bg-white\\/5{background-color:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.bg-white\\/5{background-color:color-mix(in oklab,var(--color-white)5%,transparent)}}.bg-white\\/30{background-color:#ffffff4d}@supports (color:color-mix(in lab,red,red)){.bg-white\\/30{background-color:color-mix(in oklab,var(--color-white)30%,transparent)}}.bg-white\\/90{background-color:#ffffffe6}@supports (color:color-mix(in lab,red,red)){.bg-white\\/90{background-color:color-mix(in oklab,var(--color-white)90%,transparent)}}.bg-yellow-500{background-color:var(--color-yellow-500)}.bg-zinc-100{background-color:var(--color-zinc-100)}.bg-zinc-500{background-color:var(--color-zinc-500)}.bg-zinc-700\\/80{background-color:#3f3f46cc}@supports (color:color-mix(in lab,red,red)){.bg-zinc-700\\/80{background-color:color-mix(in oklab,var(--color-zinc-700)80%,transparent)}}.bg-gradient-to-b{--tw-gradient-position:to bottom in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-gradient-to-r{--tw-gradient-position:to right in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-radial{--tw-gradient-position:in oklab;background-image:radial-gradient(var(--tw-gradient-stops))}.bg-\\[image\\:var\\(--glass-texture\\)\\]{background-image:var(--glass-texture)}.bg-\\[image\\:var\\(--gradient\\)\\]{background-image:var(--gradient)}.from-transparent{--tw-gradient-from:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-white\\/10{--tw-gradient-from:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.from-white\\/10{--tw-gradient-from:color-mix(in oklab,var(--color-white)10%,transparent)}}.from-white\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-white\\/40{--tw-gradient-from:#fff6}@supports (color:color-mix(in lab,red,red)){.from-white\\/40{--tw-gradient-from:color-mix(in oklab,var(--color-white)40%,transparent)}}.from-white\\/40{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-zinc-100\\/10{--tw-gradient-from:#f4f4f51a}@supports (color:color-mix(in lab,red,red)){.from-zinc-100\\/10{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)10%,transparent)}}.from-zinc-100\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-zinc-100\\/60{--tw-gradient-from:#f4f4f599}@supports (color:color-mix(in lab,red,red)){.from-zinc-100\\/60{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)60%,transparent)}}.from-zinc-100\\/60{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-30\\%{--tw-gradient-from-position:30%}.via-transparent{--tw-gradient-via:transparent;--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-white\\/30{--tw-gradient-via:#ffffff4d}@supports (color:color-mix(in lab,red,red)){.via-white\\/30{--tw-gradient-via:color-mix(in oklab,var(--color-white)30%,transparent)}}.via-white\\/30{--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-zinc-100\\/30{--tw-gradient-via:#f4f4f54d}@supports (color:color-mix(in lab,red,red)){.via-zinc-100\\/30{--tw-gradient-via:color-mix(in oklab,var(--color-zinc-100)30%,transparent)}}.via-zinc-100\\/30{--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.to-transparent{--tw-gradient-to:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-white\\/5{--tw-gradient-to:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.to-white\\/5{--tw-gradient-to:color-mix(in oklab,var(--color-white)5%,transparent)}}.to-white\\/5{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-white\\/10{--tw-gradient-to:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.to-white\\/10{--tw-gradient-to:color-mix(in oklab,var(--color-white)10%,transparent)}}.to-white\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-zinc-50\\/60{--tw-gradient-to:#fafafa99}@supports (color:color-mix(in lab,red,red)){.to-zinc-50\\/60{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-50)60%,transparent)}}.to-zinc-50\\/60{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-zinc-100\\/0{--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.to-zinc-100\\/0{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)0%,transparent)}}.to-zinc-100\\/0{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-zinc-100\\/10{--tw-gradient-to:#f4f4f51a}@supports (color:color-mix(in lab,red,red)){.to-zinc-100\\/10{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)10%,transparent)}}.to-zinc-100\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-75\\%{--tw-gradient-to-position:75%}.mask-\\[linear-gradient\\(to_bottom\\,transparent_0px\\,black_48px\\,black_calc\\(95\\%_-_16px\\)\\,transparent_calc\\(100\\%_-_16px\\)\\)\\]{-webkit-mask-image:linear-gradient(#0000 0,#000 48px calc(95% - 16px),#0000 calc(100% - 16px));mask-image:linear-gradient(#0000 0,#000 48px,#000 calc(95% - 16px),#0000 calc(100% - 16px))}.bg-cover{background-size:cover}.bg-center{background-position:50%}.bg-no-repeat{background-repeat:no-repeat}.mask-alpha{-webkit-mask-source-type:alpha;mask-mode:alpha}.fill-\\[var\\(--active\\)\\]{fill:var(--active)}.fill-current{fill:currentColor}.fill-white{fill:var(--color-white)}.fill-zinc-500\\/50{fill:#71717b80}@supports (color:color-mix(in lab,red,red)){.fill-zinc-500\\/50{fill:color-mix(in oklab,var(--color-zinc-500)50%,transparent)}}.fill-zinc-950{fill:var(--color-zinc-950)}.stroke-\\[var\\(--active\\)\\]{stroke:var(--active)}.stroke-\\[var\\(--primary\\)\\]{stroke:var(--primary)}.stroke-black\\/30{stroke:#0000004d}@supports (color:color-mix(in lab,red,red)){.stroke-black\\/30{stroke:color-mix(in oklab,var(--color-black)30%,transparent)}}.stroke-blue-600{stroke:var(--color-blue-600)}.stroke-fuchsia-700{stroke:var(--color-fuchsia-700)}.stroke-green-600{stroke:var(--color-green-600)}.stroke-none{stroke:none}.stroke-rose-600{stroke:var(--color-rose-600)}.stroke-violet-600{stroke:var(--color-violet-600)}.stroke-white{stroke:var(--color-white)}.stroke-1{stroke-width:1px}.stroke-3{stroke-width:3px}.object-contain{-o-object-fit:contain;object-fit:contain}.p-0{padding:calc(var(--spacing)*0)}.p-0\\.5{padding:calc(var(--spacing)*.5)}.p-1{padding:calc(var(--spacing)*1)}.p-2{padding:calc(var(--spacing)*2)}.px-0\\.5{padding-inline:calc(var(--spacing)*.5)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.py-0{padding-block:calc(var(--spacing)*0)}.py-0\\.5{padding-block:calc(var(--spacing)*.5)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-4{padding-block:calc(var(--spacing)*4)}.pt-1{padding-top:calc(var(--spacing)*1)}.pt-2{padding-top:calc(var(--spacing)*2)}.pt-3{padding-top:calc(var(--spacing)*3)}.pr-3{padding-right:calc(var(--spacing)*3)}.pr-6{padding-right:calc(var(--spacing)*6)}.pb-1{padding-bottom:calc(var(--spacing)*1)}.pb-2{padding-bottom:calc(var(--spacing)*2)}.pb-3{padding-bottom:calc(var(--spacing)*3)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-3{padding-left:calc(var(--spacing)*3)}.pl-4{padding-left:calc(var(--spacing)*4)}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[0\\.5em\\]{font-size:.5em}.leading-relaxed{--tw-leading:var(--leading-relaxed);line-height:var(--leading-relaxed)}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.whitespace-pre-wrap{white-space:pre-wrap}.text-\\[var\\(--active\\)\\]{color:var(--active)}.text-\\[var\\(--primary\\)\\]{color:var(--primary)}.text-blue-500{color:var(--color-blue-500)}.text-blue-600{color:var(--color-blue-600)}.text-current{color:currentColor}.text-foreground{color:var(--color-foreground)}.text-foreground\\/40{color:#09090b66}@supports (color:color-mix(in lab,red,red)){.text-foreground\\/40{color:color-mix(in oklab,var(--color-foreground)40%,transparent)}}.text-foreground\\/60{color:#09090b99}@supports (color:color-mix(in lab,red,red)){.text-foreground\\/60{color:color-mix(in oklab,var(--color-foreground)60%,transparent)}}.text-foreground\\/70{color:#09090bb3}@supports (color:color-mix(in lab,red,red)){.text-foreground\\/70{color:color-mix(in oklab,var(--color-foreground)70%,transparent)}}.text-foreground\\/80{color:#09090bcc}@supports (color:color-mix(in lab,red,red)){.text-foreground\\/80{color:color-mix(in oklab,var(--color-foreground)80%,transparent)}}.text-muted-foreground{color:var(--color-muted-foreground)}.text-white{color:var(--color-white)}.text-zinc-400{color:var(--color-zinc-400)}.text-zinc-500{color:var(--color-zinc-500)}.text-zinc-600{color:var(--color-zinc-600)}.text-zinc-900{color:var(--color-zinc-900)}.text-zinc-950{color:var(--color-zinc-950)}.text-zinc-950\\/70{color:#09090bb3}@supports (color:color-mix(in lab,red,red)){.text-zinc-950\\/70{color:color-mix(in oklab,var(--color-zinc-950)70%,transparent)}}.text-zinc-950\\/80{color:#09090bcc}@supports (color:color-mix(in lab,red,red)){.text-zinc-950\\/80{color:color-mix(in oklab,var(--color-zinc-950)80%,transparent)}}.underline{text-decoration-line:underline}.opacity-0{opacity:0}.opacity-30{opacity:.3}.opacity-50{opacity:.5}.opacity-70{opacity:.7}.opacity-80{opacity:.8}.opacity-100{opacity:1}.shadow-2xs{--tw-shadow:0 1px var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-none{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px var(--tw-shadow-color,#0000001a),0 8px 10px -6px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-1{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-black\\/10{--tw-shadow-color:#0000001a}@supports (color:color-mix(in lab,red,red)){.shadow-black\\/10{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-black)10%,transparent)var(--tw-shadow-alpha),transparent)}}.shadow-black\\/50{--tw-shadow-color:#00000080}@supports (color:color-mix(in lab,red,red)){.shadow-black\\/50{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-black)50%,transparent)var(--tw-shadow-alpha),transparent)}}.shadow-sky-500\\/10{--tw-shadow-color:#00a5ef1a}@supports (color:color-mix(in lab,red,red)){.shadow-sky-500\\/10{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-sky-500)10%,transparent)var(--tw-shadow-alpha),transparent)}}.ring-white\\/20{--tw-ring-color:#fff3}@supports (color:color-mix(in lab,red,red)){.ring-white\\/20{--tw-ring-color:color-mix(in oklab,var(--color-white)20%,transparent)}}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-\\[0\\.2px\\]{--tw-blur:blur(.2px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-md{--tw-blur:blur(var(--blur-md));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-none{--tw-blur: ;filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-sm{--tw-blur:blur(var(--blur-sm));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.brightness-75{--tw-brightness:brightness(75%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.brightness-90{--tw-brightness:brightness(90%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-xl{--tw-drop-shadow-size:drop-shadow(0 9px 7px var(--tw-drop-shadow-color,#0000001a));--tw-drop-shadow:drop-shadow(var(--drop-shadow-xl));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.backdrop-blur-\\[2px\\]{--tw-backdrop-blur:blur(2px);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-blur-lg{--tw-backdrop-blur:blur(var(--blur-lg));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-100{--tw-duration:.1s;transition-duration:.1s}.duration-150{--tw-duration:.15s;transition-duration:.15s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.duration-500{--tw-duration:.5s;transition-duration:.5s}.duration-1000{--tw-duration:1s;transition-duration:1s}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.ease-spring{--tw-ease:var(--ease-spring);transition-timing-function:var(--ease-spring)}.ease-spring-soft{--tw-ease:var(--ease-spring-soft);transition-timing-function:var(--ease-spring-soft)}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.\\[--active-secondary\\:var\\(--color-blue-100\\)\\]{--active-secondary:var(--color-blue-100)}.\\[--active\\:var\\(--color-blue-600\\)\\]{--active:var(--color-blue-600)}.\\[--primary\\:var\\(--color-zinc-950\\)\\]{--primary:var(--color-zinc-950)}.\\[--secondary\\:var\\(--color-zinc-400\\)\\]{--secondary:var(--color-zinc-400)}.scrollbar-thumb-black\\/15{--scrollbar-thumb:oklab(0% none none/.15)}.scrollbar-track-transparent{--scrollbar-track:transparent}:is(.\\*\\:size-full>*){width:100%;height:100%}.before\\:absolute:before{content:var(--tw-content);position:absolute}.before\\:inset-0:before{content:var(--tw-content);inset:calc(var(--spacing)*0)}.before\\:-z-20:before{content:var(--tw-content);z-index:-20}.before\\:size-full:before{content:var(--tw-content);width:100%;height:100%}.before\\:content-normal:before{content:var(--tw-content);align-content:normal}.before\\:rounded-\\[inherit\\]:before{content:var(--tw-content);border-radius:inherit}.before\\:border:before{content:var(--tw-content);border-style:var(--tw-border-style);border-width:1px}.before\\:border-zinc-950\\/20:before{content:var(--tw-content);border-color:#09090b33}@supports (color:color-mix(in lab,red,red)){.before\\:border-zinc-950\\/20:before{border-color:color-mix(in oklab,var(--color-zinc-950)20%,transparent)}}.before\\:bg-white\\/85:before{content:var(--tw-content);background-color:#ffffffd9}@supports (color:color-mix(in lab,red,red)){.before\\:bg-white\\/85:before{background-color:color-mix(in oklab,var(--color-white)85%,transparent)}}.before\\:ring-\\[1\\.5px\\]:before{content:var(--tw-content);--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1.5px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.before\\:ring-white\\/30:before{content:var(--tw-content);--tw-ring-color:#ffffff4d}@supports (color:color-mix(in lab,red,red)){.before\\:ring-white\\/30:before{--tw-ring-color:color-mix(in oklab,var(--color-white)30%,transparent)}}.before\\:backdrop-blur-sm:before{content:var(--tw-content);--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.before\\:ring-inset:before{content:var(--tw-content);--tw-ring-inset:inset}.after\\:pointer-events-none:after{content:var(--tw-content);pointer-events:none}.after\\:absolute:after{content:var(--tw-content);position:absolute}.after\\:inset-0:after{content:var(--tw-content);inset:calc(var(--spacing)*0)}.after\\:block:after{content:var(--tw-content);display:block}.after\\:size-full:after{content:var(--tw-content);width:100%;height:100%}.after\\:content-normal:after{content:var(--tw-content);align-content:normal}.after\\:rounded-\\[inherit\\]:after{content:var(--tw-content);border-radius:inherit}.after\\:bg-gradient-to-b:after{content:var(--tw-content);--tw-gradient-position:to bottom in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.after\\:from-white\\/5:after{content:var(--tw-content);--tw-gradient-from:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.after\\:from-white\\/5:after{--tw-gradient-from:color-mix(in oklab,var(--color-white)5%,transparent)}}.after\\:from-white\\/5:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.after\\:to-white\\/0:after{content:var(--tw-content);--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.after\\:to-white\\/0:after{--tw-gradient-to:color-mix(in oklab,var(--color-white)0%,transparent)}}.after\\:to-white\\/0:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.after\\:shadow-glass:after{content:var(--tw-content);--tw-shadow:var(--shadow-lg),0px -48px 48px -48px var(--tw-shadow-color,#0000000d)inset,0 5px 42px -5px var(--tw-shadow-color,#ffffff40)inset;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.after\\:transition-colors:after{content:var(--tw-content);transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.after\\:duration-150:after{content:var(--tw-content);--tw-duration:.15s;transition-duration:.15s}.after\\:ease-out:after{content:var(--tw-content);--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.focus-within\\:outline-none:focus-within{--tw-outline-style:none;outline-style:none}@media (hover:hover){.hover\\:border-black\\/5:hover{border-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.hover\\:border-black\\/5:hover{border-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.hover\\:border-border\\/40:hover{border-color:#71717b66}@supports (color:color-mix(in lab,red,red)){.hover\\:border-border\\/40:hover{border-color:color-mix(in oklab,var(--color-border)40%,transparent)}}.hover\\:border-rose-600\\/70:hover{border-color:#e70044b3}@supports (color:color-mix(in lab,red,red)){.hover\\:border-rose-600\\/70:hover{border-color:color-mix(in oklab,var(--color-rose-600)70%,transparent)}}.hover\\:border-zinc-300:hover{border-color:var(--color-zinc-300)}.hover\\:bg-blue-400\\/10:hover{background-color:#54a2ff1a}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-blue-400\\/10:hover{background-color:color-mix(in oklab,var(--color-blue-400)10%,transparent)}}.hover\\:bg-rose-600\\/5:hover{background-color:#e700440d}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-rose-600\\/5:hover{background-color:color-mix(in oklab,var(--color-rose-600)5%,transparent)}}.hover\\:bg-white:hover{background-color:var(--color-white)}.hover\\:bg-white\\/0:hover{background-color:#0000}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-white\\/0:hover{background-color:color-mix(in oklab,var(--color-white)0%,transparent)}}.hover\\:bg-white\\/80:hover{background-color:#fffc}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-white\\/80:hover{background-color:color-mix(in oklab,var(--color-white)80%,transparent)}}.hover\\:bg-zinc-100\\/80:hover{background-color:#f4f4f5cc}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-zinc-100\\/80:hover{background-color:color-mix(in oklab,var(--color-zinc-100)80%,transparent)}}.hover\\:bg-zinc-200:hover{background-color:var(--color-zinc-200)}.hover\\:bg-zinc-950\\/10:hover{background-color:#09090b1a}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-zinc-950\\/10:hover{background-color:color-mix(in oklab,var(--color-zinc-950)10%,transparent)}}.hover\\:from-zinc-100\\/40:hover{--tw-gradient-from:#f4f4f566}@supports (color:color-mix(in lab,red,red)){.hover\\:from-zinc-100\\/40:hover{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)40%,transparent)}}.hover\\:from-zinc-100\\/40:hover{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\:from-20\\%:hover{--tw-gradient-from-position:20%}.hover\\:to-zinc-100\\/0:hover{--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.hover\\:to-zinc-100\\/0:hover{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)0%,transparent)}}.hover\\:to-zinc-100\\/0:hover{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\:to-75\\%:hover{--tw-gradient-to-position:75%}.hover\\:text-red-500:hover{color:var(--color-red-500)}.hover\\:text-zinc-900:hover{color:var(--color-zinc-900)}.hover\\:opacity-90:hover{opacity:.9}.hover\\:opacity-100:hover{opacity:1}.hover\\:shadow-lg:hover{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\:shadow-md:hover{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\:shadow-none:hover{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\:shadow-xs:hover{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\:after\\:from-blue-50\\/20:hover:after{content:var(--tw-content);--tw-gradient-from:#eff6ff33}@supports (color:color-mix(in lab,red,red)){.hover\\:after\\:from-blue-50\\/20:hover:after{--tw-gradient-from:color-mix(in oklab,var(--color-blue-50)20%,transparent)}}.hover\\:after\\:from-blue-50\\/20:hover:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\:after\\:to-blue-50\\/15:hover:after{content:var(--tw-content);--tw-gradient-to:#eff6ff26}@supports (color:color-mix(in lab,red,red)){.hover\\:after\\:to-blue-50\\/15:hover:after{--tw-gradient-to:color-mix(in oklab,var(--color-blue-50)15%,transparent)}}.hover\\:after\\:to-blue-50\\/15:hover:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}}.focus\\:border-blue-400:focus{border-color:var(--color-blue-400)}.focus\\:text-zinc-900:focus{color:var(--color-zinc-900)}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-blue-500\\/20:focus{--tw-ring-color:#3080ff33}@supports (color:color-mix(in lab,red,red)){.focus\\:ring-blue-500\\/20:focus{--tw-ring-color:color-mix(in oklab,var(--color-blue-500)20%,transparent)}}.focus\\:outline-none:focus{--tw-outline-style:none;outline-style:none}.active\\:scale-\\[98\\%\\]:active{scale:98%}.active\\:border-black\\/15:active{border-color:#00000026}@supports (color:color-mix(in lab,red,red)){.active\\:border-black\\/15:active{border-color:color-mix(in oklab,var(--color-black)15%,transparent)}}.active\\:after\\:from-transparent:active:after{content:var(--tw-content);--tw-gradient-from:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.active\\:after\\:to-transparent:active:after{content:var(--tw-content);--tw-gradient-to:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:bg-black\\/5:disabled{background-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.disabled\\:bg-black\\/5:disabled{background-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.disabled\\:text-foreground\\/60:disabled{color:#09090b99}@supports (color:color-mix(in lab,red,red)){.disabled\\:text-foreground\\/60:disabled{color:color-mix(in oklab,var(--color-foreground)60%,transparent)}}.disabled\\:opacity-30:disabled{opacity:.3}.data-focus\\:outline-none[data-focus]{--tw-outline-style:none;outline-style:none}.data-\\[focused\\]\\:bg-zinc-100\\/80[data-focused]{background-color:#f4f4f5cc}@supports (color:color-mix(in lab,red,red)){.data-\\[focused\\]\\:bg-zinc-100\\/80[data-focused]{background-color:color-mix(in oklab,var(--color-zinc-100)80%,transparent)}}.data-\\[selected\\]\\:bg-blue-600[data-selected]{background-color:var(--color-blue-600)}.data-\\[selected\\]\\:text-white[data-selected]{color:var(--color-white)}.data-\\[selected\\]\\:data-\\[focused\\]\\:bg-blue-600[data-selected][data-focused]{background-color:var(--color-blue-600)}.animate-shake{animation:.5s ease-in-out 2 shake}}:root{color-scheme:normal;font-feature-settings:"liga" 1,"calt" 1;background-color:#0000}body{background-color:#0000}@keyframes shake{0%,to{transform:translate(0)}10%,30%,50%,70%,90%{transform:translate(-2px)}20%,40%,60%,80%{transform:translate(2px)}}@keyframes gradient-animation{0%{background-position:0%}50%{background-position:100%}to{background-position:0%}}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-scale-x{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-y{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-z{syntax:"*";inherits:false;initial-value:1}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-divide-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-gradient-position{syntax:"*";inherits:false}@property --tw-gradient-from{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-via{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-to{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-stops{syntax:"*";inherits:false}@property --tw-gradient-via-stops{syntax:"*";inherits:false}@property --tw-gradient-from-position{syntax:"<length-percentage>";inherits:false;initial-value:0%}@property --tw-gradient-via-position{syntax:"<length-percentage>";inherits:false;initial-value:50%}@property --tw-gradient-to-position{syntax:"<length-percentage>";inherits:false;initial-value:100%}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}@property --tw-content{syntax:"*";inherits:false;initial-value:""}@keyframes spin{to{transform:rotate(360deg)}}@keyframes pulse{50%{opacity:.5}}';
class DoubleIndexedKV {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.keyToValue.set(key, value), this.valueToKey.set(value, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value) {
    return this.valueToKey.get(value);
  }
  clear() {
    this.keyToValue.clear(), this.valueToKey.clear();
  }
}
class Registry {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier, this.kv = new DoubleIndexedKV();
  }
  register(value, identifier) {
    this.kv.getByValue(value) || (identifier || (identifier = this.generateIdentifier(value)), this.kv.set(identifier, value));
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value) {
    return this.kv.getByValue(value);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
}
class ClassRegistry extends Registry {
  constructor() {
    super((c2) => c2.name), this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(value, options) {
    typeof options == "object" ? (options.allowProps && this.classToAllowedProps.set(value, options.allowProps), super.register(value, options.identifier)) : super.register(value, options);
  }
  getAllowedProps(value) {
    return this.classToAllowedProps.get(value);
  }
}
function valuesOfObj(record) {
  if ("values" in Object)
    return Object.values(record);
  const values = [];
  for (const key in record)
    record.hasOwnProperty(key) && values.push(record[key]);
  return values;
}
function find(record, predicate) {
  const values = valuesOfObj(record);
  if ("find" in values)
    return values.find(predicate);
  const valuesNotNever = values;
  for (let i2 = 0; i2 < valuesNotNever.length; i2++) {
    const value = valuesNotNever[i2];
    if (predicate(value))
      return value;
  }
}
function forEach(record, run) {
  Object.entries(record).forEach(([key, value]) => run(value, key));
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (let i2 = 0; i2 < record.length; i2++) {
    const value = record[i2];
    if (predicate(value))
      return value;
  }
}
class CustomTransformerRegistry {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v2) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v2));
  }
  findByName(name) {
    return this.transfomers[name];
  }
}
const getType$1 = (payload) => Object.prototype.toString.call(payload).slice(8, -1), isUndefined = (payload) => typeof payload > "u", isNull = (payload) => payload === null, isPlainObject$2 = (payload) => typeof payload != "object" || payload === null || payload === Object.prototype ? !1 : Object.getPrototypeOf(payload) === null ? !0 : Object.getPrototypeOf(payload) === Object.prototype, isEmptyObject = (payload) => isPlainObject$2(payload) && Object.keys(payload).length === 0, isArray$1 = (payload) => Array.isArray(payload), isString = (payload) => typeof payload == "string", isNumber = (payload) => typeof payload == "number" && !isNaN(payload), isBoolean = (payload) => typeof payload == "boolean", isRegExp = (payload) => payload instanceof RegExp, isMap$1 = (payload) => payload instanceof Map, isSet$1 = (payload) => payload instanceof Set, isSymbol = (payload) => getType$1(payload) === "Symbol", isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf()), isError = (payload) => payload instanceof Error, isNaNValue = (payload) => typeof payload == "number" && isNaN(payload), isPrimitive = (payload) => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload), isBigint = (payload) => typeof payload == "bigint", isInfinite = (payload) => payload === 1 / 0 || payload === -1 / 0, isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView), isURL = (payload) => payload instanceof URL, escapeKey = (key) => key.replace(/\./g, "\\."), stringifyPath = (path) => path.map(String).map(escapeKey).join("."), parsePath = (string) => {
  const result = [];
  let segment = "";
  for (let i2 = 0; i2 < string.length; i2++) {
    let char = string.charAt(i2);
    if (char === "\\" && string.charAt(i2 + 1) === ".") {
      segment += ".", i2++;
      continue;
    }
    if (char === ".") {
      result.push(segment), segment = "";
      continue;
    }
    segment += char;
  }
  const lastSegment = segment;
  return result.push(lastSegment), result;
};
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
const simpleRules = [
  simpleTransformation(isUndefined, "undefined", () => null, () => {
  }),
  simpleTransformation(isBigint, "bigint", (v2) => v2.toString(), (v2) => typeof BigInt < "u" ? BigInt(v2) : (console.error("Please add a BigInt polyfill."), v2)),
  simpleTransformation(isDate, "Date", (v2) => v2.toISOString(), (v2) => new Date(v2)),
  simpleTransformation(isError, "Error", (v2, superJson) => {
    const baseError = {
      name: v2.name,
      message: v2.message
    };
    return superJson.allowedErrorProps.forEach((prop) => {
      baseError[prop] = v2[prop];
    }), baseError;
  }, (v2, superJson) => {
    const e2 = new Error(v2.message);
    return e2.name = v2.name, e2.stack = v2.stack, superJson.allowedErrorProps.forEach((prop) => {
      e2[prop] = v2[prop];
    }), e2;
  }),
  simpleTransformation(isRegExp, "regexp", (v2) => "" + v2, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/")), flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet$1,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (v2) => [...v2.values()],
    (v2) => new Set(v2)
  ),
  simpleTransformation(isMap$1, "map", (v2) => [...v2.entries()], (v2) => new Map(v2)),
  simpleTransformation((v2) => isNaNValue(v2) || isInfinite(v2), "number", (v2) => isNaNValue(v2) ? "NaN" : v2 > 0 ? "Infinity" : "-Infinity", Number),
  simpleTransformation((v2) => v2 === 0 && 1 / v2 === -1 / 0, "number", () => "-0", Number),
  simpleTransformation(isURL, "URL", (v2) => v2.toString(), (v2) => new URL(v2))
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
const symbolRule = compositeTransformation((s2, superJson) => isSymbol(s2) ? !!superJson.symbolRegistry.getIdentifier(s2) : !1, (s2, superJson) => ["symbol", superJson.symbolRegistry.getIdentifier(s2)], (v2) => v2.description, (_2, a2, superJson) => {
  const value = superJson.symbolRegistry.getValue(a2[1]);
  if (!value)
    throw new Error("Trying to deserialize unknown symbol");
  return value;
}), constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((obj, ctor) => (obj[ctor.name] = ctor, obj), {}), typedArrayRule = compositeTransformation(isTypedArray, (v2) => ["typed-array", v2.constructor.name], (v2) => [...v2], (v2, a2) => {
  const ctor = constructorToName[a2[1]];
  if (!ctor)
    throw new Error("Trying to deserialize unknown typed array");
  return new ctor(v2);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  return potentialClass != null && potentialClass.constructor ? !!superJson.classRegistry.getIdentifier(potentialClass.constructor) : !1;
}
const classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => ["class", superJson.classRegistry.getIdentifier(clazz.constructor)], (clazz, superJson) => {
  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps)
    return { ...clazz };
  const result = {};
  return allowedProps.forEach((prop) => {
    result[prop] = clazz[prop];
  }), result;
}, (v2, a2, superJson) => {
  const clazz = superJson.classRegistry.getValue(a2[1]);
  if (!clazz)
    throw new Error(`Trying to deserialize unknown class '${a2[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  return Object.assign(Object.create(clazz.prototype), v2);
}), customRule = compositeTransformation((value, superJson) => !!superJson.customTransformerRegistry.findApplicable(value), (value, superJson) => ["custom", superJson.customTransformerRegistry.findApplicable(value).name], (value, superJson) => superJson.customTransformerRegistry.findApplicable(value).serialize(value), (v2, a2, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a2[1]);
  if (!transformer)
    throw new Error("Trying to deserialize unknown custom value");
  return transformer.deserialize(v2);
}), compositeRules = [classRule, symbolRule, customRule, typedArrayRule], transformValue = (value, superJson) => {
  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableCompositeRule)
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableSimpleRule)
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
}, simpleRulesByAnnotation = {};
simpleRules.forEach((rule) => {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
const untransformValue = (json, type, superJson) => {
  if (isArray$1(type))
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  else {
    const transformation = simpleRulesByAnnotation[type];
    if (!transformation)
      throw new Error("Unknown transformation: " + type);
    return transformation.untransform(json, superJson);
  }
}, getNthKey = (value, n2) => {
  if (n2 > value.size)
    throw new Error("index out of bounds");
  const keys = value.keys();
  for (; n2 > 0; )
    keys.next(), n2--;
  return keys.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__"))
    throw new Error("__proto__ is not allowed as a property");
  if (includes(path, "prototype"))
    throw new Error("prototype is not allowed as a property");
  if (includes(path, "constructor"))
    throw new Error("constructor is not allowed as a property");
}
const getDeep = (object, path) => {
  validatePath(path);
  for (let i2 = 0; i2 < path.length; i2++) {
    const key = path[i2];
    if (isSet$1(object))
      object = getNthKey(object, +key);
    else if (isMap$1(object)) {
      const row = +key, type = +path[++i2] == 0 ? "key" : "value", keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else
      object = object[key];
  }
  return object;
}, setDeep = (object, path, mapper) => {
  if (validatePath(path), path.length === 0)
    return mapper(object);
  let parent = object;
  for (let i2 = 0; i2 < path.length - 1; i2++) {
    const key = path[i2];
    if (isArray$1(parent)) {
      const index2 = +key;
      parent = parent[index2];
    } else if (isPlainObject$2(parent))
      parent = parent[key];
    else if (isSet$1(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap$1(parent)) {
      if (i2 === path.length - 2)
        break;
      const row = +key, type = +path[++i2] == 0 ? "key" : "value", keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  const lastKey = path[path.length - 1];
  if (isArray$1(parent) ? parent[+lastKey] = mapper(parent[+lastKey]) : isPlainObject$2(parent) && (parent[lastKey] = mapper(parent[lastKey])), isSet$1(parent)) {
    const oldValue = getNthKey(parent, +lastKey), newValue = mapper(oldValue);
    oldValue !== newValue && (parent.delete(oldValue), parent.add(newValue));
  }
  if (isMap$1(parent)) {
    const row = +path[path.length - 2], keyToRow = getNthKey(parent, row);
    switch (+lastKey == 0 ? "key" : "value") {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow)), newKey !== keyToRow && parent.delete(keyToRow);
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};
function traverse(tree, walker2, origin = []) {
  if (!tree)
    return;
  if (!isArray$1(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));
    return;
  }
  const [nodeValue, children] = tree;
  children && forEach(children, (child, key) => {
    traverse(child, walker2, [...origin, ...parsePath(key)]);
  }), walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  return traverse(annotations, (type, path) => {
    plain = setDeep(plain, path, (v2) => untransformValue(v2, type, superJson));
  }), plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    const object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach((identicalObjectPath) => {
      plain = setDeep(plain, identicalObjectPath, () => object);
    });
  }
  if (isArray$1(annotations)) {
    const [root, other] = annotations;
    root.forEach((identicalPath) => {
      plain = setDeep(plain, parsePath(identicalPath), () => plain);
    }), other && forEach(other, apply);
  } else
    forEach(annotations, apply);
  return plain;
}
const isDeep = (object, superJson) => isPlainObject$2(object) || isArray$1(object) || isMap$1(object) || isSet$1(object) || isInstanceOfRegisteredClass(object, superJson);
function addIdentity(object, path, identities) {
  const existingSet = identities.get(object);
  existingSet ? existingSet.push(path) : identities.set(object, [path]);
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result = {};
  let rootEqualityPaths;
  return identitites.forEach((paths) => {
    if (paths.length <= 1)
      return;
    dedupe || (paths = paths.map((path) => path.map(String)).sort((a2, b) => a2.length - b.length));
    const [representativePath, ...identicalPaths] = paths;
    representativePath.length === 0 ? rootEqualityPaths = identicalPaths.map(stringifyPath) : result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
  }), rootEqualityPaths ? isEmptyObject(result) ? [rootEqualityPaths] : [rootEqualityPaths, result] : isEmptyObject(result) ? void 0 : result;
}
const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
  const primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    const seen = seenObjects.get(object);
    if (seen)
      return dedupe ? {
        transformedValue: null
      } : seen;
  }
  if (!isDeep(object, superJson)) {
    const transformed2 = transformValue(object, superJson), result2 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object
    };
    return primitive || seenObjects.set(object, result2), result2;
  }
  if (includes(objectsInThisPath, object))
    return {
      transformedValue: null
    };
  const transformationResult = transformValue(object, superJson), transformed = (transformationResult == null ? void 0 : transformationResult.value) ?? object, transformedValue = isArray$1(transformed) ? [] : {}, innerAnnotations = {};
  forEach(transformed, (value, index2) => {
    if (index2 === "__proto__" || index2 === "constructor" || index2 === "prototype")
      throw new Error(`Detected property ${index2}. This is a prototype pollution risk, please remove it from your object.`);
    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index2], [...objectsInThisPath, object], seenObjects);
    transformedValue[index2] = recursiveResult.transformedValue, isArray$1(recursiveResult.annotations) ? innerAnnotations[index2] = recursiveResult.annotations : isPlainObject$2(recursiveResult.annotations) && forEach(recursiveResult.annotations, (tree, key) => {
      innerAnnotations[escapeKey(index2) + "." + key] = tree;
    });
  });
  const result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  return primitive || seenObjects.set(object, result), result;
};
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray(payload) {
  return getType(payload) === "Array";
}
function isPlainObject$1(payload) {
  if (getType(payload) !== "Object")
    return !1;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  propType === "enumerable" && (carry[key] = newVal), includeNonenumerable && propType === "nonenumerable" && Object.defineProperty(carry, key, {
    value: newVal,
    enumerable: !1,
    writable: !0,
    configurable: !0
  });
}
function copy(target, options = {}) {
  if (isArray(target))
    return target.map((item) => copy(item, options));
  if (!isPlainObject$1(target))
    return target;
  const props = Object.getOwnPropertyNames(target), symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray(options.props) && !options.props.includes(key))
      return carry;
    const val = target[key], newVal = copy(val, options);
    return assignProp(carry, key, newVal, target, options.nonenumerable), carry;
  }, {});
}
class SuperJSON {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe = !1 } = {}) {
    this.classRegistry = new ClassRegistry(), this.symbolRegistry = new Registry((s2) => s2.description ?? ""), this.customTransformerRegistry = new CustomTransformerRegistry(), this.allowedErrorProps = [], this.dedupe = dedupe;
  }
  serialize(object) {
    const identities = /* @__PURE__ */ new Map(), output = walker(object, identities, this, this.dedupe), res = {
      json: output.transformedValue
    };
    output.annotations && (res.meta = {
      ...res.meta,
      values: output.annotations
    });
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    return equalityAnnotations && (res.meta = {
      ...res.meta,
      referentialEqualities: equalityAnnotations
    }), res;
  }
  deserialize(payload) {
    const { json, meta } = payload;
    let result = copy(json);
    return meta != null && meta.values && (result = applyValueAnnotations(result, meta.values, this)), meta != null && meta.referentialEqualities && (result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities)), result;
  }
  stringify(object) {
    return JSON.stringify(this.serialize(object));
  }
  parse(string) {
    return this.deserialize(JSON.parse(string));
  }
  registerClass(v2, options) {
    this.classRegistry.register(v2, options);
  }
  registerSymbol(v2, identifier) {
    this.symbolRegistry.register(v2, identifier);
  }
  registerCustom(transformer, name) {
    this.customTransformerRegistry.register({
      name,
      ...transformer
    });
  }
  allowErrorProps(...props) {
    this.allowedErrorProps.push(...props);
  }
}
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2)
  byteToHex.push((i2 + 256).toString(16).slice(1));
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = { randomUUID };
function v4(options, buf, offset2) {
  var _a;
  if (native.randomUUID && !options)
    return native.randomUUID();
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, unsafeStringify(rnds);
}
var __defProp2 = Object.defineProperty, __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key != "symbol" ? key + "" : key, value), define_process_default = { env: { NODE_ENV: "production" } };
function serializeMessage(message) {
  return SuperJSON.stringify(message);
}
function deserializeMessage(data) {
  const parsed = SuperJSON.parse(data);
  if (!parsed.type)
    throw new Error("Invalid WebSocket message: missing type");
  if (!parsed.data)
    throw new Error("Invalid WebSocket message: missing data");
  return parsed;
}
function createRPCCallMessage(rpcCallId, procedurePath, parameters) {
  return {
    type: "rpc_call",
    data: {
      rpcCallId,
      procedurePath,
      parameters
    }
  };
}
function createRPCReturnMessage(rpcCallId, value) {
  return {
    type: "rpc_return",
    data: {
      rpcCallId,
      value
    }
  };
}
function createRPCExceptionMessage(rpcCallId, error2) {
  const serializedError = {
    ...error2,
    name: error2.name,
    message: error2.message,
    stack: error2.stack
  };
  return {
    type: "rpc_exception",
    data: {
      rpcCallId,
      error: serializedError
    }
  };
}
function isRPCCallMessage(message) {
  return message.type === "rpc_call";
}
function isRPCReturnMessage(message) {
  return message.type === "rpc_return";
}
function isRPCExceptionMessage(message) {
  return message.type === "rpc_exception";
}
function isStateSyncMessage(message) {
  return message.type === "state_sync";
}
function isStatePatchMessage(message) {
  return message.type === "state_patch";
}
var WebSocketConnection = class {
  constructor(websocket) {
    __publicField2(this, "ws"), __publicField2(this, "state"), __publicField2(this, "messageQueue", []), __publicField2(this, "messageHandlers", /* @__PURE__ */ new Set()), __publicField2(this, "openHandlers", /* @__PURE__ */ new Set()), __publicField2(this, "closeHandlers", /* @__PURE__ */ new Set()), __publicField2(this, "errorHandlers", /* @__PURE__ */ new Set()), __publicField2(this, "handleOpen", () => {
      for (this.state = "OPEN"; this.messageQueue.length > 0; ) {
        const message = this.messageQueue.shift();
        message && this.sendImmediate(message);
      }
      this.openHandlers.forEach((handler) => handler());
    }), __publicField2(this, "handleClose", (event) => {
      this.state = "CLOSED", this.messageQueue = [], this.closeHandlers.forEach(
        (handler) => handler({ code: event.code, reason: event.reason })
      );
    }), __publicField2(this, "handleError", (error2) => {
      const err = error2 instanceof Error ? error2 : new Error("WebSocket error");
      this.errorHandlers.forEach((handler) => handler(err));
    }), __publicField2(this, "handleMessage", (event) => {
      try {
        const message = deserializeMessage(event.data);
        this.messageHandlers.forEach((handler) => handler(message));
      } catch (error2) {
        console.error("Failed to deserialize WebSocket message:", error2), this.handleError(error2);
      }
    }), this.ws = websocket, this.state = "CONNECTING", this.setupEventListeners(), typeof define_process_default < "u" && define_process_default.nextTick ? define_process_default.nextTick(() => {
      this.ws.readyState === 1 ? this.handleOpen() : this.ws.readyState === 3 && this.handleClose({ code: 1006, reason: "Connection already closed" });
    }) : setTimeout(() => {
      this.ws.readyState === 1 ? this.handleOpen() : this.ws.readyState === 3 && this.handleClose({ code: 1006, reason: "Connection already closed" });
    }, 0);
  }
  setupEventListeners() {
    this.ws.addEventListener("open", this.handleOpen), this.ws.addEventListener("close", this.handleClose), this.ws.addEventListener("error", this.handleError), this.ws.addEventListener("message", this.handleMessage);
  }
  cleanupEventListeners() {
    this.ws.removeEventListener("open", this.handleOpen), this.ws.removeEventListener("close", this.handleClose), this.ws.removeEventListener("error", this.handleError), this.ws.removeEventListener("message", this.handleMessage);
  }
  sendImmediate(message) {
    const serialized = serializeMessage(message);
    this.ws.send(serialized);
  }
  send(message) {
    if (this.state === "CLOSED")
      throw new Error("Connection is closed");
    this.state === "OPEN" && this.ws.readyState === 1 ? this.sendImmediate(message) : this.messageQueue.push(message);
  }
  onMessage(handler) {
    return this.messageHandlers.add(handler), () => {
      this.messageHandlers.delete(handler);
    };
  }
  onOpen(handler) {
    return this.openHandlers.add(handler), () => {
      this.openHandlers.delete(handler);
    };
  }
  onClose(handler) {
    return this.closeHandlers.add(handler), () => {
      this.closeHandlers.delete(handler);
    };
  }
  onError(handler) {
    return this.errorHandlers.add(handler), () => {
      this.errorHandlers.delete(handler);
    };
  }
  getState() {
    return this.state;
  }
  isOpen() {
    return this.state === "OPEN";
  }
  close() {
    (this.ws.readyState === 1 || this.ws.readyState === 0) && this.ws.close(), this.messageQueue = [], this.cleanupEventListeners();
  }
}, KartonRPCException = class extends Error {
  constructor(reason, procedurePath, clientId) {
    const procedureName = procedurePath.join(".");
    let message;
    switch (reason) {
      case "CONNECTION_LOST":
        message = `RPC call to '${procedureName}' failed: Connection lost`;
        break;
      case "CLIENT_NOT_FOUND":
        message = `RPC call to '${procedureName}' failed: Client '${clientId}' not found`;
        break;
      case "SERVER_UNAVAILABLE":
        message = `RPC call to '${procedureName}' failed: Server unavailable`;
        break;
    }
    super(message), __publicField2(this, "reason"), __publicField2(this, "procedurePath"), __publicField2(this, "clientId"), this.name = "KartonRPCException", this.reason = reason, this.procedurePath = procedurePath, this.clientId = clientId;
  }
}, RPCManager = class {
  // 30 seconds
  constructor(sendMessage) {
    __publicField2(this, "pendingCalls", /* @__PURE__ */ new Map()), __publicField2(this, "procedures", /* @__PURE__ */ new Map()), __publicField2(this, "sendMessage"), __publicField2(this, "defaultTimeout", 3e4), this.sendMessage = sendMessage;
  }
  async call(procedurePath, parameters, options = {}) {
    const rpcCallId = v4(), timeout = options.timeout ?? this.defaultTimeout;
    return new Promise((resolve, reject) => {
      const timeoutHandle = setTimeout(() => {
        this.pendingCalls.delete(rpcCallId), reject(
          new KartonRPCException(
            "CONNECTION_LOST",
            procedurePath,
            options.clientId
          )
        );
      }, timeout);
      this.pendingCalls.set(rpcCallId, {
        resolve,
        reject,
        timeout: timeoutHandle,
        procedurePath,
        clientId: options.clientId
      });
      const message = createRPCCallMessage(
        rpcCallId,
        procedurePath,
        parameters
      );
      this.sendMessage(message);
    });
  }
  registerProcedure(path, handler) {
    const key = path.join(".");
    this.procedures.set(key, handler);
  }
  async handleMessage(message) {
    isRPCCallMessage(message) ? await this.handleRPCCall(message) : isRPCReturnMessage(message) ? this.handleRPCReturn(message) : isRPCExceptionMessage(message) && this.handleRPCException(message);
  }
  async handleRPCCall(message) {
    const { rpcCallId, procedurePath, parameters } = message.data, key = procedurePath.join("."), handler = this.procedures.get(key);
    if (!handler) {
      const error2 = new Error(`Procedure not found: ${key}`), exceptionMessage = createRPCExceptionMessage(rpcCallId, error2);
      this.sendMessage(exceptionMessage);
      return;
    }
    try {
      const result = await handler(...parameters), returnMessage = createRPCReturnMessage(rpcCallId, result);
      this.sendMessage(returnMessage);
    } catch (error2) {
      const err = error2 instanceof Error ? error2 : new Error(String(error2)), exceptionMessage = createRPCExceptionMessage(rpcCallId, err);
      this.sendMessage(exceptionMessage);
    }
  }
  handleRPCReturn(message) {
    const { rpcCallId, value } = message.data, pendingCall = this.pendingCalls.get(rpcCallId);
    pendingCall && (clearTimeout(pendingCall.timeout), this.pendingCalls.delete(rpcCallId), pendingCall.resolve(value));
  }
  handleRPCException(message) {
    const { rpcCallId, error: error2 } = message.data, pendingCall = this.pendingCalls.get(rpcCallId);
    if (pendingCall) {
      clearTimeout(pendingCall.timeout), this.pendingCalls.delete(rpcCallId);
      const reconstructedError = Object.assign(new Error(error2.message), error2);
      pendingCall.reject(reconstructedError);
    }
  }
  cleanup() {
    for (const [_callId, pendingCall] of this.pendingCalls)
      clearTimeout(pendingCall.timeout), pendingCall.reject(
        new KartonRPCException(
          "CONNECTION_LOST",
          pendingCall.procedurePath,
          pendingCall.clientId
        )
      );
    this.pendingCalls.clear(), this.procedures.clear();
  }
}, NOTHING = Symbol.for("immer-nothing"), DRAFTABLE = Symbol.for("immer-draftable"), DRAFT_STATE = Symbol.for("immer-state");
function die(error2, ...args) {
  throw new Error(
    `[Immer] minified error nr: ${error2}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _a;
  return value ? isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) != null && _a[DRAFTABLE]) || isMap(value) || isSet(value) : !1;
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || typeof value != "object")
    return !1;
  const proto = getPrototypeOf(value);
  if (proto === null)
    return !0;
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return Ctor === Object ? !0 : typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  getArchtype(obj) === 0 ? Reflect.ownKeys(obj).forEach((key) => {
    iter(key, obj[key], obj);
  }) : obj.forEach((entry, index2) => iter(index2, entry, obj));
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
  return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
}
function set$2(thing, propOrOldValue, value) {
  const t2 = getArchtype(thing);
  t2 === 2 ? thing.set(propOrOldValue, value) : t2 === 3 ? thing.add(value) : thing[propOrOldValue] = value;
}
function is(x, y2) {
  return x === y2 ? x !== 0 || 1 / x === 1 / y2 : x !== x && y2 !== y2;
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base))
    return new Map(base);
  if (isSet(base))
    return new Set(base);
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === !0 || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2], desc = descriptors[key];
      desc.writable === !1 && (desc.writable = !0, desc.configurable = !0), (desc.get || desc.set) && (descriptors[key] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: desc.enumerable,
        value: base[key]
      });
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain)
      return { ...base };
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = !1) {
  return isFrozen(obj) || isDraft(obj) || !isDraftable(obj) || (getArchtype(obj) > 1 && (obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections), Object.freeze(obj), deep && Object.entries(obj).forEach(([key, value]) => freeze(value, !0))), obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  return plugin || die(0, pluginKey), plugin;
}
function loadPlugin(pluginKey, implementation) {
  plugins[pluginKey] || (plugins[pluginKey] = implementation);
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  patchListener && (getPlugin("Patches"), scope.patches_ = [], scope.inversePatches_ = [], scope.patchListener_ = patchListener);
}
function revokeScope(scope) {
  leaveScope(scope), scope.drafts_.forEach(revokeDraft), scope.drafts_ = null;
}
function leaveScope(scope) {
  scope === currentScope && (currentScope = scope.parent_);
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  state.type_ === 0 || state.type_ === 1 ? state.revoke_() : state.revoked_ = !0;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  return result !== void 0 && result !== baseDraft ? (baseDraft[DRAFT_STATE].modified_ && (revokeScope(scope), die(4)), isDraftable(result) && (result = finalize(scope, result), scope.parent_ || maybeFreeze(scope, result)), scope.patches_ && getPlugin("Patches").generateReplacementPatches_(
    baseDraft[DRAFT_STATE].base_,
    result,
    scope.patches_,
    scope.inversePatches_
  )) : result = finalize(scope, baseDraft, []), revokeScope(scope), scope.patches_ && scope.patchListener_(scope.patches_, scope.inversePatches_), result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state)
    return each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    ), value;
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_)
    return maybeFreeze(rootScope, state.base_, !0), state.base_;
  if (!state.finalized_) {
    state.finalized_ = !0, state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result, isSet2 = !1;
    state.type_ === 3 && (resultEach = new Set(result), result.clear(), isSet2 = !0), each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    ), maybeFreeze(rootScope, result, !1), path && rootScope.patches_ && getPlugin("Patches").generatePatches_(
      state,
      path,
      rootScope.patches_,
      rootScope.inversePatches_
    );
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0, res = finalize(rootScope, childValue, path);
    if (set$2(targetObject, prop, res), isDraft(res))
      rootScope.canAutoFreeze_ = !1;
    else
      return;
  } else targetIsSet && targetObject.add(childValue);
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1)
      return;
    finalize(rootScope, childValue), (!parentState || !parentState.scope_.parent_) && typeof prop != "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop) && maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = !1) {
  !scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_ && freeze(value, deep);
}
function createProxyProxy(base, parent) {
  const isArray2 = Array.isArray(base), state = {
    type_: isArray2 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let target = state, traps = objectTraps;
  isArray2 && (target = [state], traps = arrayTraps);
  const { revoke, proxy } = Proxy.revocable(target, traps);
  return state.draft_ = proxy, state.revoke_ = revoke, proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop))
      return readPropFromProto(state, source, prop);
    const value = source[prop];
    return state.finalized_ || !isDraftable(value) ? value : value === peek(state.base_, prop) ? (prepareCopy(state), state.copy_[prop] = createProxy(value, state)) : value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc != null && desc.set)
      return desc.set.call(state.draft_, value), !0;
    if (!state.modified_) {
      const current2 = peek(latest(state), prop), currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value)
        return state.copy_[prop] = value, state.assigned_[prop] = !1, !0;
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return !0;
      prepareCopy(state), markChanged(state);
    }
    return state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]) || (state.copy_[prop] = value, state.assigned_[prop] = !0), !0;
  },
  deleteProperty(state, prop) {
    return peek(state.base_, prop) !== void 0 || prop in state.base_ ? (state.assigned_[prop] = !1, prepareCopy(state), markChanged(state)) : delete state.assigned_[prop], state.copy_ && delete state.copy_[prop], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state), desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    return desc && {
      writable: !0,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
}, arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    return arguments[0] = arguments[0][0], fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  return (state ? latest(state) : draft)[prop];
}
function readPropFromProto(state, source, prop) {
  var _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? "value" in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return;
  let proto = getPrototypeOf(source);
  for (; proto; ) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
}
function markChanged(state) {
  state.modified_ || (state.modified_ = !0, state.parent_ && markChanged(state.parent_));
}
function prepareCopy(state) {
  state.copy_ || (state.copy_ = shallowCopy(
    state.base_,
    state.scope_.immer_.useStrictShallowCopy_
  ));
}
var Immer2 = class {
  constructor(config2) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (base, recipe, patchListener) => {
      if (typeof base == "function" && typeof recipe != "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      typeof recipe != "function" && die(6), patchListener !== void 0 && typeof patchListener != "function" && die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this), proxy = createProxy(base, void 0);
        let hasError = !0;
        try {
          result = recipe(proxy), hasError = !1;
        } finally {
          hasError ? revokeScope(scope) : leaveScope(scope);
        }
        return usePatchesInScope(scope, patchListener), processResult(result, scope);
      } else if (!base || typeof base != "object") {
        if (result = recipe(base), result === void 0 && (result = base), result === NOTHING && (result = void 0), this.autoFreeze_ && freeze(result, !0), patchListener) {
          const p2 = [], ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip), patchListener(p2, ip);
        }
        return result;
      } else
        die(1, base);
    }, this.produceWithPatches = (base, recipe) => {
      if (typeof base == "function")
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      let patches, inversePatches;
      return [this.produce(base, recipe, (p2, ip) => {
        patches = p2, inversePatches = ip;
      }), patches, inversePatches];
    }, typeof (config2 == null ? void 0 : config2.autoFreeze) == "boolean" && this.setAutoFreeze(config2.autoFreeze), typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
  }
  createDraft(base) {
    isDraftable(base) || die(8), isDraft(base) && (base = current(base));
    const scope = enterScope(this), proxy = createProxy(base, void 0);
    return proxy[DRAFT_STATE].isManual_ = !0, leaveScope(scope), proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    (!state || !state.isManual_) && die(9);
    const { scope_: scope } = state;
    return usePatchesInScope(scope, patchListener), processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch = patches[i2];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    i2 > -1 && (patches = patches.slice(i2 + 1));
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    return isDraft(base) ? applyPatchesImpl(base, patches) : this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  return (parent ? parent.scope_ : getCurrentScope()).drafts_.push(draft), draft;
}
function current(value) {
  return isDraft(value) || die(10, value), currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy2;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = !0, copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else
    copy2 = shallowCopy(value, !0);
  return each(copy2, (key, childValue) => {
    set$2(copy2, key, currentImpl(childValue));
  }), state && (state.finalized_ = !1), copy2;
}
function enablePatches() {
  const REPLACE = "replace", REMOVE = "remove";
  function generatePatches_(state, basePath, patches, inversePatches) {
    switch (state.type_) {
      case 0:
      case 2:
        return generatePatchesFromAssigned(
          state,
          basePath,
          patches,
          inversePatches
        );
      case 1:
        return generateArrayPatches(state, basePath, patches, inversePatches);
      case 3:
        return generateSetPatches(
          state,
          basePath,
          patches,
          inversePatches
        );
    }
  }
  function generateArrayPatches(state, basePath, patches, inversePatches) {
    let { base_, assigned_ } = state, copy_ = state.copy_;
    copy_.length < base_.length && ([base_, copy_] = [copy_, base_], [patches, inversePatches] = [inversePatches, patches]);
    for (let i2 = 0; i2 < base_.length; i2++)
      if (assigned_[i2] && copy_[i2] !== base_[i2]) {
        const path = basePath.concat([i2]);
        patches.push({
          op: REPLACE,
          path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i2])
        }), inversePatches.push({
          op: REPLACE,
          path,
          value: clonePatchValueIfNeeded(base_[i2])
        });
      }
    for (let i2 = base_.length; i2 < copy_.length; i2++) {
      const path = basePath.concat([i2]);
      patches.push({
        op: "add",
        path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[i2])
      });
    }
    for (let i2 = copy_.length - 1; base_.length <= i2; --i2) {
      const path = basePath.concat([i2]);
      inversePatches.push({
        op: REMOVE,
        path
      });
    }
  }
  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    const { base_, copy_ } = state;
    each(state.assigned_, (key, assignedValue) => {
      const origValue = get(base_, key), value = get(copy_, key), op = assignedValue ? has(base_, key) ? REPLACE : "add" : REMOVE;
      if (origValue === value && op === REPLACE)
        return;
      const path = basePath.concat(key);
      patches.push(op === REMOVE ? { op, path } : { op, path, value }), inversePatches.push(
        op === "add" ? { op: REMOVE, path } : op === REMOVE ? { op: "add", path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
      );
    });
  }
  function generateSetPatches(state, basePath, patches, inversePatches) {
    let { base_, copy_ } = state, i2 = 0;
    base_.forEach((value) => {
      if (!copy_.has(value)) {
        const path = basePath.concat([i2]);
        patches.push({
          op: REMOVE,
          path,
          value
        }), inversePatches.unshift({
          op: "add",
          path,
          value
        });
      }
      i2++;
    }), i2 = 0, copy_.forEach((value) => {
      if (!base_.has(value)) {
        const path = basePath.concat([i2]);
        patches.push({
          op: "add",
          path,
          value
        }), inversePatches.unshift({
          op: REMOVE,
          path,
          value
        });
      }
      i2++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? void 0 : replacement
    }), inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    return patches.forEach((patch) => {
      const { path, op } = patch;
      let base = draft;
      for (let i2 = 0; i2 < path.length - 1; i2++) {
        const parentType = getArchtype(base);
        let p2 = path[i2];
        typeof p2 != "string" && typeof p2 != "number" && (p2 = "" + p2), (parentType === 0 || parentType === 1) && (p2 === "__proto__" || p2 === "constructor") && die(19), typeof base == "function" && p2 === "prototype" && die(19), base = get(base, p2), typeof base != "object" && die(18, path.join("/"));
      }
      const type = getArchtype(base), value = deepClonePatchValue(patch.value), key = path[path.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2:
              return base.set(key, value);
            case 3:
              die(16);
            default:
              return base[key] = value;
          }
        case "add":
          switch (type) {
            case 1:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2:
              return base.set(key, value);
            case 3:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1:
              return base.splice(key, 1);
            case 2:
              return base.delete(key);
            case 3:
              return base.delete(patch.value);
            default:
              return delete base[key];
          }
        default:
          die(17, op);
      }
    }), draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj))
      return obj;
    if (Array.isArray(obj))
      return obj.map(deepClonePatchValue);
    if (isMap(obj))
      return new Map(
        Array.from(obj.entries()).map(([k, v2]) => [k, deepClonePatchValue(v2)])
      );
    if (isSet(obj))
      return new Set(Array.from(obj).map(deepClonePatchValue));
    const cloned = Object.create(getPrototypeOf(obj));
    for (const key in obj)
      cloned[key] = deepClonePatchValue(obj[key]);
    return has(obj, DRAFTABLE) && (cloned[DRAFTABLE] = obj[DRAFTABLE]), cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    return isDraft(obj) ? deepClonePatchValue(obj) : obj;
  }
  loadPlugin("Patches", {
    applyPatches_,
    generatePatches_,
    generateReplacementPatches_
  });
}
var immer = new Immer2();
immer.produce;
immer.produceWithPatches.bind(
  immer
);
immer.setAutoFreeze.bind(immer);
immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
immer.createDraft.bind(immer);
immer.finishDraft.bind(immer);
enablePatches();
var ClientStateManager = class {
  constructor(fallbackState2) {
    __publicField2(this, "state"), __publicField2(this, "fallbackState"), this.fallbackState = freeze(fallbackState2, !0), this.state = this.fallbackState;
  }
  handleMessage(message, onStateChange) {
    if (isStateSyncMessage(message))
      this.state = freeze(message.data.state, !0), onStateChange == null || onStateChange();
    else if (isStatePatchMessage(message)) {
      const patches = message.data.patch, newState = applyPatches(this.state, patches);
      this.state = freeze(newState, !0), onStateChange == null || onStateChange();
    }
  }
  getState() {
    return this.state;
  }
  reset() {
    this.state = this.fallbackState;
  }
};
function createProcedureProxy(call, options, path = []) {
  return new Proxy(() => {
  }, {
    get(_target, prop) {
      if (prop === "toString" || prop === "valueOf")
        return () => `[Proxy: ${path.join(".")}]`;
      if (typeof prop == "symbol")
        return;
      const newPath = [...path, String(prop)];
      return createProcedureProxy(call, options, newPath);
    },
    apply(_target, _thisArg, args) {
      return call(path, args, options);
    }
  });
}
function extractProceduresFromTree(tree, prefix = []) {
  const procedures = /* @__PURE__ */ new Map();
  if (!tree)
    return procedures;
  for (const [key, value] of Object.entries(tree)) {
    const currentPath = [...prefix, key];
    if (typeof value == "function")
      procedures.set(currentPath.join("."), value);
    else if (typeof value == "object" && value !== null) {
      const nested = extractProceduresFromTree(
        value,
        currentPath
      );
      for (const [nestedKey, nestedValue] of nested)
        procedures.set(nestedKey, nestedValue);
    }
  }
  return procedures;
}
var KartonClientImpl = class {
  constructor(config2) {
    __publicField2(this, "ws", null), __publicField2(this, "connection", null), __publicField2(this, "rpcManager", null), __publicField2(this, "stateManager"), __publicField2(this, "clientProcedures"), __publicField2(this, "config"), __publicField2(this, "_serverProcedures"), __publicField2(this, "_isConnected", !1), __publicField2(this, "reconnectTimer", null), __publicField2(this, "reconnectInterval", 500), __publicField2(this, "onStateChange"), this.config = config2, this.clientProcedures = config2.procedures, this.onStateChange = config2.onStateChange, this.stateManager = new ClientStateManager(config2.fallbackState), this._serverProcedures = createProcedureProxy(
      async (procedurePath, parameters, options) => {
        if (!this.rpcManager || !this._isConnected)
          throw new KartonRPCException(
            "SERVER_UNAVAILABLE",
            procedurePath
          );
        return await this.rpcManager.call(procedurePath, parameters, options);
      }
    ), this.connect();
  }
  connect() {
    try {
      this.ws = new WebSocket(this.config.webSocketPath), this.connection = new WebSocketConnection(this.ws), this.rpcManager = new RPCManager((message) => {
        var _a;
        (_a = this.connection) != null && _a.isOpen() && this.connection.send(message);
      });
      const procedures = extractProceduresFromTree(
        this.clientProcedures
      );
      for (const [path, handler] of procedures)
        this.rpcManager.registerProcedure(path.split("."), handler);
      this.connection.onMessage(async (message) => {
        this.stateManager.handleMessage(message, this.onStateChange), this.rpcManager && await this.rpcManager.handleMessage(message);
      }), this.connection.onOpen(() => {
        var _a;
        this._isConnected = !0, (_a = this.onStateChange) == null || _a.call(this), this.clearReconnectTimer();
      }), this.connection.onClose(() => {
        var _a;
        this._isConnected = !1, (_a = this.onStateChange) == null || _a.call(this), this.scheduleReconnect();
      }), this.connection.onError((error2) => {
        console.error("WebSocket error:", error2);
      });
    } catch (error2) {
      console.error("Failed to connect:", error2), this.scheduleReconnect();
    }
  }
  scheduleReconnect() {
    this.clearReconnectTimer(), this.reconnectTimer = setTimeout(() => {
      this.cleanup(), this.connect();
    }, this.reconnectInterval);
  }
  clearReconnectTimer() {
    this.reconnectTimer && (clearTimeout(this.reconnectTimer), this.reconnectTimer = null);
  }
  cleanup() {
    this.rpcManager && (this.rpcManager.cleanup(), this.rpcManager = null), this.connection && (this.connection.close(), this.connection = null), this.ws && (this.ws = null);
  }
  get state() {
    return this.stateManager.getState();
  }
  get serverProcedures() {
    return this._serverProcedures;
  }
  get isConnected() {
    return this._isConnected;
  }
  close() {
    var _a;
    this.clearReconnectTimer(), this.cleanup(), (_a = this.onStateChange) == null || _a.call(this);
  }
};
function createKartonClient(config2) {
  return new KartonClientImpl(config2);
}
function createKartonContext() {
  return createContext(null);
}
var fullStateSelector = (state) => state, fullProcedureSelector = (procedures) => procedures;
function createKartonReactClient(config2) {
  const KartonContext = createKartonContext();
  return [
    ({
      children
    }) => {
      const clientRef = useRef(null), listenersRef = useRef(/* @__PURE__ */ new Set()), subscribeRef = useRef(
        null
      );
      clientRef.current || (clientRef.current = createKartonClient({
        ...config2,
        onStateChange: () => {
          listenersRef.current.forEach((listener) => listener());
        }
      }), subscribeRef.current = (listener) => (listenersRef.current.add(listener), () => {
        listenersRef.current.delete(listener);
      }));
      const client = clientRef.current, value = useMemo(
        () => ({
          client,
          subscribe: subscribeRef.current
        }),
        [client]
        // Only recreate if client changes (which should never happen)
      );
      return /* @__PURE__ */ React__default.createElement(KartonContext.Provider, { value }, children);
    },
    (selector = fullStateSelector) => {
      const context = useContext(KartonContext);
      if (!context)
        throw new Error("useKartonState must be used within KartonProvider");
      const { client, subscribe } = context;
      return useSyncExternalStore(
        subscribe,
        useCallback(() => selector(client.state), [selector, client.state]),
        useCallback(
          () => selector(config2.fallbackState),
          [selector, config2.fallbackState]
        )
      );
    },
    (selector = fullProcedureSelector) => {
      const context = useContext(KartonContext);
      if (!context)
        throw new Error("useKartonProcedure must be used within KartonProvider");
      const { client } = context;
      return useMemo(
        () => selector(client.serverProcedures),
        // Only re-compute if the selector function changes or client changes (which should never happen)
        [selector, client]
      );
    },
    () => {
      const context = useContext(KartonContext);
      if (!context)
        throw new Error("useKartonConnected must be used within KartonProvider");
      const { client, subscribe } = context;
      return useSyncExternalStore(
        subscribe,
        () => client.isConnected,
        () => client.isConnected
      );
    }
  ];
}
const [KartonProvider, useKartonState, useKartonProcedure, useKartonConnected] = createKartonReactClient({
  webSocketPath: `${window.location.protocol}//${window.location.host}/stagewise-toolbar-app/karton`,
  procedures: {
    noop: async () => {
    }
  },
  fallbackState: {
    noop: !1
  }
}), fallbackState = {
  state: AgentStateType.IDLE
}, agentStateContext = createContext(fallbackState);
function AgentStateProvider({ children }) {
  const agent = useAgents().connected, [state, setState] = useState(fallbackState);
  return useEffect(() => {
    if (agent) {
      const subscription = agent.agent.state.getState.subscribe(void 0, {
        onData: (value) => {
          setState(value);
        },
        onError: () => {
          setState(fallbackState);
        }
      });
      return () => {
        try {
          subscription.unsubscribe();
        } catch (error2) {
          console.debug(
            "[AgentStateProvider] Error unsubscribing from agent state:",
            error2
          );
        }
      };
    } else
      setState(fallbackState);
  }, [agent]), /* @__PURE__ */ jsx(agentStateContext.Provider, { value: state, children });
}
const useAgentState = () => useContext(agentStateContext), ChatContext = createContext({
  chatInput: "",
  setChatInput: () => {
  },
  domContextElements: [],
  addChatDomContext: () => {
  },
  removeChatDomContext: () => {
  },
  sendMessage: () => {
  },
  isPromptCreationActive: !1,
  startPromptCreation: () => {
  },
  stopPromptCreation: () => {
  },
  isContextSelectorActive: !1,
  startContextSelector: () => {
  },
  stopContextSelector: () => {
  },
  isSending: !1
}), ChatStateProvider = ({ children }) => {
  const [chatInput, setChatInput] = useState(""), [isPromptCreationMode, setIsPromptCreationMode] = useState(!1), [isContextSelectorMode, setIsContextSelectorMode] = useState(!1), [isSending, setIsSending] = useState(!1), [domContextElements, setDomContextElements] = useState([]), { minimized } = useAppState(), { plugins: plugins2 } = usePlugins(), { sendMessage: sendAgentMessage } = useAgentMessaging(), { isChatOpen } = usePanels(), agentState = useAgentState(), startPromptCreation = useCallback(() => {
    setIsPromptCreationMode(!0), plugins2.forEach((plugin) => {
      var _a;
      (_a = plugin.onPromptingStart) == null || _a.call(plugin);
    });
  }, [plugins2]), stopPromptCreation = useCallback(() => {
    setIsPromptCreationMode(!1), setIsContextSelectorMode(!1), setDomContextElements([]), plugins2.forEach((plugin) => {
      var _a;
      (_a = plugin.onPromptingAbort) == null || _a.call(plugin);
    });
  }, [plugins2]), startContextSelector = useCallback(() => {
    setIsContextSelectorMode(!0);
  }, []), stopContextSelector = useCallback(() => {
    setIsContextSelectorMode(!1);
  }, []);
  useEffect(() => {
    isChatOpen || stopPromptCreation();
  }, [isChatOpen, stopPromptCreation]), useEffect(() => {
    minimized && stopPromptCreation();
  }, [minimized]), useEffect(() => {
    const allowedStates = [
      AgentStateType.IDLE,
      AgentStateType.WAITING_FOR_USER_RESPONSE
    ];
    isPromptCreationMode && agentState.state && !allowedStates.includes(agentState.state) && stopPromptCreation();
  }, [agentState.state, isPromptCreationMode, stopPromptCreation]);
  const addChatDomContext = useCallback(
    (element) => {
      const pluginsWithContextGetters = plugins2.filter(
        (plugin) => plugin.onContextElementSelect
      );
      setDomContextElements((prev) => [
        ...prev,
        {
          element,
          pluginContext: pluginsWithContextGetters.map((plugin) => {
            var _a;
            return {
              pluginName: plugin.pluginName,
              context: (_a = plugin.onContextElementSelect) == null ? void 0 : _a.call(plugin, element)
            };
          })
        }
      ]);
    },
    [plugins2]
  ), removeChatDomContext = useCallback((element) => {
    setDomContextElements(
      (prev) => prev.filter((item) => item.element !== element)
    );
  }, []), sendMessage = useCallback(async () => {
    if (chatInput.trim()) {
      setIsSending(!0);
      try {
        const baseUserMessage = {
          id: generateId(),
          createdAt: /* @__PURE__ */ new Date(),
          contentItems: [
            {
              type: "text",
              text: chatInput
            }
          ],
          metadata: collectUserMessageMetadata(
            domContextElements.map(
              (item) => getSelectedElementInfo(item.element)
            )
          ),
          pluginContent: {},
          sentByPlugin: !1
        }, pluginProcessingPromises = plugins2.map(async (plugin) => {
          var _a;
          try {
            const handlerResult = await ((_a = plugin.onPromptSend) == null ? void 0 : _a.call(plugin, baseUserMessage));
            if (!handlerResult || !handlerResult.contextSnippets || handlerResult.contextSnippets.length === 0)
              return null;
            const snippetPromises = handlerResult.contextSnippets.map(
              async (snippet) => {
                try {
                  const resolvedContent = typeof snippet.content == "string" ? snippet.content : await snippet.content();
                  return {
                    promptContextName: snippet.promptContextName,
                    content: resolvedContent
                  };
                } catch (snippetError) {
                  return console.error(
                    `Failed to resolve snippet for plugin ${plugin.pluginName}:`,
                    snippetError
                  ), null;
                }
              }
            ), validSnippets = (await Promise.all(snippetPromises)).filter(
              (snippet) => snippet !== null
            );
            return validSnippets.length > 0 ? {
              pluginName: plugin.pluginName,
              contextSnippets: validSnippets
            } : null;
          } catch (pluginError) {
            return console.error(
              `Failed to process plugin ${plugin.pluginName}:`,
              pluginError
            ), null;
          }
        }), allPluginContexts = await Promise.all(pluginProcessingPromises), pluginContent = {};
        allPluginContexts.forEach((context) => {
          context && (pluginContent[context.pluginName] = {}, context.contextSnippets.forEach((snippet) => {
            pluginContent[context.pluginName][snippet.promptContextName] = {
              type: "text",
              text: `${snippet.content}`
            };
          }));
        });
        const userMessageInput = {
          ...baseUserMessage,
          pluginContent
        };
        sendAgentMessage(userMessageInput), setChatInput(""), setDomContextElements([]), setIsPromptCreationMode(!1);
      } finally {
        setIsSending(!1);
      }
    }
  }, [chatInput, domContextElements, plugins2, sendAgentMessage]), value = {
    chatInput,
    setChatInput,
    domContextElements,
    addChatDomContext,
    removeChatDomContext,
    sendMessage,
    isPromptCreationActive: isPromptCreationMode,
    startPromptCreation,
    stopPromptCreation,
    isContextSelectorActive: isContextSelectorMode,
    startContextSelector,
    stopContextSelector,
    isSending
  };
  return /* @__PURE__ */ jsx(ChatContext.Provider, { value, children });
};
function useChatState() {
  const context = useContext(ChatContext);
  if (!context)
    throw new Error("useChatState must be used within a ChatStateProvider");
  return context;
}
const agentAvailabilityContext = createContext({
  isAvailable: !1,
  error: AgentAvailabilityError.NO_CONNECTION
});
function AgentAvailabilityProvider({
  children
}) {
  const { connected: agent } = useAgents(), [availability, setAvailability] = useState({
    isAvailable: !1,
    error: AgentAvailabilityError.NO_CONNECTION
  });
  return useEffect(() => {
    if (agent) {
      const subscription = agent.agent.availability.getAvailability.subscribe(
        void 0,
        {
          onData: (value) => {
            setAvailability(value);
          },
          onError: () => {
            setAvailability({
              isAvailable: !1,
              error: AgentAvailabilityError.NO_CONNECTION
            });
          }
        }
      );
      return () => {
        try {
          subscription.unsubscribe();
        } catch (error2) {
          console.debug(
            "[AgentAvailabilityProvider] Error unsubscribing from availability:",
            error2
          );
        }
      };
    } else
      setAvailability({
        isAvailable: !1,
        error: AgentAvailabilityError.NO_CONNECTION
      });
  }, [agent]), /* @__PURE__ */ jsx(agentAvailabilityContext.Provider, { value: availability, children });
}
function ContextProviders({
  children,
  config: config2
}) {
  return /* @__PURE__ */ jsx(ConfigProvider, { config: config2, children: /* @__PURE__ */ jsx(AgentProvider, { children: /* @__PURE__ */ jsx(AgentAvailabilityProvider, { children: /* @__PURE__ */ jsx(AgentStateProvider, { children: /* @__PURE__ */ jsx(AgentMessagingProvider, { children: /* @__PURE__ */ jsx(PanelsProvider, { children: /* @__PURE__ */ jsx(PluginProvider, { children: /* @__PURE__ */ jsx(KartonProvider, { children: /* @__PURE__ */ jsx(ChatStateProvider, { children }) }) }) }) }) }) }) }) });
}
function useEventListener(eventName, handler, options, element = window) {
  useEffect(() => {
    if (!(typeof window > "u") && element)
      return element.addEventListener(eventName, handler, options), () => element.removeEventListener(eventName, handler, options);
  }, [eventName, handler, element, options]);
}
function HotkeyListener() {
  const {
    startPromptCreation,
    stopPromptCreation,
    isPromptCreationActive,
    startContextSelector,
    stopContextSelector,
    isContextSelectorActive
  } = useChatState(), { isChatOpen, closeChat, openChat } = usePanels(), hotKeyHandlerMap = useMemo(
    () => ({
      // Functions that return true will prevent further propagation of the event.
      [HotkeyActions.CTRL_ALT_C]: () => isPromptCreationActive ? !1 : (startPromptCreation(), !0),
      [HotkeyActions.CTRL_ALT_PERIOD]: () => isPromptCreationActive ? (isContextSelectorActive ? stopContextSelector() : startContextSelector(), !0) : isChatOpen ? !1 : (openChat(), startPromptCreation(), startContextSelector(), !0),
      [HotkeyActions.ESC]: () => isContextSelectorActive ? (stopContextSelector(), !0) : isPromptCreationActive ? (stopPromptCreation(), !0) : isChatOpen ? (closeChat(), !0) : !1
    }),
    [
      startPromptCreation,
      stopPromptCreation,
      isPromptCreationActive,
      startContextSelector,
      stopContextSelector,
      isContextSelectorActive,
      isChatOpen,
      closeChat,
      openChat
    ]
  ), hotKeyListener = useCallback(
    (ev) => {
      for (const [action, definition] of Object.entries(
        hotkeyActionDefinitions
      ))
        if (definition.isEventMatching(ev)) {
          hotKeyHandlerMap[action]() && (ev.preventDefault(), ev.stopPropagation());
          break;
        }
    },
    [hotKeyHandlerMap]
  );
  useEventListener("keydown", hotKeyListener, {
    capture: !0
  });
  const iframe = document.getElementById(
    "user-app-iframe"
  );
  return useEventListener(
    "keydown",
    hotKeyListener,
    {
      capture: !0
    },
    iframe == null ? void 0 : iframe.contentWindow
  ), null;
}
function useWindowSize() {
  const iframeWindow = getIFrameWindow(), [size2, setSize] = useState({
    width: (iframeWindow == null ? void 0 : iframeWindow.innerWidth) || window.innerWidth,
    height: (iframeWindow == null ? void 0 : iframeWindow.innerHeight) || window.innerHeight
  }), handleResize = useCallback(() => {
    const iframe = getIFrameWindow();
    iframe && setSize({
      width: iframe.innerWidth,
      height: iframe.innerHeight
    });
  }, []);
  return useEffect(() => {
    const iframe = getIFrameWindow();
    if (iframe)
      return iframe.addEventListener("resize", handleResize), handleResize(), () => {
        iframe.removeEventListener("resize", handleResize);
      };
  }, [handleResize]), size2;
}
function useCyclicUpdate(func, frameRate) {
  const animationFrameHandle = useRef(void 0), timeBetweenFrames = useMemo(
    () => 1e3 / frameRate,
    [frameRate]
  ), lastCallFrameTime = useRef(0), update2 = useCallback(
    (frameTime) => {
      frameTime - lastCallFrameTime.current >= timeBetweenFrames && (func(), lastCallFrameTime.current = frameTime), animationFrameHandle.current = requestAnimationFrame(update2);
    },
    [func, timeBetweenFrames]
  );
  useEffect(() => (animationFrameHandle.current = requestAnimationFrame(update2), () => {
    animationFrameHandle.current && (cancelAnimationFrame(animationFrameHandle.current), animationFrameHandle.current = void 0);
  }), [frameRate, update2]);
}
function HoveredItem({ refElement, ...props }) {
  const boxRef = useRef(null), windowSize = useWindowSize(), { plugins: plugins2 } = usePlugins(), hoveredElementPluginContext = useMemo(() => refElement ? plugins2.filter(
    (plugin) => plugin.onContextElementSelect
  ).map((plugin) => {
    var _a;
    return {
      pluginName: plugin.pluginName,
      context: (_a = plugin.onContextElementSelect) == null ? void 0 : _a.call(plugin, refElement)
    };
  }) : [], [refElement]), updateBoxPosition = useCallback(() => {
    if (boxRef.current && refElement) {
      const referenceRect = refElement.getBoundingClientRect();
      boxRef.current.style.top = `${referenceRect.top - 2}px`, boxRef.current.style.left = `${referenceRect.left - 2}px`, boxRef.current.style.width = `${referenceRect.width + 4}px`, boxRef.current.style.height = `${referenceRect.height + 4}px`, boxRef.current.style.display = void 0;
    } else
      boxRef.current.style.height = "0px", boxRef.current.style.width = "0px", boxRef.current.style.top = `${windowSize.height / 2}px`, boxRef.current.style.left = `${windowSize.width / 2}px`, boxRef.current.style.display = "none";
  }, [refElement, windowSize.height, windowSize.width]);
  return useCyclicUpdate(updateBoxPosition, 30), /* @__PURE__ */ jsx(
    "div",
    {
      ...props,
      className: cn(
        "fixed z-10 flex items-center justify-center rounded-sm border-2 border-blue-600/70 border-dotted bg-blue-600/5 text-white transition-all duration-100"
      ),
      ref: boxRef,
      children: /* @__PURE__ */ jsxs("div", { className: "absolute top-0.5 left-0.5 flex w-full flex-row items-start justify-start gap-1", children: [
        /* @__PURE__ */ jsx("div", { className: "flex flex-row items-center justify-center gap-0.5 overflow-hidden rounded-md bg-zinc-700/80 px-1 py-0 font-medium text-white text-xs", children: /* @__PURE__ */ jsx("span", { className: "truncate", children: refElement.tagName.toLowerCase() }) }),
        hoveredElementPluginContext.filter((plugin) => plugin.context.annotation).map((plugin) => {
          var _a;
          return /* @__PURE__ */ jsxs(
            "div",
            {
              className: "flex flex-row items-center justify-center gap-0.5 overflow-hidden rounded-md bg-zinc-700/80 px-1 py-0 font-medium text-white text-xs",
              children: [
                /* @__PURE__ */ jsx("span", { className: "size-3 shrink-0 stroke-white text-white *:size-full", children: (_a = plugins2.find((p2) => p2.pluginName === plugin.pluginName)) == null ? void 0 : _a.iconSvg }),
                /* @__PURE__ */ jsx("span", { className: "truncate", children: plugin.context.annotation })
              ]
            },
            plugin.pluginName
          );
        })
      ] })
    }
  );
}
const ContextChipHoverContext = createContext(void 0);
function ContextChipHoverProvider({
  children
}) {
  const [hoveredElement, setHoveredElement] = useState(
    null
  ), { domContextElements } = useChatState();
  return useEffect(() => {
    hoveredElement && (domContextElements.some(
      (contextEl) => contextEl.element === hoveredElement
    ) || setHoveredElement(null));
  }, [hoveredElement, domContextElements]), /* @__PURE__ */ jsx(
    ContextChipHoverContext.Provider,
    {
      value: { hoveredElement, setHoveredElement },
      children
    }
  );
}
function useContextChipHover() {
  const context = useContext(ContextChipHoverContext);
  if (context === void 0)
    throw new Error(
      "useContextChipHover must be used within a ContextChipHoverProvider"
    );
  return context;
}
function SelectedItem({
  refElement,
  isChipHovered,
  ...props
}) {
  const boxRef = useRef(null), windowSize = useWindowSize(), updateBoxPosition = useCallback(() => {
    if (boxRef.current)
      if (refElement) {
        const referenceRect = refElement.getBoundingClientRect();
        boxRef.current.style.top = `${referenceRect.top - 2}px`, boxRef.current.style.left = `${referenceRect.left - 2}px`, boxRef.current.style.width = `${referenceRect.width + 4}px`, boxRef.current.style.height = `${referenceRect.height + 4}px`, boxRef.current.style.display = void 0;
      } else
        boxRef.current.style.height = "0px", boxRef.current.style.width = "0px", boxRef.current.style.top = `${windowSize.height / 2}px`, boxRef.current.style.left = `${windowSize.width / 2}px`, boxRef.current.style.opacity = "none";
  }, [refElement, windowSize.height, windowSize.width]);
  return useCyclicUpdate(updateBoxPosition, 30), /* @__PURE__ */ jsx(
    "button",
    {
      ...props,
      className: cn(
        "pointer-events-auto fixed flex cursor-not-allowed items-center justify-center rounded-sm border-2 border-zinc-600/70 border-dotted transition-all duration-100 hover:border-rose-600/70 hover:bg-rose-600/5",
        isChipHovered && "border-blue-600/70 bg-blue-600/5"
      ),
      onClick: props.onRemoveClick,
      ref: boxRef
    }
  );
}
function DOMContextSelector() {
  const {
    domContextElements,
    addChatDomContext,
    isContextSelectorActive,
    removeChatDomContext
  } = useChatState(), shouldShow = isContextSelectorActive, [hoveredElement, setHoveredElement] = useState(
    null
  ), { hoveredElement: chipHoveredElement } = useContextChipHover(), handleElementSelected = useCallback(
    (el) => {
      domContextElements.find(
        (contextEl) => contextEl.element === el
      ) || addChatDomContext(el);
    },
    [addChatDomContext, domContextElements]
  ), hoveredSelectedElement = hoveredElement ? domContextElements.find((el) => el.element === hoveredElement) : null, selectedItems = useMemo(() => domContextElements.map((el) => el.element), [domContextElements]), lastHoveredElement = useRef(null), mouseState = useRef(null), nextUpdateTimeout = useRef(null), [hoversAddable, setHoversAddable] = useState(!1), updateHoveredElement = useCallback(() => {
    if (!mouseState.current) return;
    const refElement = getElementAtPoint(
      mouseState.current.lastX,
      mouseState.current.lastY
    );
    if (selectedItems.includes(refElement)) {
      setHoversAddable(!1), lastHoveredElement.current = null, setHoveredElement(null);
      return;
    }
    lastHoveredElement.current !== refElement && (lastHoveredElement.current = refElement, setHoveredElement(refElement), setHoversAddable(!0));
  }, [selectedItems]);
  useEffect(() => {
    updateHoveredElement();
  }, [updateHoveredElement]);
  const handleMouseMove = useCallback(
    (event) => {
      var _a, _b, _c, _d, _e, _f;
      const currentTimestamp = performance.now(), deltaX = event.clientX - (((_a = mouseState.current) == null ? void 0 : _a.lastX) ?? event.clientX), deltaY = event.clientY - (((_b = mouseState.current) == null ? void 0 : _b.lastY) ?? event.clientY), deltaTime = currentTimestamp - (((_c = mouseState.current) == null ? void 0 : _c.lastTimestamp) ?? currentTimestamp), distance = Math.hypot(deltaX, deltaY);
      mouseState.current = {
        lastX: deltaTime > 0 ? event.clientX : (_d = mouseState.current) == null ? void 0 : _d.lastX,
        lastY: deltaTime > 0 ? event.clientY : (_e = mouseState.current) == null ? void 0 : _e.lastY,
        velocity: deltaTime > 0 ? distance / deltaTime * 1e3 : 0,
        lastTimestamp: currentTimestamp
      }, ((_f = mouseState.current) == null ? void 0 : _f.velocity) > 30 ? (nextUpdateTimeout.current && clearTimeout(nextUpdateTimeout.current), nextUpdateTimeout.current = setTimeout(updateHoveredElement, 1e3 / 28)) : nextUpdateTimeout.current || (nextUpdateTimeout.current = setTimeout(updateHoveredElement, 1e3 / 28));
    },
    [updateHoveredElement]
  ), handleMouseLeave = useCallback(() => {
    clearTimeout(nextUpdateTimeout.current), lastHoveredElement.current = null, setHoveredElement(null);
  }, []), handleMouseClick = useCallback(
    (event) => {
      event.preventDefault(), event.stopPropagation(), lastHoveredElement.current && (selectedItems.includes(lastHoveredElement.current) || handleElementSelected(lastHoveredElement.current));
    },
    [handleElementSelected, selectedItems]
  );
  return shouldShow ? /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "pointer-events-auto fixed inset-0 h-screen w-screen",
        hoversAddable ? "cursor-copy" : "cursor-default"
      ),
      id: "element-selector",
      onMouseMove: handleMouseMove,
      onMouseLeave: handleMouseLeave,
      onClick: handleMouseClick,
      role: "button",
      tabIndex: 0,
      children: [
        hoveredElement && !hoveredSelectedElement && /* @__PURE__ */ jsx(HoveredItem, { refElement: hoveredElement }),
        domContextElements.map((el) => /* @__PURE__ */ jsx(
          SelectedItem,
          {
            refElement: el.element,
            isChipHovered: chipHoveredElement === el.element,
            onRemoveClick: () => removeChatDomContext(el.element)
          },
          getXPathForElement(el.element, !0)
        ))
      ]
    }
  ) : null;
}
const DraggableContext = createContext(
  null
), DraggableProvider = ({
  containerRef,
  children,
  snapAreas,
  onDragStart,
  onDragEnd
}) => {
  const [borderLocation, setBorderLocation] = useState({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  });
  useEffect(() => {
    if (!containerRef.current) return;
    const updateBorderLocation = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setBorderLocation({
          top: rect.top,
          left: rect.left,
          right: rect.right,
          bottom: rect.bottom
        });
      }
    };
    updateBorderLocation();
    const resizeObserver = new ResizeObserver(updateBorderLocation);
    return resizeObserver.observe(containerRef.current), window.addEventListener("resize", updateBorderLocation), () => {
      containerRef.current && resizeObserver.unobserve(containerRef.current), resizeObserver.disconnect(), window.removeEventListener("resize", updateBorderLocation);
    };
  }, [containerRef]);
  const dragStartListeners = useRef(/* @__PURE__ */ new Set()), dragEndListeners = useRef(/* @__PURE__ */ new Set()), registerDragStart = useCallback((cb) => (dragStartListeners.current.add(cb), () => dragStartListeners.current.delete(cb)), []), registerDragEnd = useCallback((cb) => (dragEndListeners.current.add(cb), () => dragEndListeners.current.delete(cb)), []), emitDragStart = useCallback(() => {
    onDragStart && onDragStart(), dragStartListeners.current.forEach((cb) => cb());
  }, [onDragStart]), emitDragEnd = useCallback(() => {
    onDragEnd && onDragEnd(), dragEndListeners.current.forEach((cb) => cb());
  }, [onDragEnd]), contextValue = {
    borderLocation,
    snapAreas,
    registerDragStart,
    registerDragEnd,
    emitDragStart,
    emitDragEnd
  };
  return /* @__PURE__ */ jsx(DraggableContext.Provider, { value: contextValue, children: contextValue.borderLocation.right - contextValue.borderLocation.left > 0 && contextValue.borderLocation.bottom - contextValue.borderLocation.top > 0 && children });
};
function useDraggable(config2) {
  const providerData = useContext(DraggableContext), latestProviderDataRef = useRef(providerData);
  useEffect(() => {
    latestProviderDataRef.current = providerData;
  }, [providerData]);
  const movingElementRef = useRef(null), dragInitiatorRef = useRef(null), [movingElementNode, setMovingElementNode] = useState(null), [dragInitiatorNode, setDragInitiatorNode] = useState(null), mouseToDraggableCenterOffsetRef = useRef(null), mouseDownPosRef = useRef(null), currentMousePosRef = useRef(null), isDraggingRef = useRef(!1), [isDragging, setIsDragging] = useState(!1), persistedRelativeCenterRef = useRef(config2.initialRelativeCenter), [currentSnapArea, setCurrentSnapArea] = useState(null), {
    startThreshold = 2,
    areaSnapThreshold = 60,
    // px, default threshold for snapping
    onDragStart,
    onDragEnd,
    initialSnapArea,
    springStiffness = 0.1,
    // Default spring stiffness for dragging
    springStiffnessSnap = 0.02,
    // Default spring stiffness for snapping (higher for faster snap)
    springDampness = 0.55
    // Default spring dampness
    // initialRelativeCenter is used to initialize persistedRelativeCenterRef
  } = config2, animatedPositionRef = useRef(null), velocityRef = useRef({ x: 0, y: 0 }), hasAnimatedOnceRef = useRef(!1), animationInProgressRef = useRef(!1), animationFrameRef = useRef(null);
  useEffect(() => {
    if (initialSnapArea && providerData && providerData.borderLocation && providerData.snapAreas && providerData.snapAreas[initialSnapArea] && !isDraggingRef.current && !animationInProgressRef.current) {
      const { top, left, right, bottom } = providerData.borderLocation, width = right - left, height = bottom - top, center = {
        topLeft: { x: left, y: top },
        topRight: { x: right, y: top },
        bottomLeft: { x: left, y: bottom },
        bottomRight: { x: right, y: bottom }
      }[initialSnapArea];
      if (center && width > 0 && height > 0) {
        const relX = (center.x - left) / width, relY = (center.y - top) / height;
        persistedRelativeCenterRef.current = { x: relX, y: relY };
      } else center && console.warn(
        "useDraggable: Container for initialSnapArea has zero width or height. Cannot calculate relative center from snap area. Falling back to initialRelativeCenter or undefined."
      );
    }
  }, [initialSnapArea, providerData]);
  function getSnapAreaCenters(borderLocation) {
    const { top, left, right, bottom } = borderLocation, centerX = (left + right) / 2;
    return {
      topLeft: { x: left, y: top },
      topCenter: { x: centerX, y: top },
      topRight: { x: right, y: top },
      bottomLeft: { x: left, y: bottom },
      bottomCenter: { x: centerX, y: bottom },
      bottomRight: { x: right, y: bottom }
    };
  }
  const updateDraggablePosition = useCallback(() => {
    var _a, _b;
    const draggableEl = movingElementRef.current;
    if (!draggableEl) return;
    const draggableWidth = draggableEl.offsetWidth, draggableHeight = draggableEl.offsetHeight, offsetParent = draggableEl.offsetParent;
    let parentViewportLeft = 0, parentViewportTop = 0, parentWidth = window.innerWidth, parentHeight = window.innerHeight;
    if (offsetParent) {
      const opRect = offsetParent.getBoundingClientRect();
      parentViewportLeft = opRect.left, parentViewportTop = opRect.top, parentWidth = offsetParent.offsetWidth || window.innerWidth, parentHeight = offsetParent.offsetHeight || window.innerHeight;
    }
    let targetViewportCenterX = null, targetViewportCenterY = null;
    const currentDesiredRelativeCenter = persistedRelativeCenterRef.current;
    let snapArea = null, snapTarget = null;
    const provider = latestProviderDataRef.current;
    let isTopHalf = !0, isLeftHalf = !0;
    if (isDraggingRef.current && mouseToDraggableCenterOffsetRef.current && currentMousePosRef.current && provider && provider.borderLocation && provider.snapAreas) {
      const dragCenter = {
        x: currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x,
        y: currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y
      }, areaCenters = getSnapAreaCenters(provider.borderLocation);
      let minDist = Number.POSITIVE_INFINITY, closestArea = null, closestCenter = null;
      for (const area in provider.snapAreas)
        if (provider.snapAreas[area]) {
          const center = areaCenters[area];
          if (!center) continue;
          const dist = Math.hypot(
            center.x - dragCenter.x,
            center.y - dragCenter.y
          );
          dist < minDist && (minDist = dist, closestArea = area, closestCenter = center);
        }
      closestArea && closestCenter && minDist <= areaSnapThreshold && (snapArea = closestArea, snapTarget = closestCenter), isLeftHalf = (dragCenter.x - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (dragCenter.y - parentViewportTop) / parentHeight <= 0.5;
    }
    if (isDraggingRef.current && snapTarget)
      targetViewportCenterX = snapTarget.x, targetViewportCenterY = snapTarget.y, setCurrentSnapArea(snapArea), isLeftHalf = (snapTarget.x - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (snapTarget.y - parentViewportTop) / parentHeight <= 0.5;
    else if (isDraggingRef.current && mouseToDraggableCenterOffsetRef.current && currentMousePosRef.current)
      targetViewportCenterX = currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x, targetViewportCenterY = currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y, setCurrentSnapArea(null), isLeftHalf = (targetViewportCenterX - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (targetViewportCenterY - parentViewportTop) / parentHeight <= 0.5;
    else {
      if (currentDesiredRelativeCenter && parentWidth > 0 && parentHeight > 0) {
        if (isTopHalf = currentDesiredRelativeCenter.y <= 0.5, isLeftHalf = currentDesiredRelativeCenter.x <= 0.5, isLeftHalf) {
          const targetCenterXInParent = parentWidth * currentDesiredRelativeCenter.x;
          targetViewportCenterX = parentViewportLeft + targetCenterXInParent;
        } else {
          const targetCenterXInParent = parentWidth * (1 - currentDesiredRelativeCenter.x);
          targetViewportCenterX = parentViewportLeft + parentWidth - targetCenterXInParent;
        }
        if (isTopHalf) {
          const targetCenterYInParent = parentHeight * currentDesiredRelativeCenter.y;
          targetViewportCenterY = parentViewportTop + targetCenterYInParent;
        } else {
          const targetCenterYInParent = parentHeight * (1 - currentDesiredRelativeCenter.y);
          targetViewportCenterY = parentViewportTop + parentHeight - targetCenterYInParent;
        }
      } else {
        !((_a = movingElementRef.current) != null && _a.style.left) && !((_b = movingElementRef.current) != null && _b.style.top) && console.warn(
          "useDraggable: Cannot determine position. Parent has no dimensions or initialRelativeCenter was not effectively set."
        );
        return;
      }
      setCurrentSnapArea(null);
    }
    if (targetViewportCenterX === null || targetViewportCenterY === null)
      return;
    const { borderLocation } = latestProviderDataRef.current || {
      borderLocation: void 0
    };
    if (borderLocation && draggableWidth > 0 && draggableHeight > 0) {
      const providerRectWidth = borderLocation.right - borderLocation.left, providerRectHeight = borderLocation.bottom - borderLocation.top;
      let clampedCenterX = targetViewportCenterX, clampedCenterY = targetViewportCenterY;
      if (draggableWidth >= providerRectWidth)
        clampedCenterX = borderLocation.left + providerRectWidth / 2;
      else {
        const minX = borderLocation.left + draggableWidth / 2, maxX = borderLocation.right - draggableWidth / 2;
        clampedCenterX = Math.max(minX, Math.min(clampedCenterX, maxX));
      }
      if (draggableHeight >= providerRectHeight)
        clampedCenterY = borderLocation.top + providerRectHeight / 2;
      else {
        const minY = borderLocation.top + draggableHeight / 2, maxY = borderLocation.bottom - draggableHeight / 2;
        clampedCenterY = Math.max(minY, Math.min(clampedCenterY, maxY));
      }
      targetViewportCenterX = clampedCenterX, targetViewportCenterY = clampedCenterY;
    }
    if (!animatedPositionRef.current) {
      animatedPositionRef.current = {
        x: targetViewportCenterX,
        y: targetViewportCenterY
      }, velocityRef.current = { x: 0, y: 0 };
      const targetElementStyleX2 = targetViewportCenterX - draggableWidth / 2, targetElementStyleY2 = targetViewportCenterY - draggableHeight / 2, elStyle2 = draggableEl.style;
      if (elStyle2.right = "", elStyle2.bottom = "", elStyle2.left = "", elStyle2.top = "", isLeftHalf) {
        const styleLeftPx = targetElementStyleX2 - parentViewportLeft;
        elStyle2.left = parentWidth > 0 ? `${(styleLeftPx / parentWidth * 100).toFixed(2)}%` : "0px", elStyle2.right = "";
      } else {
        const styleRightPx = parentViewportLeft + parentWidth - (targetElementStyleX2 + draggableWidth);
        elStyle2.right = parentWidth > 0 ? `${(styleRightPx / parentWidth * 100).toFixed(2)}%` : "0px", elStyle2.left = "";
      }
      if (isTopHalf) {
        const styleTopPx = targetElementStyleY2 - parentViewportTop;
        elStyle2.top = parentHeight > 0 ? `${(styleTopPx / parentHeight * 100).toFixed(2)}%` : "0px", elStyle2.bottom = "";
      } else {
        const styleBottomPx = parentViewportTop + parentHeight - (targetElementStyleY2 + draggableHeight);
        elStyle2.bottom = parentHeight > 0 ? `${(styleBottomPx / parentHeight * 100).toFixed(2)}%` : "0px", elStyle2.top = "";
      }
      hasAnimatedOnceRef.current = !0;
      return;
    }
    if (!hasAnimatedOnceRef.current) {
      hasAnimatedOnceRef.current = !0;
      return;
    }
    const pos = animatedPositionRef.current, vel = velocityRef.current, dx = targetViewportCenterX - pos.x, dy = targetViewportCenterY - pos.y, currentStiffness = isDraggingRef.current ? springStiffness : springStiffnessSnap, ax = currentStiffness * dx - springDampness * vel.x, ay = currentStiffness * dy - springDampness * vel.y;
    vel.x += ax, vel.y += ay, pos.x += vel.x, pos.y += vel.y;
    const threshold = 0.5;
    Math.abs(dx) < threshold && Math.abs(dy) < threshold && Math.abs(vel.x) < threshold && Math.abs(vel.y) < threshold && (pos.x = targetViewportCenterX, pos.y = targetViewportCenterY, vel.x = 0, vel.y = 0), animatedPositionRef.current = { ...pos }, velocityRef.current = { ...vel };
    const targetElementStyleX = pos.x - draggableWidth / 2, targetElementStyleY = pos.y - draggableHeight / 2, elStyle = draggableEl.style;
    if (elStyle.right = "", elStyle.bottom = "", elStyle.left = "", elStyle.top = "", isLeftHalf) {
      const styleLeftPx = targetElementStyleX - parentViewportLeft;
      elStyle.left = parentWidth > 0 ? `${(styleLeftPx / parentWidth * 100).toFixed(2)}%` : "0px", elStyle.right = "";
    } else {
      const styleRightPx = parentViewportLeft + parentWidth - (targetElementStyleX + draggableWidth);
      elStyle.right = parentWidth > 0 ? `${(styleRightPx / parentWidth * 100).toFixed(2)}%` : "0px", elStyle.left = "";
    }
    if (isTopHalf) {
      const styleTopPx = targetElementStyleY - parentViewportTop;
      elStyle.top = parentHeight > 0 ? `${(styleTopPx / parentHeight * 100).toFixed(2)}%` : "0px", elStyle.bottom = "";
    } else {
      const styleBottomPx = parentViewportTop + parentHeight - (targetElementStyleY + draggableHeight);
      elStyle.bottom = parentHeight > 0 ? `${(styleBottomPx / parentHeight * 100).toFixed(2)}%` : "0px", elStyle.top = "";
    }
    Math.abs(pos.x - targetViewportCenterX) > threshold || Math.abs(pos.y - targetViewportCenterY) > threshold || Math.abs(vel.x) > threshold || Math.abs(vel.y) > threshold || isDraggingRef.current ? (animationInProgressRef.current = !0, animationFrameRef.current = requestAnimationFrame(
      updateDraggablePosition
    )) : (animationInProgressRef.current = !1, animationFrameRef.current = null);
  }, [areaSnapThreshold, springStiffness, springStiffnessSnap, springDampness]), [wasDragged, setWasDragged] = useState(!1), mouseUpHandler = useCallback(
    (_e) => {
      var _a;
      let finalSnapArea = null;
      if (isDraggingRef.current) {
        setWasDragged(!0), setTimeout(() => setWasDragged(!1), 20);
        const draggableEl = movingElementRef.current, provider = latestProviderDataRef.current;
        if (draggableEl && provider && provider.borderLocation) {
          const draggableWidth = draggableEl.offsetWidth, draggableHeight = draggableEl.offsetHeight, offsetParent = draggableEl.offsetParent;
          let parentViewportLeft = 0, parentViewportTop = 0, parentWidth = window.innerWidth, parentHeight = window.innerHeight;
          if (offsetParent) {
            const opRect = offsetParent.getBoundingClientRect();
            parentViewportLeft = opRect.left, parentViewportTop = opRect.top, parentWidth = offsetParent.offsetWidth || window.innerWidth, parentHeight = offsetParent.offsetHeight || window.innerHeight;
          }
          let releasedCenterX = 0, releasedCenterY = 0;
          currentMousePosRef.current && mouseToDraggableCenterOffsetRef.current ? (releasedCenterX = currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x, releasedCenterY = currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y) : animatedPositionRef.current && (releasedCenterX = animatedPositionRef.current.x, releasedCenterY = animatedPositionRef.current.y);
          const borderLocation = provider.borderLocation, minX = borderLocation.left + draggableWidth / 2, maxX = borderLocation.right - draggableWidth / 2, minY = borderLocation.top + draggableHeight / 2, maxY = borderLocation.bottom - draggableHeight / 2;
          releasedCenterX = Math.max(minX, Math.min(releasedCenterX, maxX)), releasedCenterY = Math.max(minY, Math.min(releasedCenterY, maxY));
          const areaCenters = getSnapAreaCenters(borderLocation);
          let minDist = Number.POSITIVE_INFINITY, closestArea = null, closestCenter = null;
          for (const area in provider.snapAreas)
            if (provider.snapAreas[area]) {
              const center = areaCenters[area];
              if (!center) continue;
              const dist = Math.hypot(
                center.x - releasedCenterX,
                center.y - releasedCenterY
              );
              dist < minDist && (minDist = dist, closestArea = area, closestCenter = center);
            }
          if (closestArea && closestCenter) {
            finalSnapArea = closestArea, setCurrentSnapArea(closestArea);
            const relX = (closestCenter.x - parentViewportLeft) / parentWidth, relY = (closestCenter.y - parentViewportTop) / parentHeight;
            persistedRelativeCenterRef.current = { x: relX, y: relY };
          } else {
            finalSnapArea = null, setCurrentSnapArea(null);
            const relX = (releasedCenterX - parentViewportLeft) / parentWidth, relY = (releasedCenterY - parentViewportTop) / parentHeight;
            persistedRelativeCenterRef.current = { x: relX, y: relY };
          }
        }
        isDraggingRef.current = !1, animationInProgressRef.current = !0, animationFrameRef.current = requestAnimationFrame(
          updateDraggablePosition
        ), setIsDragging(!1), onDragEnd && onDragEnd(finalSnapArea), (_a = latestProviderDataRef.current) != null && _a.emitDragEnd && latestProviderDataRef.current.emitDragEnd();
      }
      mouseDownPosRef.current = null, window.removeEventListener("mousemove", mouseMoveHandler, {
        capture: !0
      }), window.removeEventListener("mouseup", mouseUpHandler, {
        capture: !0
      }), movingElementRef.current && (movingElementRef.current.style.userSelect = ""), document.body.style.userSelect = "", document.body.style.cursor = "";
    },
    [onDragEnd, updateDraggablePosition]
  ), mouseMoveHandler = useCallback(
    (e2) => {
      var _a;
      if (!mouseDownPosRef.current) return;
      Math.hypot(
        e2.clientX - mouseDownPosRef.current.x,
        e2.clientY - mouseDownPosRef.current.y
      ) > startThreshold && !isDraggingRef.current && (isDraggingRef.current = !0, setIsDragging(!0), movingElementRef.current && (movingElementRef.current.style.userSelect = "none"), document.body.style.userSelect = "none", document.body.style.cursor = "grabbing", onDragStart && onDragStart(), (_a = latestProviderDataRef.current) != null && _a.emitDragStart && latestProviderDataRef.current.emitDragStart(), animationInProgressRef.current = !0, animationFrameRef.current = requestAnimationFrame(
        updateDraggablePosition
      )), currentMousePosRef.current = { x: e2.clientX, y: e2.clientY };
    },
    [startThreshold, onDragStart, updateDraggablePosition]
  ), mouseDownHandler = useCallback(
    (e2) => {
      if (e2.button !== 0)
        return;
      const handleNode = dragInitiatorRef.current, draggableItemNode = movingElementRef.current;
      if (handleNode) {
        if (!handleNode.contains(e2.target) && e2.target !== handleNode)
          return;
      } else if (draggableItemNode) {
        if (!draggableItemNode.contains(e2.target) && e2.target !== draggableItemNode)
          return;
      } else {
        console.error(
          "Draggable element or handle ref not set in mouseDownHandler"
        );
        return;
      }
      if (mouseDownPosRef.current = { x: e2.clientX, y: e2.clientY }, !movingElementRef.current) {
        console.error("Draggable element ref not set in mouseDownHandler");
        return;
      }
      const rect = movingElementRef.current.getBoundingClientRect(), currentDraggableCenterX = rect.left + rect.width / 2, currentDraggableCenterY = rect.top + rect.height / 2;
      mouseToDraggableCenterOffsetRef.current = {
        x: e2.clientX - currentDraggableCenterX,
        y: e2.clientY - currentDraggableCenterY
      }, window.addEventListener("mousemove", mouseMoveHandler, {
        capture: !0
      }), window.addEventListener("mouseup", mouseUpHandler, {
        capture: !0
      });
    },
    [mouseMoveHandler, mouseUpHandler]
  );
  useEffect(() => {
    const elementToListenOn = dragInitiatorNode || movingElementNode;
    return elementToListenOn && elementToListenOn.addEventListener("mousedown", mouseDownHandler), () => {
      elementToListenOn && elementToListenOn.removeEventListener("mousedown", mouseDownHandler), isDraggingRef.current && (onDragEnd && onDragEnd(currentSnapArea), isDraggingRef.current = !1, setIsDragging(!1), movingElementNode && (movingElementNode.style.userSelect = ""), document.body.style.userSelect = "", document.body.style.cursor = "");
    };
  }, [
    movingElementNode,
    dragInitiatorNode,
    mouseDownHandler,
    onDragEnd,
    mouseMoveHandler,
    mouseUpHandler,
    currentSnapArea
  ]), useEffect(() => {
    movingElementRef.current && providerData && providerData.borderLocation && // Needed for calculations within updateDraggablePosition
    persistedRelativeCenterRef.current && // Ensure we have a center to position to
    !isDraggingRef.current && // Not currently dragging
    !hasAnimatedOnceRef.current && requestAnimationFrame(() => {
      movingElementRef.current && updateDraggablePosition();
    });
  }, [
    movingElementNode,
    // Run when element is available/changes
    providerData,
    // Run if provider context changes (for borderLocation)
    config2.initialRelativeCenter,
    // If this changes, persistedRelativeCenterRef might be re-initialized
    initialSnapArea,
    // If this changes, an effect updates persistedRelativeCenterRef
    updateDraggablePosition
    // Memoized callback for positioning
    // hasAnimatedOnceRef is intentionally not a dep, its current value is checked inside.
  ]);
  const draggableRefCallback = useCallback((node) => {
    setMovingElementNode(node), movingElementRef.current = node;
  }, []), handleRefCallback = useCallback((node) => {
    setDragInitiatorNode(node), dragInitiatorRef.current = node;
  }, []);
  return {
    draggableRef: draggableRefCallback,
    handleRef: handleRefCallback,
    position: {
      snapArea: currentSnapArea,
      isTopHalf: persistedRelativeCenterRef.current ? persistedRelativeCenterRef.current.y <= 0.5 : !0,
      isLeftHalf: persistedRelativeCenterRef.current ? persistedRelativeCenterRef.current.x <= 0.5 : !0
    },
    wasDragged,
    isDragging
  };
}
const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < "u" ? React__default.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {
  const ref = useRef(null);
  return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    ref.current = fn;
  }, [
    fn
  ]), useCallback((...args) => {
    const f2 = ref.current;
    return f2 == null ? void 0 : f2(...args);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el == null ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
}, $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => el && "window" in el && el.window === el ? el : $431fbd86ca7dc216$export$b204af158042fbac(el).defaultView || window;
function $431fbd86ca7dc216$var$isNode(value) {
  return value !== null && typeof value == "object" && "nodeType" in value && typeof value.nodeType == "number";
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(node) {
  return $431fbd86ca7dc216$var$isNode(node) && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in node;
}
let $f4e2df6bd15f8569$var$_shadowDOM = !1;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
  return $f4e2df6bd15f8569$var$_shadowDOM;
}
function $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return otherNode && node ? node.contains(otherNode) : !1;
  if (!node || !otherNode) return !1;
  let currentNode = otherNode;
  for (; currentNode !== null; ) {
    if (currentNode === node) return !0;
    currentNode.tagName === "SLOT" && currentNode.assignedSlot ? currentNode = currentNode.assignedSlot.parentNode : $431fbd86ca7dc216$export$af51f0f06c0f328a(currentNode) ? currentNode = currentNode.host : currentNode = currentNode.parentNode;
  }
  return !1;
}
const $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => {
  var _activeElement_shadowRoot;
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return doc.activeElement;
  let activeElement2 = doc.activeElement;
  for (; activeElement2 && "shadowRoot" in activeElement2 && (!((_activeElement_shadowRoot = activeElement2.shadowRoot) === null || _activeElement_shadowRoot === void 0) && _activeElement_shadowRoot.activeElement); ) activeElement2 = activeElement2.shadowRoot.activeElement;
  return activeElement2;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
  return $f4e2df6bd15f8569$export$98658e8c59125e6a() && event.target.shadowRoot && event.composedPath ? event.composedPath()[0] : event.target;
}
var define_process_env_default$J = {};
function $c87311424ea30a05$var$testUserAgent(re) {
  var _window_navigator_userAgentData;
  return typeof window > "u" || window.navigator == null ? !1 : ((_window_navigator_userAgentData = window.navigator.userAgentData) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re) {
  var _window_navigator_userAgentData;
  return typeof window < "u" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator.userAgentData) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : !1;
}
function $c87311424ea30a05$var$cached(fn) {
  if (define_process_env_default$J.NODE_ENV === "test") return fn;
  let res = null;
  return () => (res == null && (res = fn()), res);
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = useRef(/* @__PURE__ */ new Map()), addGlobalListener = useCallback((eventTarget, type, listener, options) => {
    let fn = options != null && options.once ? (...args) => {
      globalListeners.current.delete(listener), listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      fn,
      options
    }), eventTarget.addEventListener(type, fn, options);
  }, []), removeGlobalListener = useCallback((eventTarget, type, listener, options) => {
    var _globalListeners_current_get;
    let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type, fn, options), globalListeners.current.delete(listener);
  }, []), removeAllGlobalListeners = useCallback(() => {
    globalListeners.current.forEach((value, key) => {
      removeGlobalListener(value.eventTarget, value.type, key, value.options);
    });
  }, [
    removeGlobalListener
  ]);
  return useEffect(() => removeAllGlobalListeners, [
    removeAllGlobalListeners
  ]), {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}
function $6a7db85432448f7f$export$60278871457622de(event) {
  return event.mozInputSource === 0 && event.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType ? event.type === "click" && event.buttons === 1 : event.detail === 0 && !event.pointerType;
}
function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
  let event = nativeEvent;
  return event.nativeEvent = nativeEvent, event.isDefaultPrevented = () => event.defaultPrevented, event.isPropagationStopped = () => event.cancelBubble, event.persist = () => {
  }, event;
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {
  Object.defineProperty(event, "target", {
    value: target
  }), Object.defineProperty(event, "currentTarget", {
    value: target
  });
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = useRef({
    isFocused: !1,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const state = stateRef.current;
    return () => {
      state.observer && (state.observer.disconnect(), state.observer = null);
    };
  }, []);
  let dispatchBlur = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {
    onBlur == null || onBlur(e2);
  });
  return useCallback((e2) => {
    if (e2.target instanceof HTMLButtonElement || e2.target instanceof HTMLInputElement || e2.target instanceof HTMLTextAreaElement || e2.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = !0;
      let target = e2.target, onBlurHandler = (e3) => {
        if (stateRef.current.isFocused = !1, target.disabled) {
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e3);
          dispatchBlur(event);
        }
        stateRef.current.observer && (stateRef.current.observer.disconnect(), stateRef.current.observer = null);
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: !0
      }), stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 || _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          })), target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: relatedTargetEl
          }));
        }
      }), stateRef.current.observer.observe(target, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
let $8a9cb279dc87e130$export$fda7da73ab5d4c48 = !1;
var define_process_env_default$I = {};
let $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: !0,
  Escape: !0
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e2) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e2);
}
function $507fabe10e71c6fb$var$isValidKey(e2) {
  return !(e2.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e2) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$isValidKey(e2) && ($507fabe10e71c6fb$var$currentModality = "keyboard", $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e2));
}
function $507fabe10e71c6fb$var$handlePointerEvent(e2) {
  $507fabe10e71c6fb$var$currentModality = "pointer", (e2.type === "mousedown" || e2.type === "pointerdown") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e2));
}
function $507fabe10e71c6fb$var$handleClickEvent(e2) {
  $6a7db85432448f7f$export$60278871457622de(e2) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = "virtual");
}
function $507fabe10e71c6fb$var$handleFocusEvent(e2) {
  e2.target === window || e2.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !e2.isTrusted || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = "virtual", $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e2)), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1);
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
  if (typeof window > "u" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element))) return;
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element), documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let focus = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, focus.apply(this, arguments);
  }, documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : define_process_env_default$I.NODE_ENV === "test" && (documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
  }, {
    once: !0
  }), $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element), documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  loadListener && documentObject.removeEventListener("DOMContentLoaded", loadListener), $507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject) && (windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus, documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : define_process_env_default$I.NODE_ENV === "test" && (documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject));
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let loadListener;
  return documentObject.readyState !== "loading" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) : (loadListener = () => {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
  }, documentObject.addEventListener("DOMContentLoaded", loadListener)), () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
typeof document < "u" && $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e2) {
  let document1 = $431fbd86ca7dc216$export$b204af158042fbac(e2 == null ? void 0 : e2.target);
  const IHTMLInputElement = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLInputElement : HTMLInputElement, IHTMLTextAreaElement = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLTextAreaElement : HTMLTextAreaElement, IHTMLElement = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLElement : HTMLElement, IKeyboardEvent = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).KeyboardEvent : KeyboardEvent;
  return isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable, !(isTextInput && modality === "keyboard" && e2 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e2.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents(), useEffect(() => {
    let handler = (modality, e2) => {
      $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts != null && opts.isTextInput), modality, e2) && fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    return $507fabe10e71c6fb$var$changeHandlers.add(handler), () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = useCallback((e2) => {
    if (e2.target === e2.currentTarget)
      return onBlurProp && onBlurProp(e2), onFocusChange && onFocusChange(!1), !0;
  }, [
    onBlurProp,
    onFocusChange
  ]), onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur), onFocus = useCallback((e2) => {
    const ownerDocument2 = $431fbd86ca7dc216$export$b204af158042fbac(e2.target), activeElement2 = ownerDocument2 ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument2) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
    e2.target === e2.currentTarget && activeElement2 === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent) && (onFocusProp && onFocusProp(e2), onFocusChange && onFocusChange(!0), onSyntheticFocus(e2));
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props, state = useRef({
    isFocusWithin: !1
  }), { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6(), onBlur = useCallback((e2) => {
    e2.currentTarget.contains(e2.target) && state.current.isFocusWithin && !e2.currentTarget.contains(e2.relatedTarget) && (state.current.isFocusWithin = !1, removeAllGlobalListeners(), onBlurWithin && onBlurWithin(e2), onFocusWithinChange && onFocusWithinChange(!1));
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state,
    removeAllGlobalListeners
  ]), onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur), onFocus = useCallback((e2) => {
    if (!e2.currentTarget.contains(e2.target)) return;
    const ownerDocument2 = $431fbd86ca7dc216$export$b204af158042fbac(e2.target), activeElement2 = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument2);
    if (!state.current.isFocusWithin && activeElement2 === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      onFocusWithin && onFocusWithin(e2), onFocusWithinChange && onFocusWithinChange(!0), state.current.isFocusWithin = !0, onSyntheticFocus(e2);
      let currentTarget = e2.currentTarget;
      addGlobalListener(ownerDocument2, "focus", (e3) => {
        if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(currentTarget, e3.target)) {
          let nativeEvent = new ownerDocument2.defaultView.FocusEvent("blur", {
            relatedTarget: e3.target
          });
          $8a9cb279dc87e130$export$c2b7abe5d61ec696(nativeEvent, currentTarget);
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent);
          onBlur(event);
        }
      }, {
        capture: !0
      });
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus,
    addGlobalListener,
    onBlur
  ]);
  return isDisabled ? {
    focusWithinProps: {
      // These cannot be null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}
var define_process_env_default$H = {};
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0, setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e2) {
  e2.pointerType === "touch" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : define_process_env_default$H.NODE_ENV === "test" && document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents), $6179b936705e76d3$var$hoverCount++, () => {
      $6179b936705e76d3$var$hoverCount--, !($6179b936705e76d3$var$hoverCount > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : define_process_env_default$H.NODE_ENV === "test" && document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents));
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props, [isHovered, setHovered] = useState(!1), state = useRef({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6(), { hoverProps, triggerHoverEnd } = useMemo(() => {
    let triggerHoverStart = (event, pointerType) => {
      if (state.pointerType = pointerType, isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
      state.isHovered = !0;
      let target = event.currentTarget;
      state.target = target, addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), "pointerover", (e2) => {
        state.isHovered && state.target && !$d4ee10de306f2510$export$4282f70798064fe0(state.target, e2.target) && triggerHoverEnd2(e2, e2.pointerType);
      }, {
        capture: !0
      }), onHoverStart && onHoverStart({
        type: "hoverstart",
        target,
        pointerType
      }), onHoverChange && onHoverChange(!0), setHovered(!0);
    }, triggerHoverEnd2 = (event, pointerType) => {
      let target = state.target;
      state.pointerType = "", state.target = null, !(pointerType === "touch" || !state.isHovered || !target) && (state.isHovered = !1, removeAllGlobalListeners(), onHoverEnd && onHoverEnd({
        type: "hoverend",
        target,
        pointerType
      }), onHoverChange && onHoverChange(!1), setHovered(!1));
    }, hoverProps2 = {};
    return typeof PointerEvent < "u" ? (hoverProps2.onPointerEnter = (e2) => {
      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e2.pointerType === "mouse" || triggerHoverStart(e2, e2.pointerType);
    }, hoverProps2.onPointerLeave = (e2) => {
      !isDisabled && e2.currentTarget.contains(e2.target) && triggerHoverEnd2(e2, e2.pointerType);
    }) : define_process_env_default$H.NODE_ENV === "test" && (hoverProps2.onTouchStart = () => {
      state.ignoreEmulatedMouseEvents = !0;
    }, hoverProps2.onMouseEnter = (e2) => {
      !state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && triggerHoverStart(e2, "mouse"), state.ignoreEmulatedMouseEvents = !1;
    }, hoverProps2.onMouseLeave = (e2) => {
      !isDisabled && e2.currentTarget.contains(e2.target) && triggerHoverEnd2(e2, "mouse");
    }), {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state,
    addGlobalListener,
    removeAllGlobalListeners
  ]);
  return useEffect(() => {
    isDisabled && triggerHoverEnd({
      currentTarget: state.target
    }, state.pointerType);
  }, [
    isDisabled
  ]), {
    hoverProps,
    isHovered
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = !1, isTextInput, within } = props, state = useRef({
    isFocused: !1,
    isFocusVisible: autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  }), [isFocused, setFocused] = useState(!1), [isFocusVisibleState, setFocusVisible] = useState(() => state.current.isFocused && state.current.isFocusVisible), updateState = useCallback(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []), onFocusChange = useCallback((isFocused2) => {
    state.current.isFocused = isFocused2, setFocused(isFocused2), updateState();
  }, [
    updateState
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible, updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: within,
    onFocusChange
  }), { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}
var i = Object.defineProperty, d = (t2, e2, n2) => e2 in t2 ? i(t2, e2, { enumerable: !0, configurable: !0, writable: !0, value: n2 }) : t2[e2] = n2, r = (t2, e2, n2) => (d(t2, typeof e2 != "symbol" ? e2 + "" : e2, n2), n2);
let o$3 = class {
  constructor() {
    r(this, "current", this.detect()), r(this, "handoffState", "pending"), r(this, "currentId", 0);
  }
  set(e2) {
    this.current !== e2 && (this.handoffState = "pending", this.currentId = 0, this.current = e2);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$1 = new o$3();
function o$2(n2) {
  var e2, r2;
  return s$1.isServer ? null : n2 ? "ownerDocument" in n2 ? n2.ownerDocument : "current" in n2 ? (r2 = (e2 = n2.current) == null ? void 0 : e2.ownerDocument) != null ? r2 : document : null : document;
}
function t$1(e2) {
  typeof queueMicrotask == "function" ? queueMicrotask(e2) : Promise.resolve().then(e2).catch((o3) => setTimeout(() => {
    throw o3;
  }));
}
function o$1() {
  let n2 = [], r2 = { addEventListener(e2, t2, s2, a2) {
    return e2.addEventListener(t2, s2, a2), r2.add(() => e2.removeEventListener(t2, s2, a2));
  }, requestAnimationFrame(...e2) {
    let t2 = requestAnimationFrame(...e2);
    return r2.add(() => cancelAnimationFrame(t2));
  }, nextFrame(...e2) {
    return r2.requestAnimationFrame(() => r2.requestAnimationFrame(...e2));
  }, setTimeout(...e2) {
    let t2 = setTimeout(...e2);
    return r2.add(() => clearTimeout(t2));
  }, microTask(...e2) {
    let t2 = { current: !0 };
    return t$1(() => {
      t2.current && e2[0]();
    }), r2.add(() => {
      t2.current = !1;
    });
  }, style(e2, t2, s2) {
    let a2 = e2.style.getPropertyValue(t2);
    return Object.assign(e2.style, { [t2]: s2 }), this.add(() => {
      Object.assign(e2.style, { [t2]: a2 });
    });
  }, group(e2) {
    let t2 = o$1();
    return e2(t2), this.add(() => t2.dispose());
  }, add(e2) {
    return n2.includes(e2) || n2.push(e2), () => {
      let t2 = n2.indexOf(e2);
      if (t2 >= 0) for (let s2 of n2.splice(t2, 1)) s2();
    };
  }, dispose() {
    for (let e2 of n2.splice(0)) e2();
  } };
  return r2;
}
function p() {
  let [e2] = useState(o$1);
  return useEffect(() => () => e2.dispose(), [e2]), e2;
}
let n = (e2, t2) => {
  s$1.isServer ? useEffect(e2, t2) : useLayoutEffect(e2, t2);
};
function s(e2) {
  let r2 = useRef(e2);
  return n(() => {
    r2.current = e2;
  }, [e2]), r2;
}
let o2 = function(t2) {
  let e2 = s(t2);
  return React__default.useCallback((...r2) => e2.current(...r2), [e2]);
};
function E(e2) {
  let t2 = e2.width / 2, n2 = e2.height / 2;
  return { top: e2.clientY - n2, right: e2.clientX + t2, bottom: e2.clientY + n2, left: e2.clientX - t2 };
}
function P$2(e2, t2) {
  return !(!e2 || !t2 || e2.right < t2.left || e2.left > t2.right || e2.bottom < t2.top || e2.top > t2.bottom);
}
function w({ disabled: e2 = !1 } = {}) {
  let t2 = useRef(null), [n2, l] = useState(!1), r2 = p(), o$12 = o2(() => {
    t2.current = null, l(!1), r2.dispose();
  }), f2 = o2((s2) => {
    if (r2.dispose(), t2.current === null) {
      t2.current = s2.currentTarget, l(!0);
      {
        let i2 = o$2(s2.currentTarget);
        r2.addEventListener(i2, "pointerup", o$12, !1), r2.addEventListener(i2, "pointermove", (c2) => {
          if (t2.current) {
            let p2 = E(c2);
            l(P$2(p2, t2.current.getBoundingClientRect()));
          }
        }, !1), r2.addEventListener(i2, "pointercancel", o$12, !1);
      }
    }
  });
  return { pressed: n2, pressProps: e2 ? {} : { onPointerDown: f2, onPointerUp: o$12, onClick: o$12 } };
}
let e$1 = createContext(void 0);
function a$1() {
  return useContext(e$1);
}
function t(...r2) {
  return Array.from(new Set(r2.flatMap((n2) => typeof n2 == "string" ? n2.split(" ") : []))).filter(Boolean).join(" ");
}
function u$2(r2, n2, ...a2) {
  if (r2 in n2) {
    let e2 = n2[r2];
    return typeof e2 == "function" ? e2(...a2) : e2;
  }
  let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e2) => `"${e2}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$2), t2;
}
var O = ((a2) => (a2[a2.None = 0] = "None", a2[a2.RenderStrategy = 1] = "RenderStrategy", a2[a2.Static = 2] = "Static", a2))(O || {}), A = ((e2) => (e2[e2.Unmount = 0] = "Unmount", e2[e2.Hidden = 1] = "Hidden", e2))(A || {});
function L$1() {
  let n2 = U$2();
  return useCallback((r2) => C$1({ mergeRefs: n2, ...r2 }), [n2]);
}
function C$1({ ourProps: n2, theirProps: r2, slot: e2, defaultTag: a2, features: s2, visible: t2 = !0, name: l, mergeRefs: i2 }) {
  i2 = i2 ?? $;
  let o3 = P$1(r2, n2);
  if (t2) return F(o3, e2, a2, l, i2);
  let y2 = s2 ?? 0;
  if (y2 & 2) {
    let { static: f2 = !1, ...u2 } = o3;
    if (f2) return F(u2, e2, a2, l, i2);
  }
  if (y2 & 1) {
    let { unmount: f2 = !0, ...u2 } = o3;
    return u$2(f2 ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return F({ ...u2, hidden: !0, style: { display: "none" } }, e2, a2, l, i2);
    } });
  }
  return F(o3, e2, a2, l, i2);
}
function F(n2, r2 = {}, e2, a2, s2) {
  let { as: t$12 = e2, children: l, refName: i2 = "ref", ...o3 } = h(n2, ["unmount", "static"]), y2 = n2.ref !== void 0 ? { [i2]: n2.ref } : {}, f2 = typeof l == "function" ? l(r2) : l;
  "className" in o3 && o3.className && typeof o3.className == "function" && (o3.className = o3.className(r2)), o3["aria-labelledby"] && o3["aria-labelledby"] === o3.id && (o3["aria-labelledby"] = void 0);
  let u2 = {};
  if (r2) {
    let d2 = !1, p2 = [];
    for (let [c2, T] of Object.entries(r2)) typeof T == "boolean" && (d2 = !0), T === !0 && p2.push(c2.replace(/([A-Z])/g, (g) => `-${g.toLowerCase()}`));
    if (d2) {
      u2["data-headlessui-state"] = p2.join(" ");
      for (let c2 of p2) u2[`data-${c2}`] = "";
    }
  }
  if (t$12 === Fragment && (Object.keys(m(o3)).length > 0 || Object.keys(m(u2)).length > 0)) if (!isValidElement(f2) || Array.isArray(f2) && f2.length > 1) {
    if (Object.keys(m(o3)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${a2} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m(o3)).concat(Object.keys(m(u2))).map((d2) => `  - ${d2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d2) => `  - ${d2}`).join(`
`)].join(`
`));
  } else {
    let d2 = f2.props, p2 = d2 == null ? void 0 : d2.className, c2 = typeof p2 == "function" ? (...R2) => t(p2(...R2), o3.className) : t(p2, o3.className), T = c2 ? { className: c2 } : {}, g = P$1(f2.props, m(h(o3, ["ref"])));
    for (let R2 in u2) R2 in g && delete u2[R2];
    return cloneElement(f2, Object.assign({}, g, u2, y2, { ref: s2(H$2(f2), y2.ref) }, T));
  }
  return createElement(t$12, Object.assign({}, h(o3, ["ref"]), t$12 !== Fragment && y2, t$12 !== Fragment && u2), f2);
}
function U$2() {
  let n2 = useRef([]), r2 = useCallback((e2) => {
    for (let a2 of n2.current) a2 != null && (typeof a2 == "function" ? a2(e2) : a2.current = e2);
  }, []);
  return (...e2) => {
    if (!e2.every((a2) => a2 == null)) return n2.current = e2, r2;
  };
}
function $(...n2) {
  return n2.every((r2) => r2 == null) ? void 0 : (r2) => {
    for (let e2 of n2) e2 != null && (typeof e2 == "function" ? e2(r2) : e2.current = r2);
  };
}
function P$1(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  if (r2.disabled || r2["aria-disabled"]) for (let s2 in e2) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s2) && (e2[s2] = [(t2) => {
    var l;
    return (l = t2 == null ? void 0 : t2.preventDefault) == null ? void 0 : l.call(t2);
  }]);
  for (let s2 in e2) Object.assign(r2, { [s2](t2, ...l) {
    let i2 = e2[s2];
    for (let o3 of i2) {
      if ((t2 instanceof Event || (t2 == null ? void 0 : t2.nativeEvent) instanceof Event) && t2.defaultPrevented) return;
      o3(t2, ...l);
    }
  } });
  return r2;
}
function _$1(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  for (let s2 in e2) Object.assign(r2, { [s2](...t2) {
    let l = e2[s2];
    for (let i2 of l) i2 == null || i2(...t2);
  } });
  return r2;
}
function K(n2) {
  var r2;
  return Object.assign(forwardRef(n2), { displayName: (r2 = n2.displayName) != null ? r2 : n2.name });
}
function m(n2) {
  let r2 = Object.assign({}, n2);
  for (let e2 in r2) r2[e2] === void 0 && delete r2[e2];
  return r2;
}
function h(n2, r2 = []) {
  let e2 = Object.assign({}, n2);
  for (let a2 of r2) a2 in e2 && delete e2[a2];
  return e2;
}
function H$2(n2) {
  return React__default.version.split(".")[0] >= "19" ? n2.props.ref : n2.ref;
}
let R = "button";
function v(a2, u2) {
  var p2;
  let l = a$1(), { disabled: e2 = l || !1, autoFocus: t2 = !1, ...o3 } = a2, { isFocusVisible: r2, focusProps: i2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: t2 }), { isHovered: s2, hoverProps: T } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e2 }), { pressed: n2, pressProps: d2 } = w({ disabled: e2 }), f2 = _$1({ ref: u2, type: (p2 = o3.type) != null ? p2 : "button", disabled: e2 || void 0, autoFocus: t2 }, i2, T, d2), m2 = useMemo(() => ({ disabled: e2, hover: s2, focus: r2, active: n2, autofocus: t2 }), [e2, s2, r2, n2, t2]);
  return L$1()({ ourProps: f2, theirProps: o3, slot: m2, defaultTag: R, name: "Button" });
}
let H$1 = K(v), e = createContext(void 0);
function u$1() {
  return useContext(e);
}
let u = Symbol();
function y(...t2) {
  let n2 = useRef(t2);
  useEffect(() => {
    n2.current = t2;
  }, [t2]);
  let c2 = o2((e2) => {
    for (let o3 of n2.current) o3 != null && (typeof o3 == "function" ? o3(e2) : o3.current = e2);
  });
  return t2.every((e2) => e2 == null || (e2 == null ? void 0 : e2[u])) ? void 0 : c2;
}
let a = createContext(null);
a.displayName = "DescriptionContext";
function f() {
  let r2 = useContext(a);
  if (r2 === null) {
    let e2 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(e2, f), e2;
  }
  return r2;
}
function U$1() {
  var r2, e2;
  return (e2 = (r2 = useContext(a)) == null ? void 0 : r2.value) != null ? e2 : void 0;
}
let S = "p";
function C(r2, e2) {
  let d2 = useId$1(), t2 = a$1(), { id: i2 = `headlessui-description-${d2}`, ...l } = r2, n$1 = f(), s2 = y(e2);
  n(() => n$1.register(i2), [i2, n$1.register]);
  let o3 = t2 || !1, p2 = useMemo(() => ({ ...n$1.slot, disabled: o3 }), [n$1.slot, o3]), D = { ref: s2, ...n$1.props, id: i2 };
  return L$1()({ ourProps: D, theirProps: l, slot: p2, defaultTag: S, name: n$1.name || "Description" });
}
let _ = K(C);
Object.assign(_, {});
let c = createContext(null);
c.displayName = "LabelContext";
function P() {
  let r2 = useContext(c);
  if (r2 === null) {
    let l = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(l, P), l;
  }
  return r2;
}
function I(r2) {
  var a2, e2, o3;
  let l = (e2 = (a2 = useContext(c)) == null ? void 0 : a2.value) != null ? e2 : void 0;
  return ((o3 = void 0) != null ? o3 : 0) > 0 ? [l, ...r2].filter(Boolean).join(" ") : l;
}
let N = "label";
function G(r2, l) {
  var y$1;
  let a2 = useId$1(), e2 = P(), o$12 = u$1(), g = a$1(), { id: t2 = `headlessui-label-${a2}`, htmlFor: s2 = o$12 ?? ((y$1 = e2.props) == null ? void 0 : y$1.htmlFor), passive: m2 = !1, ...i2 } = r2, p2 = y(l);
  n(() => e2.register(t2), [t2, e2.register]);
  let u2 = o2((L2) => {
    let b = L2.currentTarget;
    if (b instanceof HTMLLabelElement && L2.preventDefault(), e2.props && "onClick" in e2.props && typeof e2.props.onClick == "function" && e2.props.onClick(L2), b instanceof HTMLLabelElement) {
      let n2 = document.getElementById(b.htmlFor);
      if (n2) {
        let E2 = n2.getAttribute("disabled");
        if (E2 === "true" || E2 === "") return;
        let x = n2.getAttribute("aria-disabled");
        if (x === "true" || x === "") return;
        (n2 instanceof HTMLInputElement && (n2.type === "radio" || n2.type === "checkbox") || n2.role === "radio" || n2.role === "checkbox" || n2.role === "switch") && n2.click(), n2.focus({ preventScroll: !0 });
      }
    }
  }), d2 = g || !1, C2 = useMemo(() => ({ ...e2.slot, disabled: d2 }), [e2.slot, d2]), f2 = { ref: p2, ...e2.props, id: t2, htmlFor: s2, onClick: u2 };
  return m2 && ("onClick" in f2 && (delete f2.htmlFor, delete f2.onClick), "onClick" in i2 && delete i2.onClick), L$1()({ ourProps: f2, theirProps: i2, slot: C2, defaultTag: s2 ? N : "div", name: e2.name || "Label" });
}
let U = K(G);
Object.assign(U, {});
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || "").toLowerCase() : "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return hasWindow() ? value instanceof Node || value instanceof getWindow(value).Node : !1;
}
function isElement(value) {
  return hasWindow() ? value instanceof Element || value instanceof getWindow(value).Element : !1;
}
function isHTMLElement(value) {
  return hasWindow() ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : !1;
}
function isShadowRoot(value) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch {
      return !1;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"], willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"], containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit$1(), css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : !1) || (css.containerType ? css.containerType !== "normal" : !1) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : !1) || !webkit && (css.filter ? css.filter !== "none" : !1) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  for (; isHTMLElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    if (isContainingBlock(currentNode))
      return currentNode;
    if (isTopLayer(currentNode))
      return null;
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit$1() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  return isElement(element) ? {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  } : {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html")
    return node;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  return isLastTraversableNode(parentNode) ? node.ownerDocument ? node.ownerDocument.body : node.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  list === void 0 && (list = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node), isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
const sides = ["top", "right", "bottom", "left"], min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (v2) => ({
  x: v2,
  y: v2
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value == "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1);
  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  return rects.reference[length] > rects.floating[length] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      return rtl ? isStart ? rlPlacement : lrPlacement : isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  return alignment && (list = list.map((side) => side + "-" + alignment), flipAlignment && (list = list.concat(list.map(getOppositeAlignmentPlacement)))), list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding != "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x,
    right: x + width,
    bottom: y2 + height,
    x,
    y: y2
  };
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], candidateSelector = /* @__PURE__ */ candidateSelectors.join(","), NoElement = typeof Element > "u", matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element == null || (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element == null ? void 0 : element.ownerDocument;
}, isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  lookUp === void 0 && (lookUp = !0);
  var inertAtt = node == null || (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert"), inert = inertAtt === "" || inertAtt === "true", result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
}, isContentEditable = function(node) {
  var _node$getAttribute2, attValue = node == null || (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
}, getCandidates = function(el, includeContainer, filter) {
  if (isInert(el))
    return [];
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  return includeContainer && matches.call(el, candidateSelector) && candidates.unshift(el), candidates = candidates.filter(filter), candidates;
}, getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  for (var candidates = [], elementsToCheck = Array.from(elements); elementsToCheck.length; ) {
    var element = elementsToCheck.shift();
    if (!isInert(element, !1))
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements(), content = assigned.length ? assigned : element.children, nestedCandidates = getCandidatesIteratively2(content, !0, options);
        options.flatten ? candidates.push.apply(candidates, nestedCandidates) : candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        validCandidate && options.filter(element) && (includeContainer || !elements.includes(element)) && candidates.push(element);
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot == "function" && options.getShadowRoot(element), validShadowRoot = !isInert(shadowRoot, !1) && (!options.shadowRootFilter || options.shadowRootFilter(element));
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === !0 ? element.children : shadowRoot.children, !0, options);
          options.flatten ? candidates.push.apply(candidates, _nestedCandidates) : candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        } else
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
  }
  return candidates;
}, hasTabIndex = function(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
}, getTabIndex = function(node) {
  if (!node)
    throw new Error("No node provided");
  return node.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node) ? 0 : node.tabIndex;
}, getSortOrderTabIndex = function(node, isScope) {
  var tabIndex = getTabIndex(node);
  return tabIndex < 0 && isScope && !hasTabIndex(node) ? 0 : tabIndex;
}, sortOrderedTabbables = function(a2, b) {
  return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
}, isInput = function(node) {
  return node.tagName === "INPUT";
}, isHiddenInput = function(node) {
  return isInput(node) && node.type === "hidden";
}, isDetailsWithSummary = function(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
}, getCheckedRadio = function(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++)
    if (nodes[i2].checked && nodes[i2].form === form)
      return nodes[i2];
}, isTabbableRadio = function(node) {
  if (!node.name)
    return !0;
  var radioScope = node.form || getRootNode(node), queryRadios = function(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  }, radioSet;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    radioSet = queryRadios(window.CSS.escape(node.name));
  else
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message), !1;
    }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
}, isRadio = function(node) {
  return isInput(node) && node.type === "radio";
}, isNonTabbableRadio = function(node) {
  return isRadio(node) && !isTabbableRadio(node);
}, isNodeAttached = function(node) {
  var _nodeRoot, nodeRoot = node && getRootNode(node), nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host, attached = !1;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    for (attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node != null && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node)); !attached && nodeRootHost; ) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost), nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host, attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
}, isZeroArea = function(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
}, isHidden = function(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden")
    return !0;
  var isDirectSummary = matches.call(node, "details>summary:first-of-type"), nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *"))
    return !0;
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot == "function") {
      for (var originalNode = node; node; ) {
        var parentElement = node.parentElement, rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === !0)
          return isZeroArea(node);
        node.assignedSlot ? node = node.assignedSlot : !parentElement && rootNode !== node.ownerDocument ? node = rootNode.host : node = parentElement;
      }
      node = originalNode;
    }
    if (isNodeAttached(node))
      return !node.getClientRects().length;
    if (displayCheck !== "legacy-full")
      return !0;
  } else if (displayCheck === "non-zero-area")
    return isZeroArea(node);
  return !1;
}, isDisabledFromFieldset = function(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName))
    for (var parentNode = node.parentElement; parentNode; ) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND")
            return matches.call(parentNode, "fieldset[disabled] *") ? !0 : !child.contains(node);
        }
        return !0;
      }
      parentNode = parentNode.parentElement;
    }
  return !1;
}, isNodeMatchingSelectorFocusable = function(options, node) {
  return !(node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node));
}, isNodeMatchingSelectorTabbable = function(options, node) {
  return !(isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node));
}, isValidShadowRootTabbable = function(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  return !!(isNaN(tabIndex) || tabIndex >= 0);
}, sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [], orderedTabbables = [];
  return candidates.forEach(function(item, i2) {
    var isScope = !!item.scopeParent, element = isScope ? item.scopeParent : item, candidateTabindex = getSortOrderTabIndex(element, isScope), elements = isScope ? sortByOrder2(item.candidates) : element;
    candidateTabindex === 0 ? isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element) : orderedTabbables.push({
      documentOrder: i2,
      tabIndex: candidateTabindex,
      item,
      isScope,
      content: elements
    });
  }), orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    return sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content), acc;
  }, []).concat(regularTabbables);
}, tabbable = function(container, options) {
  options = options || {};
  var candidates;
  return options.getShadowRoot ? candidates = getCandidatesIteratively([container], options.includeContainer, {
    filter: isNodeMatchingSelectorTabbable.bind(null, options),
    flatten: !1,
    getShadowRoot: options.getShadowRoot,
    shadowRootFilter: isValidShadowRootTabbable
  }) : candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options)), sortByOrder(candidates);
}, focusable = function(container, options) {
  options = options || {};
  var candidates;
  return options.getShadowRoot ? candidates = getCandidatesIteratively([container], options.includeContainer, {
    filter: isNodeMatchingSelectorFocusable.bind(null, options),
    flatten: !0,
    getShadowRoot: options.getShadowRoot
  }) : candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options)), candidates;
}, isTabbable = function(node, options) {
  if (options = options || {}, !node)
    throw new Error("No node provided");
  return matches.call(node, candidateSelector) === !1 ? !1 : isNodeMatchingSelectorTabbable(options, node);
};
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === "y", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2, validMiddleware = middleware.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  }), {
    x,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2], {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX ?? x, y2 = nextY ?? y2, middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    }, reset && resetCount <= 50 && (resetCount++, typeof reset == "object" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({
      reference,
      floating,
      strategy
    }) : reset.rects), {
      x,
      y: y2
    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i2 = -1);
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  options === void 0 && (options = {});
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state, {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = !1,
    padding = 0
  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) == null || _await$platform$isEle ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  })), rect = elementContext === "floating" ? {
    x,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const flip$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)
        return {};
      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      const placements = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow(state, detectOverflowOptions), overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      if (overflowsData = [...overflowsData, {
        placement,
        overflows
      }], !overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements[nextIndex];
        if (nextPlacement && (!(checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        overflowsData.every((d2) => getSideAxis(d2.placement) === initialSideAxis ? d2.overflows[0] > 0 : !0)))
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement)
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return !0;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              placement2 && (resetPlacement = placement2);
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        if (placement !== resetPlacement)
          return {
            reset: {
              placement: resetPlacement
            }
          };
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state, {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          }), offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: !0
          }), offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === "y", mainAxisMulti = originSides.has(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue == "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  return alignment && typeof alignmentAxis == "number" && (crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  return options === void 0 && (options = 0), {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y: y2,
        placement,
        middlewareData
      } = state, diffCoords = await convertValueToCoords(state, options);
      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {
        x: x + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, shift$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y: y2,
        placement
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !1,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y3
            } = _ref;
            return {
              x: x2,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state), coords = {
        x,
        y: y2
      }, overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left", maxSide = mainAxis === "y" ? "bottom" : "right", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left", maxSide = crossAxis === "y" ? "bottom" : "right", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
}, limitShift$2 = function(options) {
  return options === void 0 && (options = {}), {
    options,
    fn(state) {
      const {
        x,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state, {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0
      } = evaluate(options, state), coords = {
        x,
        y: y2
      }, crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state), computedOffset = typeof rawOffset == "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width", limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis, limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > limitMax && (mainAxisCoord = limitMax);
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height", isOriginSide = originSides.has(getSide(placement)), limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide && ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0) + (isOriginSide ? 0 : computedOffset.crossAxis), limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        crossAxisCoord < limitMin ? crossAxisCoord = limitMin : crossAxisCoord > limitMax && (crossAxisCoord = limitMax);
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
}, size$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state, {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions), side = getSide(placement), alignment = getAlignment(placement), isYAxis = getSideAxis(placement) === "y", {
        width,
        height
      } = rects.floating;
      let heightSide, widthSide;
      side === "top" || side === "bottom" ? (heightSide = side, widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right") : (widthSide = side, heightSide = alignment === "end" ? "top" : "bottom");
      const maximumClippingHeight = height - overflow.top - overflow.bottom, maximumClippingWidth = width - overflow.left - overflow.right, overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight), overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth), noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight, availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x && (availableWidth = maximumClippingWidth), (_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y && (availableHeight = maximumClippingHeight), noShift && !alignment) {
        const xMin = max(overflow.left, 0), xMax = max(overflow.right, 0), yMin = max(overflow.top, 0), yMax = max(overflow.bottom, 0);
        isYAxis ? availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      return width !== nextDimensions.width || height !== nextDimensions.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0, height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return isElement(element) ? element : element.contextElement;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x = ($2 ? round(rect.width) : rect.width) / width, y2 = ($2 ? round(rect.height) : rect.height) / height;
  return (!x || !Number.isFinite(x)) && (x = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  return !isWebKit$1() || !win.visualViewport ? noOffsets : {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x, y2 = (clientRect.top + visualOffsets.y) / scale.y, width = clientRect.width / scale.x, height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win, currentIFrame = getFrameElement(currentWin);
    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css = getComputedStyle$1(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x += left, y2 += top, currentWin = getWindow(currentIFrame), currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  return rect ? rect.left + leftScroll : getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  ignoreScrollbarX === void 0 && (ignoreScrollbarX = !1);
  const htmlRect = documentElement.getBoundingClientRect(), x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  )), y2 = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;
  if (offsetParent === documentElement || topLayer && isFixed)
    return rect;
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  }, scale = createCoords(1);
  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement(offsetParent);
  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent))) {
    const offsetRect = getBoundingClientRect(offsetParent);
    scale = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, !0) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element), scroll = getNodeScroll(element), body = element.ownerDocument.body, width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth), height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  return getComputedStyle$1(body).direction === "rtl" && (x += max(html.clientWidth, body.clientWidth) - width), {
    width,
    height,
    x,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element), html = getDocumentElement(element), visualViewport = win.visualViewport;
  let width = html.clientWidth, height = html.clientHeight, x = 0, y2 = 0;
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height;
    const visualViewportBased = isWebKit$1();
    (!visualViewportBased || visualViewportBased && strategy === "fixed") && (x = visualViewport.offsetLeft, y2 = visualViewport.offsetTop);
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, !0, strategy === "fixed"), top = clientRect.top + element.clientTop, left = clientRect.left + element.clientLeft, scale = isHTMLElement(element) ? getScale(element) : createCoords(1), width = element.clientWidth * scale.x, height = element.clientHeight * scale.y, x = left * scale.x, y2 = top * scale.y;
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport")
    rect = getViewportRect(element, strategy);
  else if (clippingAncestor === "document")
    rect = getDocumentRect(getDocumentElement(element));
  else if (isElement(clippingAncestor))
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult)
    return cachedResult;
  let result = getOverflowAncestors(element, [], !1).filter((el) => isElement(el) && getNodeName(el) !== "body"), currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  for (; isElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    const computedStyle = getComputedStyle$1(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
    !currentNodeIsContaining && computedStyle.position === "fixed" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);
  }
  return cache.set(element, result), result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    return accRect.top = max(rect.top, accRect.top), accRect.right = min(rect.right, accRect.right), accRect.bottom = min(rect.bottom, accRect.bottom), accRect.left = max(rect.left, accRect.left), accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === "fixed", rect = getBoundingClientRect(element, !0, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    if ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
    } else documentElement && setLeftRTLScrollbarOffset();
  isFixed && !isOffsetParentAnElement && documentElement && setLeftRTLScrollbarOffset();
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0), x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x, y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed")
    return null;
  if (polyfill)
    return polyfill(element);
  let rawOffsetParent = element.offsetParent;
  return getDocumentElement(element) === rawOffsetParent && (rawOffsetParent = rawOffsetParent.ownerDocument.body), rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element))
    return win;
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))
        return svgOffsetParent;
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win : offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform$1 = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b) {
  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;
}
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect(), {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root.clientWidth - (left + width)), insetBottom = floor(root.clientHeight - (top + height)), insetLeft = floor(left), options = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 1e3);
      }
      ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect()) && refresh(), isFirstUpdate = !1;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  return refresh(!0), cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  options === void 0 && (options = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref) => {
    let [firstEntry] = _ref;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
    })), update2();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect) && update2(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return update2(), () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2), ancestorResize && ancestor.removeEventListener("resize", update2);
    }), cleanupIo == null || cleanupIo(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
const offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, hide$1 = hide$2, limitShift$1 = limitShift$2, computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map(), mergedOptions = {
    platform: platform$1,
    ...options
  }, platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document < "u", noop$1 = function() {
}, index = isClient ? useLayoutEffect : noop$1;
function deepEqual(a2, b) {
  if (a2 === b)
    return !0;
  if (typeof a2 != typeof b)
    return !1;
  if (typeof a2 == "function" && a2.toString() === b.toString())
    return !0;
  let length, i2, keys;
  if (a2 && b && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      if (length = a2.length, length !== b.length) return !1;
      for (i2 = length; i2-- !== 0; )
        if (!deepEqual(a2[i2], b[i2]))
          return !1;
      return !0;
    }
    if (keys = Object.keys(a2), length = keys.length, length !== Object.keys(b).length)
      return !1;
    for (i2 = length; i2-- !== 0; )
      if (!{}.hasOwnProperty.call(b, keys[i2]))
        return !1;
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (!(key === "_owner" && a2.$$typeof) && !deepEqual(a2[key], b[key]))
        return !1;
    }
    return !0;
  }
  return a2 !== a2 && b !== b;
}
function getDPR(element) {
  return typeof window > "u" ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = React.useRef(value);
  return index(() => {
    ref.current = value;
  }), ref;
}
function useFloating$1(options) {
  options === void 0 && (options = {});
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = !0,
    whileElementsMounted,
    open
  } = options, [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: !1
  }), [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  deepEqual(latestMiddleware, middleware) || setLatestMiddleware(middleware);
  const [_reference, _setReference] = React.useState(null), [_floating, _setFloating] = React.useState(null), setReference = React.useCallback((node) => {
    node !== referenceRef.current && (referenceRef.current = node, _setReference(node));
  }, []), setFloating = React.useCallback((node) => {
    node !== floatingRef.current && (floatingRef.current = node, _setFloating(node));
  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React.useRef(null), floatingRef = React.useRef(null), dataRef = React.useRef(data), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef$1(whileElementsMounted), platformRef = useLatestRef$1(platform2), openRef = useLatestRef$1(open), update2 = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current)
      return;
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    platformRef.current && (config2.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== !1
      };
      isMountedRef.current && !deepEqual(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {
        setData(fullData);
      }));
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData((data2) => ({
      ...data2,
      isPositioned: !1
    })));
  }, [open]);
  const isMountedRef = React.useRef(!1);
  index(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), index(() => {
    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {
      if (whileElementsMountedRef.current)
        return whileElementsMountedRef.current(referenceEl, floatingEl, update2);
      update2();
    }
  }, [referenceEl, floatingEl, update2, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]), elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]), floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating)
      return initialStyles;
    const x = roundByDPR(elements.floating, data.x), y2 = roundByDPR(elements.floating, data.y);
    return transform ? {
      ...initialStyles,
      transform: "translate(" + x + "px, " + y2 + "px)",
      ...getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: strategy,
      left: x,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update: update2,
    refs,
    elements,
    floatingStyles
  }), [data, update2, refs, elements, floatingStyles]);
}
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
}), shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
}), flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
}), hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
let L = "textarea";
function H(s2, l) {
  let i2 = useId$1(), d2 = u$1(), n2 = a$1(), { id: p2 = d2 || `headlessui-textarea-${i2}`, disabled: e2 = n2 || !1, autoFocus: r2 = !1, invalid: a2 = !1, ...T } = s2, f2 = I(), m2 = U$1(), { isFocused: o3, focusProps: u2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r2 }), { isHovered: t2, hoverProps: b } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e2 }), y2 = _$1({ ref: l, id: p2, "aria-labelledby": f2, "aria-describedby": m2, "aria-invalid": a2 ? "true" : void 0, disabled: e2 || void 0, autoFocus: r2 }, u2, b), x = useMemo(() => ({ disabled: e2, invalid: a2, hover: t2, focus: o3, autofocus: r2 }), [e2, a2, t2, o3, r2]);
  return L$1()({ ourProps: y2, theirProps: T, slot: x, defaultTag: L, name: "Textarea" });
}
let J = K(H);
function ToolbarItem(props) {
  return /* @__PURE__ */ jsxs("div", { className: "relative flex w-full shrink-0 items-center justify-center", children: [
    props.children,
    props.badgeContent && /* @__PURE__ */ jsx(
      "div",
      {
        className: cn(
          "bg-blue-600 text-white",
          props.badgeClassName,
          "pointer-events-none absolute right-0 bottom-0 flex h-3 w-max min-w-3 max-w-8 select-none items-center justify-center truncate rounded-full px-0.5 font-semibold text-[0.5em]"
        ),
        children: props.badgeContent
      }
    ),
    props.statusDot && /* @__PURE__ */ jsx(
      "div",
      {
        className: cn(
          "bg-rose-600 text-white",
          props.statusDotClassName,
          "pointer-events-none absolute top-0 right-0 size-1.5 rounded-full"
        )
      }
    )
  ] });
}
const ToolbarButton = forwardRef(
  ({
    badgeContent,
    badgeClassName,
    statusDot,
    statusDotClassName,
    tooltipHint,
    variant = "default",
    active,
    ...props
  }, ref) => {
    const button = /* @__PURE__ */ jsx(
      H$1,
      {
        ref,
        ...props,
        className: cn(
          "flex cursor-pointer items-center justify-center rounded-full bg-radial from-transparent to-transparent p-1 text-current transition-all duration-150 hover:from-20% hover:from-zinc-100/40 hover:to-75% hover:to-zinc-100/0",
          variant === "default" ? "size-8" : "h-8 rounded-full",
          active && "from-30% from-zinc-100/60 to-75% to-zinc-100/0 fill-[var(--active)] stroke-[var(--active)] text-[var(--active)]",
          props.className
        )
      }
    );
    return /* @__PURE__ */ jsx(
      ToolbarItem,
      {
        badgeContent,
        badgeClassName,
        statusDot,
        statusDotClassName,
        children: button
      }
    );
  }
);
ToolbarButton.displayName = "ToolbarButton";
function ToolbarSection({ children }) {
  return /* @__PURE__ */ jsx("div", { className: "fade-in slide-in-from-right-2 flex max-h-sm max-w-full animate-in snap-start flex-col items-center justify-between gap-1 py-0.5", children });
}
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), toCamelCase = (string) => string.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
), toPascalCase = (string) => {
  const camelCase = toCamelCase(string);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
}, mergeClasses = (...classes) => classes.filter((className, index2, array) => !!className && className.trim() !== "" && array.indexOf(className) === index2).join(" ").trim(), hasA11yProp = (props) => {
  for (const prop in props)
    if (prop.startsWith("aria-") || prop === "role" || prop === "title")
      return !0;
};
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = forwardRef(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => createElement(
    "svg",
    {
      ref,
      ...defaultAttributes,
      width: size2,
      height: size2,
      stroke: color,
      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
      className: mergeClasses("lucide", className),
      ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
      ...rest
    },
    [
      ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
      ...Array.isArray(children) ? children : [children]
    ]
  )
);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = forwardRef(
    ({ className, ...props }, ref) => createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props
    })
  );
  return Component.displayName = toPascalCase(iconName), Component;
};
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$f = [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
], ArrowUp = createLucideIcon("arrow-up", __iconNode$f);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$e = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], Check = createLucideIcon("check", __iconNode$e);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$d = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], ChevronDown = createLucideIcon("chevron-down", __iconNode$d);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$c = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], ChevronUp = createLucideIcon("chevron-up", __iconNode$c);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$b = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
], CircleX = createLucideIcon("circle-x", __iconNode$b);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$a = [
  ["path", { d: "M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z", key: "sobvz5" }],
  ["path", { d: "M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", key: "11i496" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M12 22v-2", key: "1osdcq" }],
  ["path", { d: "m17 20.66-1-1.73", key: "eq3orb" }],
  ["path", { d: "M11 10.27 7 3.34", key: "16pf9h" }],
  ["path", { d: "m20.66 17-1.73-1", key: "sg0v6f" }],
  ["path", { d: "m3.34 7 1.73 1", key: "1ulond" }],
  ["path", { d: "M14 12h8", key: "4f43i9" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "m20.66 7-1.73 1", key: "1ow05n" }],
  ["path", { d: "m3.34 17 1.73-1", key: "nuk764" }],
  ["path", { d: "m17 3.34-1 1.73", key: "2wel8s" }],
  ["path", { d: "m11 13.73-4 6.93", key: "794ttg" }]
], Cog = createLucideIcon("cog", __iconNode$a);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$9 = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
], Copy = createLucideIcon("copy", __iconNode$9);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$8 = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], LoaderCircle = createLucideIcon("loader-circle", __iconNode$8);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$7 = [
  ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
], MessageCircleQuestionMark = createLucideIcon("message-circle-question-mark", __iconNode$7);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$6 = [
  ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }]
], MessageCircle = createLucideIcon("message-circle", __iconNode$6);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$5 = [
  ["path", { d: "M12.586 12.586 19 19", key: "ea5xo7" }],
  [
    "path",
    {
      d: "M3.688 3.037a.497.497 0 0 0-.651.651l6.5 15.999a.501.501 0 0 0 .947-.062l1.569-6.083a2 2 0 0 1 1.448-1.479l6.124-1.579a.5.5 0 0 0 .063-.947z",
      key: "277e5u"
    }
  ]
], MousePointer = createLucideIcon("mouse-pointer", __iconNode$5);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$4 = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], Plus = createLucideIcon("plus", __iconNode$4);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$3 = [
  [
    "path",
    {
      d: "M15.39 4.39a1 1 0 0 0 1.68-.474 2.5 2.5 0 1 1 3.014 3.015 1 1 0 0 0-.474 1.68l1.683 1.682a2.414 2.414 0 0 1 0 3.414L19.61 15.39a1 1 0 0 1-1.68-.474 2.5 2.5 0 1 0-3.014 3.015 1 1 0 0 1 .474 1.68l-1.683 1.682a2.414 2.414 0 0 1-3.414 0L8.61 19.61a1 1 0 0 0-1.68.474 2.5 2.5 0 1 1-3.014-3.015 1 1 0 0 0 .474-1.68l-1.683-1.682a2.414 2.414 0 0 1 0-3.414L4.39 8.61a1 1 0 0 1 1.68.474 2.5 2.5 0 1 0 3.014-3.015 1 1 0 0 1-.474-1.68l1.683-1.682a2.414 2.414 0 0 1 3.414 0z",
      key: "w46dr5"
    }
  ]
], Puzzle = createLucideIcon("puzzle", __iconNode$3);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$2 = [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], Settings = createLucideIcon("settings", __iconNode$2);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$1 = [
  [
    "path",
    {
      d: "M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z",
      key: "xwnzip"
    }
  ],
  ["path", { d: "M5 3a2 2 0 0 0-2 2", key: "y57alp" }],
  ["path", { d: "M19 3a2 2 0 0 1 2 2", key: "18rm91" }],
  ["path", { d: "M5 21a2 2 0 0 1-2-2", key: "sbafld" }],
  ["path", { d: "M9 3h1", key: "1yesri" }],
  ["path", { d: "M9 21h2", key: "1qve2z" }],
  ["path", { d: "M14 3h1", key: "1ec4yj" }],
  ["path", { d: "M3 9v1", key: "1r0deq" }],
  ["path", { d: "M21 9v2", key: "p14lih" }],
  ["path", { d: "M3 14v1", key: "vnatye" }]
], SquareDashedMousePointer = createLucideIcon("square-dashed-mouse-pointer", __iconNode$1);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], X = createLucideIcon("x", __iconNode);
function RegularContent() {
  const {
    isChatOpen,
    openChat,
    closeChat,
    openPluginName,
    closePlugin,
    openPlugin,
    isInfoOpen,
    openInfo,
    closeInfo
  } = usePanels(), { startPromptCreation, startContextSelector } = useChatState(), pluginsWithActions = usePlugins().plugins.filter(
    (plugin) => plugin.onActionClick
  );
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    pluginsWithActions.length > 0 && /* @__PURE__ */ jsx(ToolbarSection, { children: pluginsWithActions.map((plugin) => /* @__PURE__ */ jsx(
      ToolbarButton,
      {
        onClick: openPluginName === plugin.pluginName ? closePlugin : () => openPlugin(plugin.pluginName),
        active: openPluginName === plugin.pluginName,
        children: plugin.iconSvg ? /* @__PURE__ */ jsx("span", { className: "size-4 *:size-full", children: plugin.iconSvg }) : /* @__PURE__ */ jsx(Puzzle, { className: "size-4" })
      },
      plugin.pluginName
    )) }),
    /* @__PURE__ */ jsxs(ToolbarSection, { children: [
      /* @__PURE__ */ jsx(
        ToolbarButton,
        {
          onClick: isChatOpen ? closeChat : () => {
            openChat(), startPromptCreation(), startContextSelector();
          },
          active: isChatOpen,
          children: /* @__PURE__ */ jsx(MessageCircle, { className: "size-4" })
        }
      ),
      /* @__PURE__ */ jsx(
        ToolbarButton,
        {
          onClick: isInfoOpen ? closeInfo : openInfo,
          active: isInfoOpen,
          children: /* @__PURE__ */ jsx(Settings, { className: "size-4" })
        }
      )
    ] })
  ] });
}
const Logo = ({
  color = "default",
  loading = !1,
  loadingSpeed = "slow",
  ...props
}) => {
  const colorStyle = {
    default: "fill-stagewise-700 stroke-none",
    black: "fill-zinc-950 stroke-none",
    white: "fill-white stroke-none",
    zinc: "fill-zinc-500/50 stroke-none",
    current: "fill-current stroke-none",
    gradient: "fill-white stroke-black/30 stroke-1"
  };
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: `relative ${color === "gradient" ? "rounded-full bg-[image:var(--gradient)] bg-cover bg-no-repeat" : ""} ${props.className || ""} ${loading ? "drop-shadow-xl" : ""} aspect-square overflow-visible`,
      children: [
        /* @__PURE__ */ jsxs(
          "svg",
          {
            className: `absolute overflow-visible ${color === "gradient" ? "top-[25%] left-[25%] h-[50%] w-[50%]" : "top-0 left-0 h-full w-full"}`,
            viewBox: "0 0 2048 2048",
            children: [
              /* @__PURE__ */ jsx("title", { children: "stagewise" }),
              /* @__PURE__ */ jsx(
                "ellipse",
                {
                  className: colorStyle[color] + (loading ? " animate-pulse" : ""),
                  id: "path3",
                  ry: "624",
                  rx: "624",
                  cy: "1024",
                  cx: "1024"
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsx(
          "svg",
          {
            className: `absolute overflow-visible ${color === "gradient" ? "top-[25%] left-[25%] h-[50%] w-[50%]" : "top-0 left-0 h-full w-full"}`,
            viewBox: "0 0 2048 2048",
            children: /* @__PURE__ */ jsx(
              "path",
              {
                id: "path4",
                className: "origin-center " + colorStyle[color] + (loading ? loadingSpeed === "fast" ? " animate-spin-fast" : " animate-spin-slow" : ""),
                d: "M 1024 0 A 1024 1024 0 0 0 0 1024 A 1024 1024 0 0 0 1024 2048 L 1736 2048 L 1848 2048 C 1958.7998 2048 2048 1958.7998 2048 1848 L 2048 1736 L 2048 1024 A 1024 1024 0 0 0 1024 0 z M 1024.9414 200 A 824 824 0 0 1 1848.9414 1024 A 824 824 0 0 1 1024.9414 1848 A 824 824 0 0 1 200.94141 1024 A 824 824 0 0 1 1024.9414 200 z "
              }
            )
          }
        )
      ]
    }
  );
}, AnimatedGradientBackground = ({
  className
}) => /* @__PURE__ */ jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 800 800",
    preserveAspectRatio: "xMidYMid slice",
    className,
    children: [
      /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("filter", { id: "blur", x: "-50%", y: "-50%", width: "200%", height: "200%", children: /* @__PURE__ */ jsx("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "80" }) }) }),
      /* @__PURE__ */ jsx("rect", { width: "800", height: "800", fill: "#000f68" }),
      /* @__PURE__ */ jsxs("g", { filter: "url(#blur)", children: [
        /* @__PURE__ */ jsxs("circle", { cx: "100", cy: "400", r: "260", fill: "#1e90ff", children: [
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cx",
              dur: "15s",
              begin: "0s",
              values: "100; 700; 100",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          ),
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cy",
              dur: "20s",
              begin: "0.1s",
              values: "400; 100; 400",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          )
        ] }),
        /* @__PURE__ */ jsxs("circle", { cx: "700", cy: "100", r: "220", fill: "#c300ff", children: [
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cx",
              dur: "12s",
              begin: "0.2s",
              values: "700; 100; 700",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          ),
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cy",
              dur: "10s",
              begin: "0.3s",
              values: "100; 700; 100",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          )
        ] }),
        /* @__PURE__ */ jsxs("circle", { cx: "400", cy: "700", r: "240", fill: "#0055ff", children: [
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cx",
              dur: "18s",
              begin: "0.4s",
              values: "400; 500; 200; 400",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.33; 0.67; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          ),
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cy",
              dur: "22s",
              begin: "0.5s",
              values: "700; 400; 700",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          )
        ] })
      ] })
    ]
  }
);
function Toolbar({
  draggableHandleRef,
  position,
  isDragged
}) {
  const { minimized, minimize, expand } = useAppState(), { isInitialLoad } = useAgents();
  return /* @__PURE__ */ jsxs(
    Glassy,
    {
      as: "div",
      className: cn(
        "pointer-events-auto absolute z-10 origin-center rounded-full p-0.5 shadow-md transition-transform duration-500 ease-spring",
        minimized || isInitialLoad ? "size-10 bg-blue-950/80" : "size-auto",
        isDragged && "scale-110 bg-sky-100/60 shadow-lg shadow-sky-500/10 blur-[0.2px]",
        "[--active-secondary:var(--color-blue-100)] [--active:var(--color-blue-600)] [--primary:var(--color-zinc-950)] [--secondary:var(--color-zinc-400)]",
        "stroke-[var(--primary)] text-[var(--primary)]"
      ),
      ref: draggableHandleRef,
      children: [
        /* @__PURE__ */ jsxs(
          H$1,
          {
            onClick: () => expand(),
            className: cn(
              "absolute left-0 z-50 flex size-10 origin-center cursor-pointer items-center justify-center overflow-hidden rounded-full border border-zinc-500/20 transition-all duration-500 ease-spring hover:opacity-90",
              minimized || isInitialLoad ? "pointer-events-auto scale-100 opacity-100 blur-none" : "pointer-events-none scale-25 opacity-0 blur-md",
              position.isTopHalf ? "top-0" : "bottom-0"
            ),
            children: [
              /* @__PURE__ */ jsx(AnimatedGradientBackground, { className: "-z-10 absolute inset-0 size-full" }),
              /* @__PURE__ */ jsx(Logo, { color: "white", className: "mr-px mb-px size-1/2 shadow-2xs" })
            ]
          }
        ),
        /* @__PURE__ */ jsxs(
          "div",
          {
            className: cn(
              "flex h-[calc-size(auto,size)] scale-100 items-center justify-center divide-y divide-border/20 transition-all duration-500 ease-spring",
              position.isTopHalf ? "origin-top flex-col-reverse divide-y-reverse" : "origin-bottom flex-col",
              (minimized || isInitialLoad) && "pointer-events-none h-0 scale-50 opacity-0 blur-md"
            ),
            children: [
              /* @__PURE__ */ jsx(RegularContent, {}),
              /* @__PURE__ */ jsx(ToolbarSection, { children: /* @__PURE__ */ jsx(
                ToolbarButton,
                {
                  onClick: minimize,
                  className: cn(
                    "h-5",
                    position.isTopHalf ? "rounded-t-3xl rounded-b-lg" : "rounded-t-lg rounded-b-3xl"
                  ),
                  children: position.isTopHalf ? /* @__PURE__ */ jsx(ChevronUp, { className: "size-4" }) : /* @__PURE__ */ jsx(ChevronDown, { className: "size-4" })
                }
              ) })
            ]
          }
        )
      ]
    }
  );
}
const visuallyHidden = {
  clip: "rect(0 0 0 0)",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "fixed",
  top: 0,
  left: 0,
  border: 0,
  padding: 0,
  width: 1,
  height: 1,
  margin: -1
}, UNINITIALIZED = {};
function useRefWithInit(init, initArg) {
  const ref = React.useRef(UNINITIALIZED);
  return ref.current === UNINITIALIZED && (ref.current = init(initArg)), ref;
}
function useMergedRefs(a2, b, c2, d2) {
  const forkRef = useRefWithInit(createForkRef).current;
  return didChange(forkRef, a2, b, c2, d2) && update(forkRef, [a2, b, c2, d2]), forkRef.callback;
}
function useMergedRefsN(refs) {
  const forkRef = useRefWithInit(createForkRef).current;
  return didChangeN(forkRef, refs) && update(forkRef, refs), forkRef.callback;
}
function createForkRef() {
  return {
    callback: null,
    cleanup: null,
    refs: []
  };
}
function didChange(forkRef, a2, b, c2, d2) {
  return forkRef.refs[0] !== a2 || forkRef.refs[1] !== b || forkRef.refs[2] !== c2 || forkRef.refs[3] !== d2;
}
function didChangeN(forkRef, newRefs) {
  return forkRef.refs.length !== newRefs.length || forkRef.refs.some((ref, index2) => ref !== newRefs[index2]);
}
function update(forkRef, refs) {
  if (forkRef.refs = refs, refs.every((ref) => ref == null)) {
    forkRef.callback = null;
    return;
  }
  forkRef.callback = (instance) => {
    if (forkRef.cleanup && (forkRef.cleanup(), forkRef.cleanup = null), instance != null) {
      const cleanupCallbacks = Array(refs.length).fill(null);
      for (let i2 = 0; i2 < refs.length; i2 += 1) {
        const ref = refs[i2];
        if (ref != null)
          switch (typeof ref) {
            case "function": {
              const refCleanup = ref(instance);
              typeof refCleanup == "function" && (cleanupCallbacks[i2] = refCleanup);
              break;
            }
            case "object": {
              ref.current = instance;
              break;
            }
          }
      }
      forkRef.cleanup = () => {
        for (let i2 = 0; i2 < refs.length; i2 += 1) {
          const ref = refs[i2];
          if (ref != null)
            switch (typeof ref) {
              case "function": {
                const cleanupCallback = cleanupCallbacks[i2];
                typeof cleanupCallback == "function" ? cleanupCallback() : ref(null);
                break;
              }
              case "object": {
                ref.current = null;
                break;
              }
            }
        }
      };
    }
  };
}
function useOnFirstRender(fn) {
  const ref = React.useRef(!0);
  ref.current && (ref.current = !1, fn());
}
var define_process_env_default$G = {};
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = React.useRef(controlled !== void 0), [valueState, setValue] = React.useState(defaultProp), value = isControlled ? controlled : valueState;
  if (define_process_env_default$G.NODE_ENV !== "production") {
    React.useEffect(() => {
      isControlled !== (controlled !== void 0) && console.error([`Base UI: A component is changing the ${isControlled ? "" : "un"}controlled ${state} state of ${name} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${name} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [state, name, controlled]);
    const {
      current: defaultValue
    } = React.useRef(defaultProp);
    React.useEffect(() => {
      !isControlled && !Object.is(defaultValue, defaultProp) && console.error([`Base UI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. To suppress this warning opt to use a controlled ${name}.`].join(`
`));
    }, [JSON.stringify(defaultProp)]);
  }
  const setValueIfUncontrolled = React.useCallback((newValue) => {
    isControlled || setValue(newValue);
  }, []);
  return [value, setValueIfUncontrolled];
}
const noop2 = () => {
}, useIsoLayoutEffect = typeof document < "u" ? React.useLayoutEffect : noop2;
var define_process_env_default$F = {};
const useInsertionEffect = React[`useInsertionEffect${Math.random().toFixed(1)}`.slice(0, -3)], useSafeInsertionEffect = (
  // React 17 doesn't have useInsertionEffect.
  useInsertionEffect && // Preact replaces useInsertionEffect with useLayoutEffect and fires too late.
  useInsertionEffect !== React.useLayoutEffect ? useInsertionEffect : (fn) => fn()
);
function useEventCallback(callback) {
  const stable = useRefWithInit(createStableCallback).current;
  return stable.next = callback, useSafeInsertionEffect(stable.effect), stable.trampoline;
}
function createStableCallback() {
  const stable = {
    next: void 0,
    callback: assertNotCalled,
    trampoline: (...args) => {
      var _a;
      return (_a = stable.callback) == null ? void 0 : _a.call(stable, ...args);
    },
    effect: () => {
      stable.callback = stable.next;
    }
  };
  return stable;
}
function assertNotCalled() {
  if (define_process_env_default$F.NODE_ENV !== "production")
    throw new Error("Base UI: Cannot call an event handler while rendering.");
}
const EMPTY$2 = [];
function useOnMount(fn) {
  React.useEffect(fn, EMPTY$2);
}
const EMPTY$1 = 0;
class Timeout {
  constructor() {
    __publicField(this, "currentId", EMPTY$1);
    __publicField(this, "clear", () => {
      this.currentId !== EMPTY$1 && (clearTimeout(this.currentId), this.currentId = EMPTY$1);
    });
    __publicField(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = EMPTY$1, fn();
    }, delay);
  }
  isStarted() {
    return this.currentId !== EMPTY$1;
  }
}
function useTimeout() {
  const timeout = useRefWithInit(Timeout.create).current;
  return useOnMount(timeout.disposeEffect), timeout;
}
var define_process_env_default$E = {};
let set$1;
define_process_env_default$E.NODE_ENV !== "production" && (set$1 = /* @__PURE__ */ new Set());
function warn(...messages) {
  if (define_process_env_default$E.NODE_ENV !== "production") {
    const messageKey = messages.join(" ");
    set$1.has(messageKey) || (set$1.add(messageKey), console.warn(`Base UI: ${messageKey}`));
  }
}
function useLatestRef(value) {
  const latest2 = useRefWithInit(createLatestRef, value).current;
  return latest2.next = value, useIsoLayoutEffect(latest2.effect), latest2;
}
function createLatestRef(value) {
  const latest2 = {
    current: value,
    next: value,
    effect: () => {
      latest2.current = latest2.next;
    }
  };
  return latest2;
}
var define_process_env_default$D = {}, runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = !1;
    try {
      const emptyObject = {};
      resultFunc(emptyObject) === emptyObject && (isInputSameAsOutput = !0);
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack;
      try {
        throw new Error();
      } catch (e2) {
        ({ stack } = e2);
      }
      console.warn(
        `The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,
        { stack }
      );
    }
  }
}, runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {
  const { memoize, memoizeOptions } = options, { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject, createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);
  if (!(createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy))) {
    let stack;
    try {
      throw new Error();
    } catch (e2) {
      ({ stack } = e2);
    }
    console.warn(
      `An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
}, globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
}, NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func != "function")
    throw new TypeError(errorMessage);
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object != "object")
    throw new TypeError(errorMessage);
}
function assertIsArrayOfFunctions(array, errorMessage = "expected all items to be functions, instead received the following types: ") {
  if (!array.every((item) => typeof item == "function")) {
    const itemTypes = array.map(
      (item) => typeof item == "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => Array.isArray(item) ? item : [item];
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  return assertIsArrayOfFunctions(
    dependencies,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [], { length } = dependencies;
  for (let i2 = 0; i2 < length; i2++)
    inputSelectorResults.push(dependencies[i2].apply(null, inputSelectorArgs));
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
function createSingletonCache(equals) {
  let entry;
  return {
    get(key) {
      return entry && equals(entry.key, key) ? entry.value : NOT_FOUND;
    },
    put(key, value) {
      entry = { key, value };
    },
    getEntries() {
      return entry ? [entry] : [];
    },
    clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  let entries = [];
  function get2(key) {
    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));
    if (cacheIndex > -1) {
      const entry = entries[cacheIndex];
      return cacheIndex > 0 && (entries.splice(cacheIndex, 1), entries.unshift(entry)), entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    get2(key) === NOT_FOUND && (entries.unshift({ key, value }), entries.length > maxSize && entries.pop());
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return { get: get2, put, getEntries, clear };
}
var referenceEqualityCheck = (a2, b) => a2 === b;
function createCacheKeyComparator(equalityCheck) {
  return function(prev, next) {
    if (prev === null || next === null || prev.length !== next.length)
      return !1;
    const { length } = prev;
    for (let i2 = 0; i2 < length; i2++)
      if (!equalityCheck(prev[i2], next[i2]))
        return !1;
    return !0;
  };
}
function lruMemoize(func, equalityCheckOrOptions) {
  const providedOptions = typeof equalityCheckOrOptions == "object" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions }, {
    equalityCheck = referenceEqualityCheck,
    maxSize = 1,
    resultEqualityCheck
  } = providedOptions, comparator = createCacheKeyComparator(equalityCheck);
  let resultsCount = 0;
  const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    let value = cache.get(arguments);
    if (value === NOT_FOUND) {
      if (value = func.apply(null, arguments), resultsCount++, resultEqualityCheck) {
        const matchingEntry = cache.getEntries().find(
          (entry) => resultEqualityCheck(entry.value, value)
        );
        matchingEntry && (value = matchingEntry.value, resultsCount !== 0 && resultsCount--);
      }
      cache.put(arguments, value);
    }
    return value;
  }
  return memoized.clearCache = () => {
    cache.clear(), memoized.resetResultsCount();
  }, memoized.resultsCount = () => resultsCount, memoized.resetResultsCount = () => {
    resultsCount = 0;
  }, memoized;
}
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
}, Ref = typeof WeakRef < "u" ? WeakRef : StrongRef, UNTERMINATED = 0, TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult, resultsCount = 0;
  function memoized() {
    var _a;
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i2 = 0, l = length; i2 < l; i2++) {
      const arg = arguments[i2];
      if (typeof arg == "function" || typeof arg == "object" && arg !== null) {
        let objectCache = cacheNode.o;
        objectCache === null && (cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap());
        const objectNode = objectCache.get(arg);
        objectNode === void 0 ? (cacheNode = createCacheNode(), objectCache.set(arg, cacheNode)) : cacheNode = objectNode;
      } else {
        let primitiveCache = cacheNode.p;
        primitiveCache === null && (cacheNode.p = primitiveCache = /* @__PURE__ */ new Map());
        const primitiveNode = primitiveCache.get(arg);
        primitiveNode === void 0 ? (cacheNode = createCacheNode(), primitiveCache.set(arg, cacheNode)) : cacheNode = primitiveNode;
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED)
      result = cacheNode.v;
    else if (result = func.apply(null, arguments), resultsCount++, resultEqualityCheck) {
      const lastResultValue = ((_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) ?? lastResult;
      lastResultValue != null && resultEqualityCheck(lastResultValue, result) && (result = lastResultValue, resultsCount !== 0 && resultsCount--), lastResult = typeof result == "object" && result !== null || typeof result == "function" ? new Ref(result) : result;
    }
    return terminatedNode.s = TERMINATED, terminatedNode.v = result, result;
  }
  return memoized.clearCache = () => {
    fnNode = createCacheNode(), memoized.resetResultsCount();
  }, memoized.resultsCount = () => resultsCount, memoized.resetResultsCount = () => {
    resultsCount = 0;
  }, memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions == "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions, createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0, dependencyRecomputations = 0, lastResult, directlyPassedOptions = {}, resultFunc = createSelectorArgs.pop();
    typeof resultFunc == "object" && (directlyPassedOptions = resultFunc, resultFunc = createSelectorArgs.pop()), assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    }, {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions, finalMemoizeOptions = ensureIsArray(memoizeOptions), finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions), dependencies = getDependencies(createSelectorArgs), memoizedResultFunc = memoize(function() {
      return recomputations++, resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = !0;
    const selector = argsMemoize(function() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      if (lastResult = memoizedResultFunc.apply(null, inputSelectorResults), define_process_env_default$D.NODE_ENV !== "production") {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun && identityFunctionCheck.run(
          resultFunc,
          inputSelectorResults,
          lastResult
        ), inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        firstRun && (firstRun = !1);
      }
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  return Object.assign(createSelector2, {
    withTypes: () => createSelector2
  }), createSelector2;
}
var createSelector$1 = /* @__PURE__ */ createSelectorCreator(weakMapMemoize), createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector$1) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject), dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    return selectorCreator(
      dependencies,
      (...inputSelectorResults) => inputSelectorResults.reduce((composition, value, index2) => (composition[inputSelectorKeys[index2]] = value, composition), {})
    );
  },
  { withTypes: () => createStructuredSelector }
);
createSelectorCreator({
  memoize: lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  }
});
const createSelector = (a2, b, c2, d2, e2, f2, ...other) => {
  if (other.length > 0)
    throw new Error("Unsupported number of selectors");
  let selector;
  if (a2)
    selector = a2;
  else
    throw new Error("Missing arguments");
  return selector;
};
var withSelector = { exports: {} }, withSelector_production = {}, shim = { exports: {} }, useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = React__default;
  function is2(x, y2) {
    return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is2, useState2 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect2 = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState2({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    return useLayoutEffect2(
      function() {
        inst.value = value, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    ), useEffect2(
      function() {
        return checkIfSnapshotChanged(inst) && forceUpdate({ inst }), subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    ), useDebugValue(value), value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch {
      return !0;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? useSyncExternalStore$1 : useSyncExternalStore$2;
  return useSyncExternalStoreShim_production.useSyncExternalStore = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim2, useSyncExternalStoreShim_production;
}
var useSyncExternalStoreShim_development = {}, hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
  hasRequiredUseSyncExternalStoreShim_development = 1;
  var define_process_env_default2 = {};
  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return define_process_env_default2.NODE_ENV !== "production" && (function() {
    function is2(x, y2) {
      return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
      didWarnOld18Alpha || React2.startTransition === void 0 || (didWarnOld18Alpha = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var value = getSnapshot();
      if (!didWarnUncachedGetSnapshot) {
        var cachedValue = getSnapshot();
        objectIs(value, cachedValue) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), didWarnUncachedGetSnapshot = !0);
      }
      cachedValue = useState2({
        inst: { value, getSnapshot }
      });
      var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
      return useLayoutEffect2(
        function() {
          inst.value = value, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe, value, getSnapshot]
      ), useEffect2(
        function() {
          return checkIfSnapshotChanged(inst) && forceUpdate({ inst }), subscribe(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe]
      ), useDebugValue(value), value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch {
        return !0;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
      return getSnapshot();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React2 = React__default, objectIs = typeof Object.is == "function" ? Object.is : is2, useState2 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect2 = React2.useLayoutEffect, useDebugValue = React2.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim2 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? useSyncExternalStore$1 : useSyncExternalStore$2;
    useSyncExternalStoreShim_development.useSyncExternalStore = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim2, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })(), useSyncExternalStoreShim_development;
}
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  var define_process_env_default2 = {};
  return define_process_env_default2.NODE_ENV === "production" ? shim.exports = requireUseSyncExternalStoreShim_production() : shim.exports = requireUseSyncExternalStoreShim_development(), shim.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = React__default, shim2 = requireShim();
  function is2(x, y2) {
    return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is2, useSyncExternalStore2 = shim2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;
  return withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef2(null);
    if (instRef.current === null) {
      var inst = { hasValue: !1, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo2(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector(nextSnapshot), isEqual !== void 0 && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
        }
        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
    return useEffect2(
      function() {
        inst.hasValue = !0, inst.value = value;
      },
      [value]
    ), useDebugValue(value), value;
  }, withSelector_production;
}
var withSelector_development = {}, hasRequiredWithSelector_development;
function requireWithSelector_development() {
  if (hasRequiredWithSelector_development) return withSelector_development;
  hasRequiredWithSelector_development = 1;
  var define_process_env_default2 = {};
  /**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return define_process_env_default2.NODE_ENV !== "production" && (function() {
    function is2(x, y2) {
      return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React2 = React__default, shim2 = requireShim(), objectIs = typeof Object.is == "function" ? Object.is : is2, useSyncExternalStore2 = shim2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;
    withSelector_development.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef2(null);
      if (instRef.current === null) {
        var inst = { hasValue: !1, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo2(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector(nextSnapshot), isEqual !== void 0 && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot))
              return currentSelection;
            var nextSelection = selector(nextSnapshot);
            return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
          }
          var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual]
      );
      var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
      return useEffect2(
        function() {
          inst.hasValue = !0, inst.value = value;
        },
        [value]
      ), useDebugValue(value), value;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })(), withSelector_development;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  var define_process_env_default2 = {};
  return define_process_env_default2.NODE_ENV === "production" ? withSelector.exports = requireWithSelector_production() : withSelector.exports = requireWithSelector_development(), withSelector.exports;
}
var withSelectorExports = requireWithSelector();
function useStore(store, selector, a1, a2, a3) {
  const selectorWithArgs = (state) => selector(state, a1, a2, a3);
  return withSelectorExports.useSyncExternalStoreWithSelector(store.subscribe, store.getSnapshot, store.getSnapshot, selectorWithArgs);
}
class Store {
  constructor(state) {
    /**
     * Registers a listener that will be called whenever the store's state changes.
     *
     * @param fn The listener function to be called on state changes.
     * @returns A function to unsubscribe the listener.
     */
    __publicField(this, "subscribe", (fn) => (this.listeners.add(fn), () => {
      this.listeners.delete(fn);
    }));
    /**
     * Returns the current state of the store.
     */
    __publicField(this, "getSnapshot", () => this.state);
    /**
     * Updates the entire store's state and notifies all registered listeners.
     *
     * @param newState The new state to set for the store.
     */
    __publicField(this, "update", (newState) => {
      this.state !== newState && (this.state = newState, this.listeners.forEach((l) => l(newState)));
    });
    this.state = state, this.listeners = /* @__PURE__ */ new Set();
  }
  /**
   * Merges the provided changes into the current state and notifies listeners if there are changes.
   *
   * @param changes An object containing the changes to apply to the current state.
   */
  apply(changes) {
    for (const key in changes)
      if (!Object.is(this.state[key], changes[key])) {
        this.update({
          ...this.state,
          ...changes
        });
        return;
      }
  }
  /**
   * Sets a specific key in the store's state to a new value and notifies listeners if the value has changed.
   *
   * @param key The key in the store's state to update.
   * @param value The new value to set for the specified key.
   */
  set(key, value) {
    Object.is(this.state[key], value) || this.update({
      ...this.state,
      [key]: value
    });
  }
}
const hasNavigator = typeof navigator < "u", nav = getNavigatorData(), platform = getPlatform(), userAgent = getUserAgent(), isWebKit = typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter:none"), isIOS = (
  // iPads can claim to be MacIntel
  nav.platform === "MacIntel" && nav.maxTouchPoints > 1 ? !0 : /iP(hone|ad|od)|iOS/.test(nav.platform)
), isSafari = hasNavigator && /apple/i.test(navigator.vendor), isAndroid = hasNavigator && /android/i.test(platform) || /android/i.test(userAgent), isMac = hasNavigator && platform.toLowerCase().startsWith("mac") && !navigator.maxTouchPoints, isJSDOM = userAgent.includes("jsdom/");
function getNavigatorData() {
  if (!hasNavigator)
    return {
      platform: "",
      maxTouchPoints: -1
    };
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? {
    platform: uaData.platform,
    maxTouchPoints: navigator.maxTouchPoints
  } : {
    platform: navigator.platform ?? "",
    maxTouchPoints: navigator.maxTouchPoints ?? -1
  };
}
function getUserAgent() {
  if (!hasNavigator)
    return "";
  const uaData = navigator.userAgentData;
  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map(({
    brand,
    version
  }) => `${brand}/${version}`).join(" ") : navigator.userAgent;
}
function getPlatform() {
  if (!hasNavigator)
    return "";
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? uaData.platform : navigator.platform ?? "";
}
const FOCUSABLE_ATTRIBUTE = "data-base-ui-focusable", ACTIVE_KEY = "active", SELECTED_KEY = "selected", TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])", ARROW_LEFT = "ArrowLeft", ARROW_RIGHT = "ArrowRight", ARROW_UP = "ArrowUp", ARROW_DOWN = "ArrowDown";
function activeElement(doc) {
  var _a;
  let element = doc.activeElement;
  for (; ((_a = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a.activeElement) != null; )
    element = element.shadowRoot.activeElement;
  return element;
}
function contains(parent, child) {
  var _a;
  if (!parent || !child)
    return !1;
  const rootNode = (_a = child.getRootNode) == null ? void 0 : _a.call(child);
  if (parent.contains(child))
    return !0;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    for (; next; ) {
      if (parent === next)
        return !0;
      next = next.parentNode || next.host;
    }
  }
  return !1;
}
function getTarget(event) {
  return "composedPath" in event ? event.composedPath()[0] : event.target;
}
function isEventTargetWithin(event, node) {
  if (node == null)
    return !1;
  if ("composedPath" in event)
    return event.composedPath().includes(node);
  const eventAgain = event;
  return eventAgain.target != null && node.contains(eventAgain.target);
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function isTypeableCombobox(element) {
  return element ? element.getAttribute("role") === "combobox" && isTypeableElement(element) : !1;
}
function matchesFocusVisible(element) {
  if (!element || isJSDOM)
    return !0;
  try {
    return element.matches(":focus-visible");
  } catch {
    return !0;
  }
}
function getFloatingFocusElement(floatingElement) {
  return floatingElement ? floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(`[${FOCUSABLE_ATTRIBUTE}]`) || floatingElement : null;
}
function getNodeChildren(nodes, id, onlyOpenChildren = !0) {
  return nodes.filter((node) => {
    var _a;
    return node.parentId === id && (!onlyOpenChildren || ((_a = node.context) == null ? void 0 : _a.open));
  }).flatMap((child) => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);
}
function getNodeAncestors(nodes, id) {
  var _a;
  let allAncestors = [], currentParentId = (_a = nodes.find((node) => node.id === id)) == null ? void 0 : _a.parentId;
  for (; currentParentId; ) {
    const currentNode = nodes.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId, currentNode && (allAncestors = allAncestors.concat(currentNode));
  }
  return allAncestors;
}
function stopEvent(event) {
  event.preventDefault(), event.stopPropagation();
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isVirtualClick(event) {
  return event.mozInputSource === 0 && event.isTrusted ? !0 : isAndroid && event.pointerType ? event.type === "click" && event.buttons === 1 : event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  return isJSDOM ? !1 : !isAndroid && event.width === 0 && event.height === 0 || isAndroid && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333 for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  return strict || values.push("", void 0), values.includes(pointerType);
}
var define_process_env_default$C = {};
function isDifferentGridRow(index2, cols, prevRow) {
  return Math.floor(index2 / cols) !== prevRow;
}
function isIndexOutOfListBounds(listRef, index2) {
  return index2 < 0 || index2 >= listRef.current.length;
}
function getMinListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    disabledIndices
  });
}
function getMaxListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    decrement: !0,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledListIndex(listRef, {
  startingIndex = -1,
  decrement = !1,
  disabledIndices,
  amount = 1
} = {}) {
  let index2 = startingIndex;
  do
    index2 += decrement ? -amount : amount;
  while (index2 >= 0 && index2 <= listRef.current.length - 1 && isListIndexDisabled(listRef, index2, disabledIndices));
  return index2;
}
function getGridNavigatedIndex(listRef, {
  event,
  orientation,
  loop,
  rtl,
  cols,
  disabledIndices,
  minIndex,
  maxIndex,
  prevIndex,
  stopEvent: stop = !1
}) {
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    if (stop && stopEvent(event), prevIndex === -1)
      nextIndex = maxIndex;
    else if (nextIndex = findNonDisabledListIndex(listRef, {
      startingIndex: nextIndex,
      amount: cols,
      decrement: !0,
      disabledIndices
    }), loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
      const col = prevIndex % cols, maxCol = maxIndex % cols, offset2 = maxIndex - (maxCol - col);
      maxCol === col ? nextIndex = maxIndex : nextIndex = maxCol > col ? offset2 : offset2 - cols;
    }
    isIndexOutOfListBounds(listRef, nextIndex) && (nextIndex = prevIndex);
  }
  if (event.key === ARROW_DOWN && (stop && stopEvent(event), prevIndex === -1 ? nextIndex = minIndex : (nextIndex = findNonDisabledListIndex(listRef, {
    startingIndex: prevIndex,
    amount: cols,
    disabledIndices
  }), loop && prevIndex + cols > maxIndex && (nextIndex = findNonDisabledListIndex(listRef, {
    startingIndex: prevIndex % cols - cols,
    amount: cols,
    disabledIndices
  }))), isIndexOutOfListBounds(listRef, nextIndex) && (nextIndex = prevIndex)), orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) && (stop && stopEvent(event), prevIndex % cols !== cols - 1 ? (nextIndex = findNonDisabledListIndex(listRef, {
      startingIndex: prevIndex,
      disabledIndices
    }), loop && isDifferentGridRow(nextIndex, cols, prevRow) && (nextIndex = findNonDisabledListIndex(listRef, {
      startingIndex: prevIndex - prevIndex % cols - 1,
      disabledIndices
    }))) : loop && (nextIndex = findNonDisabledListIndex(listRef, {
      startingIndex: prevIndex - prevIndex % cols - 1,
      disabledIndices
    })), isDifferentGridRow(nextIndex, cols, prevRow) && (nextIndex = prevIndex)), event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) && (stop && stopEvent(event), prevIndex % cols !== 0 ? (nextIndex = findNonDisabledListIndex(listRef, {
      startingIndex: prevIndex,
      decrement: !0,
      disabledIndices
    }), loop && isDifferentGridRow(nextIndex, cols, prevRow) && (nextIndex = findNonDisabledListIndex(listRef, {
      startingIndex: prevIndex + (cols - prevIndex % cols),
      decrement: !0,
      disabledIndices
    }))) : loop && (nextIndex = findNonDisabledListIndex(listRef, {
      startingIndex: prevIndex + (cols - prevIndex % cols),
      decrement: !0,
      disabledIndices
    })), isDifferentGridRow(nextIndex, cols, prevRow) && (nextIndex = prevIndex));
    const lastRow = floor(maxIndex / cols) === prevRow;
    isIndexOutOfListBounds(listRef, nextIndex) && (loop && lastRow ? nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {
      startingIndex: prevIndex - prevIndex % cols - 1,
      disabledIndices
    }) : nextIndex = prevIndex);
  }
  return nextIndex;
}
function createGridCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  return sizes.forEach(({
    width,
    height
  }, index2) => {
    if (width > cols && define_process_env_default$C.NODE_ENV !== "production")
      throw new Error(`[Floating UI]: Invalid grid - item width at index ${index2} is greater than grid columns`);
    let itemPlaced = !1;
    for (dense && (startIndex = 0); !itemPlaced; ) {
      const targetCells = [];
      for (let i2 = 0; i2 < width; i2 += 1)
        for (let j = 0; j < height; j += 1)
          targetCells.push(startIndex + i2 + j * cols);
      startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null) ? (targetCells.forEach((cell) => {
        cellMap[cell] = index2;
      }), itemPlaced = !0) : startIndex += 1;
    }
  }), [...cellMap];
}
function getGridCellIndexOfCorner(index2, sizes, cellMap, cols, corner) {
  if (index2 === -1)
    return -1;
  const firstCellIndex = cellMap.indexOf(index2), sizeItem = sizes[index2];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      return sizeItem ? firstCellIndex + sizeItem.width - 1 : firstCellIndex;
    case "bl":
      return sizeItem ? firstCellIndex + (sizeItem.height - 1) * cols : firstCellIndex;
    case "br":
      return cellMap.lastIndexOf(index2);
    default:
      return -1;
  }
}
function getGridCellIndices(indices, cellMap) {
  return cellMap.flatMap((index2, cellIndex) => indices.includes(index2) ? [cellIndex] : []);
}
function isListIndexDisabled(listRef, index2, disabledIndices) {
  if (typeof disabledIndices == "function")
    return disabledIndices(index2);
  if (disabledIndices)
    return disabledIndices.includes(index2);
  const element = listRef.current[index2];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
const getTabbableOptions = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, dir) {
  const list = tabbable(container, getTabbableOptions()), len = list.length;
  if (len === 0)
    return;
  const active = activeElement(getDocument(container)), index2 = list.indexOf(active), nextIndex = index2 === -1 ? dir === 1 ? 0 : len - 1 : index2 + dir;
  return list[nextIndex];
}
function getNextTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;
}
function getPreviousTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget, relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  tabbable(container, getTabbableOptions()).forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "", element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  container.querySelectorAll("[data-tabindex]").forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex, tabindex ? element.setAttribute("tabindex", tabindex) : element.removeAttribute("tabindex");
  });
}
const SafeReact = {
  ...React
};
let globalId = 0;
function useGlobalId(idOverride, prefix = "mui") {
  const [defaultId, setDefaultId] = React.useState(idOverride), id = idOverride || defaultId;
  return React.useEffect(() => {
    defaultId == null && (globalId += 1, setDefaultId(`${prefix}-${globalId}`));
  }, [defaultId, prefix]), id;
}
const maybeReactUseId = SafeReact.useId;
function useId(idOverride, prefix) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride ?? (prefix ? `${prefix}-${reactId}` : reactId);
  }
  return useGlobalId(idOverride, prefix);
}
function createEventEmitter() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _a;
      (_a = map.get(event)) == null || _a.forEach((listener) => listener(data));
    },
    on(event, listener) {
      map.has(event) || map.set(event, /* @__PURE__ */ new Set()), map.get(event).add(listener);
    },
    off(event, listener) {
      var _a;
      (_a = map.get(event)) == null || _a.delete(listener);
    }
  };
}
var define_process_env_default$B = {};
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null);
define_process_env_default$B.NODE_ENV !== "production" && (FloatingNodeContext.displayName = "FloatingNodeContext");
const FloatingTreeContext = /* @__PURE__ */ React.createContext(null);
define_process_env_default$B.NODE_ENV !== "production" && (FloatingTreeContext.displayName = "FloatingTreeContext");
const useFloatingParentNodeId = () => {
  var _a;
  return ((_a = React.useContext(FloatingNodeContext)) == null ? void 0 : _a.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext);
function createAttribute(name) {
  return `data-base-ui-${name}`;
}
const safePolygonIdentifier = createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType))
    return 0;
  if (typeof value == "number")
    return value;
  if (typeof value == "function") {
    const result = value();
    return typeof result == "number" ? result : result == null ? void 0 : result[prop];
  }
  return value == null ? void 0 : value[prop];
}
function getRestMs(value) {
  return typeof value == "function" ? value() : value;
}
function useHover(context, props = {}) {
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context, {
    enabled = !0,
    delay = 0,
    handleClose = null,
    mouseOnly = !1,
    restMs = 0,
    move = !0
  } = props, tree = useFloatingTree(), parentId = useFloatingParentNodeId(), handleCloseRef = useLatestRef(handleClose), delayRef = useLatestRef(delay), openRef = useLatestRef(open), restMsRef = useLatestRef(restMs), pointerTypeRef = React.useRef(void 0), timeout = useTimeout(), handlerRef = React.useRef(void 0), restTimeout = useTimeout(), blockMouseMoveRef = React.useRef(!0), performedPointerEventsMutationRef = React.useRef(!1), unbindMouseMoveRef = React.useRef(() => {
  }), restTimeoutPendingRef = React.useRef(!1), isHoverOpen = useEventCallback(() => {
    var _a;
    const type = (_a = dataRef.current.openEvent) == null ? void 0 : _a.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  });
  React.useEffect(() => {
    if (!enabled)
      return;
    function onOpenChangeLocal({
      open: newOpen
    }) {
      newOpen || (timeout.clear(), restTimeout.clear(), blockMouseMoveRef.current = !0, restTimeoutPendingRef.current = !1);
    }
    return events.on("openchange", onOpenChangeLocal), () => {
      events.off("openchange", onOpenChangeLocal);
    };
  }, [enabled, events, timeout, restTimeout]), React.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open)
      return;
    function onLeave(event) {
      isHoverOpen() && onOpenChange(!1, event, "hover");
    }
    const html = getDocument(elements.floating).documentElement;
    return html.addEventListener("mouseleave", onLeave), () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React.useCallback((event, runElseBranch = !0, reason = "hover") => {
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    closeDelay && !handlerRef.current ? timeout.start(closeDelay, () => onOpenChange(!1, event, reason)) : runElseBranch && (timeout.clear(), onOpenChange(!1, event, reason));
  }, [delayRef, onOpenChange, timeout]), cleanupMouseMoveHandler = useEventCallback(() => {
    unbindMouseMoveRef.current(), handlerRef.current = void 0;
  }), clearPointerEvents = useEventCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "", body.removeAttribute(safePolygonIdentifier), performedPointerEventsMutationRef.current = !1;
    }
  }), isClickLikeOpenEvent = useEventCallback(() => dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : !1);
  React.useEffect(() => {
    if (!enabled)
      return;
    function onReferenceMouseEnter(event) {
      if (timeout.clear(), blockMouseMoveRef.current = !1, mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open"))
        return;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      openDelay ? timeout.start(openDelay, () => {
        openRef.current || onOpenChange(!0, event, "hover");
      }) : open || onOpenChange(!0, event, "hover");
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      if (restTimeout.clear(), restTimeoutPendingRef.current = !1, handleCloseRef.current && dataRef.current.floatingContext) {
        open || timeout.clear(), handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event, !0, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler), unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      (pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : !0) && closeWithDelay(event);
    }
    function onScrollMouseLeave(event) {
      var _a;
      isClickLikeOpenEvent() || dataRef.current.floatingContext && ((_a = handleCloseRef.current) == null || _a.call(handleCloseRef, {
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event);
        }
      })(event));
    }
    function onFloatingMouseEnter() {
      timeout.clear();
    }
    function onFloatingMouseLeave(event) {
      isClickLikeOpenEvent() || closeWithDelay(event, !1);
    }
    if (isElement(elements.domReference)) {
      const reference2 = elements.domReference, floating = elements.floating;
      return open && reference2.addEventListener("mouseleave", onScrollMouseLeave), move && reference2.addEventListener("mousemove", onReferenceMouseEnter, {
        once: !0
      }), reference2.addEventListener("mouseenter", onReferenceMouseEnter), reference2.addEventListener("mouseleave", onReferenceMouseLeave), floating && (floating.addEventListener("mouseleave", onScrollMouseLeave), floating.addEventListener("mouseenter", onFloatingMouseEnter), floating.addEventListener("mouseleave", onFloatingMouseLeave)), () => {
        open && reference2.removeEventListener("mouseleave", onScrollMouseLeave), move && reference2.removeEventListener("mousemove", onReferenceMouseEnter), reference2.removeEventListener("mouseenter", onReferenceMouseEnter), reference2.removeEventListener("mouseleave", onReferenceMouseLeave), floating && (floating.removeEventListener("mouseleave", onScrollMouseLeave), floating.removeEventListener("mouseenter", onFloatingMouseEnter), floating.removeEventListener("mouseleave", onFloatingMouseLeave));
      };
    }
  }, [elements, enabled, context, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef, timeout, restTimeout]), useIsoLayoutEffect(() => {
    var _a, _b, _c, _d;
    if (enabled && open && (_b = (_a = handleCloseRef.current) == null ? void 0 : _a.__options) != null && _b.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = !0;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference, parentFloating = (_d = (_c = tree == null ? void 0 : tree.nodesRef.current.find((node) => node.id === parentId)) == null ? void 0 : _c.context) == null ? void 0 : _d.elements.floating;
        return parentFloating && (parentFloating.style.pointerEvents = ""), body.style.pointerEvents = "none", ref.style.pointerEvents = "auto", floatingEl.style.pointerEvents = "auto", () => {
          body.style.pointerEvents = "", ref.style.pointerEvents = "", floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]), useIsoLayoutEffect(() => {
    open || (pointerTypeRef.current = void 0, restTimeoutPendingRef.current = !1, cleanupMouseMoveHandler(), clearPointerEvents());
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]), React.useEffect(() => () => {
    cleanupMouseMoveHandler(), timeout.clear(), restTimeout.clear(), clearPointerEvents();
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents, timeout, restTimeout]);
  const reference = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          !blockMouseMoveRef.current && !openRef.current && onOpenChange(!0, nativeEvent, "hover");
        }
        mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || open || getRestMs(restMsRef.current) === 0 || restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2 || (restTimeout.clear(), pointerTypeRef.current === "touch" ? handleMouseMove() : (restTimeoutPendingRef.current = !0, restTimeout.start(getRestMs(restMsRef.current), handleMouseMove)));
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMsRef, restTimeout]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
var define_process_env_default$A = {};
const FloatingDelayGroupContext = /* @__PURE__ */ React.createContext({
  hasProvider: !1,
  timeoutMs: 0,
  delayRef: {
    current: 0
  },
  initialDelayRef: {
    current: 0
  },
  timeout: new Timeout(),
  currentIdRef: {
    current: null
  },
  currentContextRef: {
    current: null
  }
});
define_process_env_default$A.NODE_ENV !== "production" && (FloatingDelayGroupContext.displayName = "FloatingDelayGroupContext");
function useDelayGroup(context, options = {}) {
  const {
    open,
    onOpenChange,
    floatingId
  } = context, {
    enabled = !0
  } = options, groupContext = React.useContext(FloatingDelayGroupContext), {
    currentIdRef,
    delayRef,
    timeoutMs,
    initialDelayRef,
    currentContextRef,
    hasProvider,
    timeout
  } = groupContext, [isInstantPhase, setIsInstantPhase] = React.useState(!1);
  return useIsoLayoutEffect(() => {
    function unset() {
      var _a;
      setIsInstantPhase(!1), (_a = currentContextRef.current) == null || _a.setIsInstantPhase(!1), currentIdRef.current = null, currentContextRef.current = null, delayRef.current = initialDelayRef.current;
    }
    if (enabled && currentIdRef.current && !open && currentIdRef.current === floatingId) {
      if (setIsInstantPhase(!1), timeoutMs)
        return timeout.start(timeoutMs, unset), () => {
          timeout.clear();
        };
      unset();
    }
  }, [enabled, open, floatingId, currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, timeout]), useIsoLayoutEffect(() => {
    if (!enabled || !open)
      return;
    const prevContext = currentContextRef.current, prevId = currentIdRef.current;
    currentContextRef.current = {
      onOpenChange,
      setIsInstantPhase
    }, currentIdRef.current = floatingId, delayRef.current = {
      open: 0,
      close: getDelay(initialDelayRef.current, "close")
    }, prevId !== null && prevId !== floatingId ? (timeout.clear(), setIsInstantPhase(!0), prevContext == null || prevContext.setIsInstantPhase(!0), prevContext == null || prevContext.onOpenChange(!1)) : (setIsInstantPhase(!1), prevContext == null || prevContext.setIsInstantPhase(!1));
  }, [enabled, open, floatingId, onOpenChange, currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, timeout]), useIsoLayoutEffect(() => () => {
    currentContextRef.current = null;
  }, [currentContextRef]), React.useMemo(() => ({
    hasProvider,
    delayRef,
    isInstantPhase
  }), [hasProvider, delayRef, isInstantPhase]);
}
var define_process_env_default$z = {};
const FocusGuard = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  const [role, setRole] = React.useState();
  return useIsoLayoutEffect(() => {
    isSafari && setRole("button");
  }, []), /* @__PURE__ */ jsx("span", {
    ...props,
    ...{
      ref,
      tabIndex: 0,
      // Role is only for VoiceOver
      role,
      "aria-hidden": role ? void 0 : !0,
      style: visuallyHidden
    },
    "data-base-ui-focus-guard": ""
  });
});
define_process_env_default$z.NODE_ENV !== "production" && (FocusGuard.displayName = "FocusGuard");
let rafId = 0;
function enqueueFocus(el, options = {}) {
  const {
    preventScroll = !1,
    cancelPrevious = !0,
    sync = !1
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  sync ? exec() : rafId = requestAnimationFrame(exec);
}
const counters = {
  inert: /* @__PURE__ */ new WeakMap(),
  "aria-hidden": /* @__PURE__ */ new WeakMap(),
  none: /* @__PURE__ */ new WeakMap()
};
function getCounterMap(control) {
  return control === "inert" ? counters.inert : control === "aria-hidden" ? counters["aria-hidden"] : counters.none;
}
let uncontrolledElementsSet = /* @__PURE__ */ new WeakSet(), markerMap = {}, lockCount = 0;
const unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode)), correctElements = (parent, targets) => targets.map((target) => {
  if (parent.contains(target))
    return target;
  const correctedTarget = unwrapHost(target);
  return parent.contains(correctedTarget) ? correctedTarget : null;
}).filter((x) => x != null);
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-base-ui-inert", controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null, avoidElements = correctElements(body, uncorrectedAvoidElements), elementsToKeep = /* @__PURE__ */ new Set(), elementsToStop = new Set(avoidElements), hiddenElements = [];
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep), deep(body), elementsToKeep.clear();
  function keep(el) {
    !el || elementsToKeep.has(el) || (elementsToKeep.add(el), el.parentNode && keep(el.parentNode));
  }
  function deep(parent) {
    !parent || elementsToStop.has(parent) || [].forEach.call(parent.children, (node) => {
      if (getNodeName(node) !== "script")
        if (elementsToKeep.has(node))
          deep(node);
        else {
          const attr2 = controlAttribute ? node.getAttribute(controlAttribute) : null, alreadyHidden = attr2 !== null && attr2 !== "false", counterMap = getCounterMap(controlAttribute), counterValue = (counterMap.get(node) || 0) + 1, markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue), markerCounter.set(node, markerValue), hiddenElements.push(node), counterValue === 1 && alreadyHidden && uncontrolledElementsSet.add(node), markerValue === 1 && node.setAttribute(markerName, ""), !alreadyHidden && controlAttribute && node.setAttribute(controlAttribute, controlAttribute === "inert" ? "" : "true");
        }
    });
  }
  return lockCount += 1, () => {
    hiddenElements.forEach((element) => {
      const counterMap = getCounterMap(controlAttribute), counterValue = (counterMap.get(element) || 0) - 1, markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue), markerCounter.set(element, markerValue), counterValue || (!uncontrolledElementsSet.has(element) && controlAttribute && element.removeAttribute(controlAttribute), uncontrolledElementsSet.delete(element)), markerValue || element.removeAttribute(markerName);
    }), lockCount -= 1, lockCount || (counters.inert = /* @__PURE__ */ new WeakMap(), counters["aria-hidden"] = /* @__PURE__ */ new WeakMap(), counters.none = /* @__PURE__ */ new WeakMap(), uncontrolledElementsSet = /* @__PURE__ */ new WeakSet(), markerMap = {});
  };
}
function markOthers(avoidElements, ariaHidden = !1, inert = !1) {
  const body = getDocument(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll("[aria-live]"))), body, ariaHidden, inert);
}
var define_process_env_default$y = {};
const PortalContext = /* @__PURE__ */ React.createContext(null);
define_process_env_default$y.NODE_ENV !== "production" && (PortalContext.displayName = "PortalContext");
const usePortalContext = () => React.useContext(PortalContext), attr = createAttribute("portal");
function useFloatingPortalNode(props = {}) {
  const {
    id,
    root
  } = props, uniqueId = useId(), portalContext = usePortalContext(), [portalNode, setPortalNode] = React.useState(null), portalNodeRef = React.useRef(null);
  return useIsoLayoutEffect(() => () => {
    portalNode == null || portalNode.remove(), queueMicrotask(() => {
      portalNodeRef.current = null;
    });
  }, [portalNode]), useIsoLayoutEffect(() => {
    if (!uniqueId || portalNodeRef.current)
      return;
    const existingIdRoot = id ? document.getElementById(id) : null;
    if (!existingIdRoot)
      return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId, subRoot.setAttribute(attr, ""), existingIdRoot.appendChild(subRoot), portalNodeRef.current = subRoot, setPortalNode(subRoot);
  }, [id, uniqueId]), useIsoLayoutEffect(() => {
    if (root === null || !uniqueId || portalNodeRef.current)
      return;
    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
    container && !isNode(container) && (container = container.current), container = container || document.body;
    let idWrapper = null;
    id && (idWrapper = document.createElement("div"), idWrapper.id = id, container.appendChild(idWrapper));
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId, subRoot.setAttribute(attr, ""), container = idWrapper || container, container.appendChild(subRoot), portalNodeRef.current = subRoot, setPortalNode(subRoot);
  }, [id, root, uniqueId, portalContext]), portalNode;
}
function FloatingPortal(props) {
  const {
    children,
    id,
    root,
    preserveTabOrder = !0
  } = props, portalNode = useFloatingPortalNode({
    id,
    root
  }), [focusManagerState, setFocusManagerState] = React.useState(null), beforeOutsideRef = React.useRef(null), afterOutsideRef = React.useRef(null), beforeInsideRef = React.useRef(null), afterInsideRef = React.useRef(null), modal = focusManagerState == null ? void 0 : focusManagerState.modal, open = focusManagerState == null ? void 0 : focusManagerState.open, shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root || portalNode)
  );
  return React.useEffect(() => {
    if (!portalNode || !preserveTabOrder || modal)
      return;
    function onFocus(event) {
      portalNode && isOutsideEvent(event) && (event.type === "focusin" ? enableFocusInside : disableFocusInside)(portalNode);
    }
    return portalNode.addEventListener("focusin", onFocus, !0), portalNode.addEventListener("focusout", onFocus, !0), () => {
      portalNode.removeEventListener("focusin", onFocus, !0), portalNode.removeEventListener("focusout", onFocus, !0);
    };
  }, [portalNode, preserveTabOrder, modal]), React.useEffect(() => {
    portalNode && (open || enableFocusInside(portalNode));
  }, [open, portalNode]), /* @__PURE__ */ jsxs(PortalContext.Provider, {
    value: React.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode]),
    children: [shouldRenderGuards && portalNode && /* @__PURE__ */ jsx(FocusGuard, {
      "data-type": "outside",
      ref: beforeOutsideRef,
      onFocus: (event) => {
        var _a;
        if (isOutsideEvent(event, portalNode))
          (_a = beforeInsideRef.current) == null || _a.focus();
        else {
          const domReference = focusManagerState ? focusManagerState.domReference : null, prevTabbable = getPreviousTabbable(domReference);
          prevTabbable == null || prevTabbable.focus();
        }
      }
    }), shouldRenderGuards && portalNode && /* @__PURE__ */ jsx("span", {
      "aria-owns": portalNode.id,
      style: visuallyHidden
    }), portalNode && /* @__PURE__ */ ReactDOM.createPortal(children, portalNode), shouldRenderGuards && portalNode && /* @__PURE__ */ jsx(FocusGuard, {
      "data-type": "outside",
      ref: afterOutsideRef,
      onFocus: (event) => {
        var _a;
        if (isOutsideEvent(event, portalNode))
          (_a = afterInsideRef.current) == null || _a.focus();
        else {
          const domReference = focusManagerState ? focusManagerState.domReference : null, nextTabbable = getNextTabbable(domReference);
          nextTabbable == null || nextTabbable.focus(), focusManagerState != null && focusManagerState.closeOnFocusOut && (focusManagerState == null || focusManagerState.onOpenChange(!1, event.nativeEvent, "focus-out"));
        }
      }
    })]
  });
}
const DISABLED_TRANSITIONS_STYLE = {
  style: {
    transition: "none"
  }
}, EMPTY_OBJECT = {}, EMPTY_ARRAY = [], CLICK_TRIGGER_IDENTIFIER = "data-base-ui-click-trigger", DROPDOWN_COLLISION_AVOIDANCE = {
  fallbackAxisSide: "none"
}, POPUP_COLLISION_AVOIDANCE = {
  fallbackAxisSide: "end"
}, LIST_LIMIT = 20;
let previouslyFocusedElements = [];
function clearDisconnectedPreviouslyFocusedElements() {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
}
function addPreviouslyFocusedElement(element) {
  clearDisconnectedPreviouslyFocusedElements(), element && getNodeName(element) !== "body" && (previouslyFocusedElements.push(element), previouslyFocusedElements.length > LIST_LIMIT && (previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT)));
}
function getPreviouslyFocusedElement() {
  return clearDisconnectedPreviouslyFocusedElements(), previouslyFocusedElements[previouslyFocusedElements.length - 1];
}
function getFirstTabbableElement(container) {
  const tabbableOptions = getTabbableOptions();
  return isTabbable(container, tabbableOptions) ? container : tabbable(container, tabbableOptions)[0] || container;
}
function handleTabIndex(floatingFocusElement, orderRef) {
  var _a;
  if (!orderRef.current.includes("floating") && !((_a = floatingFocusElement.getAttribute("role")) != null && _a.includes("dialog")))
    return;
  const options = getTabbableOptions(), tabbableContent = focusable(floatingFocusElement, options).filter((element) => {
    const dataTabIndex = element.getAttribute("data-tabindex") || "";
    return isTabbable(element, options) || element.hasAttribute("data-tabindex") && !dataTabIndex.startsWith("-");
  }), tabIndex = floatingFocusElement.getAttribute("tabindex");
  orderRef.current.includes("floating") || tabbableContent.length === 0 ? tabIndex !== "0" && floatingFocusElement.setAttribute("tabindex", "0") : (tabIndex !== "-1" || floatingFocusElement.hasAttribute("data-tabindex") && floatingFocusElement.getAttribute("data-tabindex") !== "-1") && (floatingFocusElement.setAttribute("tabindex", "-1"), floatingFocusElement.setAttribute("data-tabindex", "-1"));
}
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = !1,
    order = ["content"],
    initialFocus = 0,
    returnFocus = !0,
    restoreFocus = !1,
    modal = !0,
    closeOnFocusOut = !0,
    getInsideElements: getInsideElementsProp = () => []
  } = props, {
    open,
    onOpenChange,
    events,
    dataRef,
    elements: {
      domReference,
      floating
    }
  } = context, getNodeId = useEventCallback(() => {
    var _a;
    return (_a = dataRef.current.floatingContext) == null ? void 0 : _a.nodeId;
  }), getInsideElements = useEventCallback(getInsideElementsProp), ignoreInitialFocus = typeof initialFocus == "number" && initialFocus < 0, isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus, orderRef = useLatestRef(order), initialFocusRef = useLatestRef(initialFocus), returnFocusRef = useLatestRef(returnFocus), tree = useFloatingTree(), portalContext = usePortalContext(), startDismissButtonRef = React.useRef(null), endDismissButtonRef = React.useRef(null), preventReturnFocusRef = React.useRef(!1), isPointerDownRef = React.useRef(!1), tabbableIndexRef = React.useRef(-1), blurTimeout = useTimeout(), isInsidePortal = portalContext != null, floatingFocusElement = getFloatingFocusElement(floating), getTabbableContent = useEventCallback((container = floatingFocusElement) => container ? tabbable(container, getTabbableOptions()) : []), getTabbableElements = useEventCallback((container) => {
    const content = getTabbableContent(container);
    return orderRef.current.map(() => content).filter(Boolean).flat();
  });
  React.useEffect(() => {
    if (disabled || !modal)
      return;
    function onKeyDown(event) {
      event.key === "Tab" && contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox && stopEvent(event);
    }
    const doc = getDocument(floatingFocusElement);
    return doc.addEventListener("keydown", onKeyDown), () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]), React.useEffect(() => {
    if (disabled || !floating)
      return;
    function handleFocusIn(event) {
      const target = getTarget(event), tabbableIndex = getTabbableContent().indexOf(target);
      tabbableIndex !== -1 && (tabbableIndexRef.current = tabbableIndex);
    }
    return floating.addEventListener("focusin", handleFocusIn), () => {
      floating.removeEventListener("focusin", handleFocusIn);
    };
  }, [disabled, floating, getTabbableContent]), React.useEffect(() => {
    if (disabled || !closeOnFocusOut)
      return;
    function handlePointerDown() {
      isPointerDownRef.current = !0;
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget, currentTarget = event.currentTarget, target = getTarget(event);
      queueMicrotask(() => {
        const nodeId = getNodeId(), movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getNodeChildren(tree.nodesRef.current, nodeId).find((node) => {
          var _a, _b;
          return contains((_a = node.context) == null ? void 0 : _a.elements.floating, relatedTarget) || contains((_b = node.context) == null ? void 0 : _b.elements.domReference, relatedTarget);
        }) || getNodeAncestors(tree.nodesRef.current, nodeId).find((node) => {
          var _a, _b, _c;
          return [(_a = node.context) == null ? void 0 : _a.elements.floating, getFloatingFocusElement((_b = node.context) == null ? void 0 : _b.elements.floating)].includes(relatedTarget) || ((_c = node.context) == null ? void 0 : _c.elements.domReference) === relatedTarget;
        })));
        if (currentTarget === domReference && floatingFocusElement && handleTabIndex(floatingFocusElement, orderRef), restoreFocus && currentTarget !== domReference && !(target != null && target.isConnected) && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {
          isHTMLElement(floatingFocusElement) && floatingFocusElement.focus();
          const prevTabbableIndex = tabbableIndexRef.current, tabbableContent = getTabbableContent(), nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;
          isHTMLElement(nodeToFocus) && nodeToFocus.focus();
        }
        if (dataRef.current.insideReactTree) {
          dataRef.current.insideReactTree = !1;
          return;
        }
        if (isPointerDownRef.current) {
          isPointerDownRef.current = !1;
          return;
        }
        (isUntrappedTypeableCombobox || !modal) && relatedTarget && movedToUnrelatedNode && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== getPreviouslyFocusedElement() && (preventReturnFocusRef.current = !0, onOpenChange(!1, event, "focus-out"));
      });
    }
    const shouldHandleBlurCapture = !!(!tree && portalContext);
    function markInsideReactTree() {
      dataRef.current.insideReactTree = !0, blurTimeout.start(0, () => {
        dataRef.current.insideReactTree = !1;
      });
    }
    if (floating && isHTMLElement(domReference))
      return domReference.addEventListener("focusout", handleFocusOutside), domReference.addEventListener("pointerdown", handlePointerDown), floating.addEventListener("focusout", handleFocusOutside), shouldHandleBlurCapture && floating.addEventListener("focusout", markInsideReactTree, !0), () => {
        domReference.removeEventListener("focusout", handleFocusOutside), domReference.removeEventListener("pointerdown", handlePointerDown), floating.removeEventListener("focusout", handleFocusOutside), shouldHandleBlurCapture && floating.removeEventListener("focusout", markInsideReactTree, !0);
      };
  }, [disabled, domReference, floating, floatingFocusElement, modal, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox, getNodeId, orderRef, dataRef, blurTimeout]);
  const beforeGuardRef = React.useRef(null), afterGuardRef = React.useRef(null), mergedBeforeGuardRef = useMergedRefs(beforeGuardRef, portalContext == null ? void 0 : portalContext.beforeInsideRef), mergedAfterGuardRef = useMergedRefs(afterGuardRef, portalContext == null ? void 0 : portalContext.afterInsideRef);
  React.useEffect(() => {
    var _a, _b, _c;
    if (disabled || !floating)
      return;
    const portalNodes = Array.from(((_a = portalContext == null ? void 0 : portalContext.portalNode) == null ? void 0 : _a.querySelectorAll(`[${createAttribute("portal")}]`)) || []), rootAncestorComboboxDomReference = (_c = (_b = (tree ? getNodeAncestors(tree.nodesRef.current, getNodeId()) : []).find((node) => {
      var _a2;
      return isTypeableCombobox(((_a2 = node.context) == null ? void 0 : _a2.elements.domReference) || null);
    })) == null ? void 0 : _b.context) == null ? void 0 : _c.elements.domReference, insideElements = [floating, rootAncestorComboboxDomReference, ...portalNodes, ...getInsideElements(), startDismissButtonRef.current, endDismissButtonRef.current, beforeGuardRef.current, afterGuardRef.current, portalContext == null ? void 0 : portalContext.beforeOutsideRef.current, portalContext == null ? void 0 : portalContext.afterOutsideRef.current, isUntrappedTypeableCombobox ? domReference : null].filter((x) => x != null), cleanup = markOthers(insideElements, modal || isUntrappedTypeableCombobox);
    return () => {
      cleanup();
    };
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, tree, getNodeId, getInsideElements]), useIsoLayoutEffect(() => {
    if (disabled || !isHTMLElement(floatingFocusElement))
      return;
    const doc = getDocument(floatingFocusElement), previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floatingFocusElement), initialFocusValue = initialFocusRef.current, elToFocus = (typeof initialFocusValue == "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement, focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);
      !ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open && enqueueFocus(elToFocus, {
        preventScroll: elToFocus === floatingFocusElement
      });
    });
  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]), useIsoLayoutEffect(() => {
    if (disabled || !floatingFocusElement)
      return;
    const doc = getDocument(floatingFocusElement), previouslyFocusedElement = activeElement(doc);
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChangeLocal({
      reason,
      event,
      nested
    }) {
      if (["hover", "safe-polygon"].includes(reason) && event.type === "mouseleave" && (preventReturnFocusRef.current = !0), reason === "outside-press")
        if (nested)
          preventReturnFocusRef.current = !1;
        else if (isVirtualClick(event) || isVirtualPointerEvent(event))
          preventReturnFocusRef.current = !1;
        else {
          let isPreventScrollSupported = !1;
          document.createElement("div").focus({
            get preventScroll() {
              return isPreventScrollSupported = !0, !1;
            }
          }), isPreventScrollSupported ? preventReturnFocusRef.current = !1 : preventReturnFocusRef.current = !0;
        }
    }
    events.on("openchange", onOpenChangeLocal);
    const fallbackEl = doc.createElement("span");
    fallbackEl.setAttribute("tabindex", "-1"), fallbackEl.setAttribute("aria-hidden", "true"), Object.assign(fallbackEl.style, visuallyHidden), isInsidePortal && domReference && domReference.insertAdjacentElement("afterend", fallbackEl);
    function getReturnElement() {
      if (typeof returnFocusRef.current == "boolean") {
        const el = domReference || getPreviouslyFocusedElement();
        return el && el.isConnected ? el : fallbackEl;
      }
      return returnFocusRef.current.current || fallbackEl;
    }
    return () => {
      events.off("openchange", onOpenChangeLocal);
      const activeEl = activeElement(doc), isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getNodeChildren(tree.nodesRef.current, getNodeId(), !1).some((node) => {
        var _a;
        return contains((_a = node.context) == null ? void 0 : _a.elements.floating, activeEl);
      }), returnElement = getReturnElement();
      queueMicrotask(() => {
        const tabbableReturnElement = getFirstTabbableElement(returnElement);
        // eslint-disable-next-line react-hooks/exhaustive-deps
        returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(tabbableReturnElement) && // If the focus moved somewhere else after mount, avoid returning focus
        // since it likely entered a different element which should be
        // respected: https://github.com/floating-ui/floating-ui/issues/2607
        (!(tabbableReturnElement !== activeEl && activeEl !== doc.body) || isFocusInsideFloatingTree) && tabbableReturnElement.focus({
          preventScroll: !0
        }), fallbackEl.remove();
      });
    };
  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, events, tree, isInsidePortal, domReference, getNodeId]), React.useEffect(() => {
    queueMicrotask(() => {
      preventReturnFocusRef.current = !1;
    });
  }, [disabled]), React.useEffect(() => {
    if (disabled || !open)
      return;
    function handlePointerDown(event) {
      const target = getTarget(event);
      target != null && target.closest(`[${CLICK_TRIGGER_IDENTIFIER}]`) && (isPointerDownRef.current = !0);
    }
    const doc = getDocument(floatingFocusElement);
    return doc.addEventListener("pointerdown", handlePointerDown, !0), () => {
      doc.removeEventListener("pointerdown", handlePointerDown, !0);
    };
  }, [disabled, open, floatingFocusElement]), useIsoLayoutEffect(() => {
    if (!disabled && portalContext)
      return portalContext.setFocusManagerState({
        modal,
        closeOnFocusOut,
        open,
        onOpenChange,
        domReference
      }), () => {
        portalContext.setFocusManagerState(null);
      };
  }, [disabled, portalContext, modal, open, onOpenChange, closeOnFocusOut, domReference]), useIsoLayoutEffect(() => {
    if (!(disabled || !floatingFocusElement))
      return handleTabIndex(floatingFocusElement, orderRef), () => {
        queueMicrotask(clearDisconnectedPreviouslyFocusedElements);
      };
  }, [disabled, floatingFocusElement, orderRef]);
  const shouldRenderGuards = !disabled && (modal ? !isUntrappedTypeableCombobox : !0) && (isInsidePortal || modal);
  return /* @__PURE__ */ jsxs(React.Fragment, {
    children: [shouldRenderGuards && /* @__PURE__ */ jsx(FocusGuard, {
      "data-type": "inside",
      ref: mergedBeforeGuardRef,
      onFocus: (event) => {
        var _a;
        if (modal) {
          const els = getTabbableElements();
          enqueueFocus(els[els.length - 1]);
        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode)
          if (preventReturnFocusRef.current = !1, isOutsideEvent(event, portalContext.portalNode)) {
            const nextTabbable = getNextTabbable(domReference);
            nextTabbable == null || nextTabbable.focus();
          } else
            (_a = portalContext.beforeOutsideRef.current) == null || _a.focus();
      }
    }), children, shouldRenderGuards && /* @__PURE__ */ jsx(FocusGuard, {
      "data-type": "inside",
      ref: mergedAfterGuardRef,
      onFocus: (event) => {
        var _a;
        if (modal)
          enqueueFocus(getTabbableElements()[0]);
        else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode)
          if (closeOnFocusOut && (preventReturnFocusRef.current = !0), isOutsideEvent(event, portalContext.portalNode)) {
            const prevTabbable = getPreviousTabbable(domReference);
            prevTabbable == null || prevTabbable.focus();
          } else
            (_a = portalContext.afterOutsideRef.current) == null || _a.focus();
      }
    })]
  });
}
var define_process_env_default$x = {};
const EMPTY = null;
let LAST_RAF = globalThis.requestAnimationFrame;
class Scheduler {
  constructor() {
    /* This implementation uses an array as a backing data-structure for frame callbacks.
     * It allows `O(1)` callback cancelling by inserting a `null` in the array, though it
     * never calls the native `cancelAnimationFrame` if there are no frames left. This can
     * be much more efficient if there is a call pattern that alterns as
     * "request-cancel-request-cancel-".
     * But in the case of "request-request--cancel-cancel-", it leaves the final animation
     * frame to run anyway. We turn that frame into a `O(1)` no-op via `callbacksCount`. */
    __publicField(this, "callbacks", []);
    __publicField(this, "callbacksCount", 0);
    __publicField(this, "nextId", 1);
    __publicField(this, "startId", 1);
    __publicField(this, "isScheduled", !1);
    __publicField(this, "tick", (timestamp) => {
      var _a;
      this.isScheduled = !1;
      const currentCallbacks = this.callbacks, currentCallbacksCount = this.callbacksCount;
      if (this.callbacks = [], this.callbacksCount = 0, this.startId = this.nextId, currentCallbacksCount > 0)
        for (let i2 = 0; i2 < currentCallbacks.length; i2 += 1)
          (_a = currentCallbacks[i2]) == null || _a.call(currentCallbacks, timestamp);
    });
  }
  request(fn) {
    const id = this.nextId;
    this.nextId += 1, this.callbacks.push(fn), this.callbacksCount += 1;
    const didRAFChange = define_process_env_default$x.NODE_ENV === "test" && LAST_RAF !== requestAnimationFrame && (LAST_RAF = requestAnimationFrame, !0);
    return (!this.isScheduled || didRAFChange) && (requestAnimationFrame(this.tick), this.isScheduled = !0), id;
  }
  cancel(id) {
    const index2 = id - this.startId;
    index2 < 0 || index2 >= this.callbacks.length || (this.callbacks[index2] = null, this.callbacksCount -= 1);
  }
}
const scheduler = new Scheduler();
class AnimationFrame {
  constructor() {
    __publicField(this, "currentId", EMPTY);
    __publicField(this, "cancel", () => {
      this.currentId !== EMPTY && (scheduler.cancel(this.currentId), this.currentId = EMPTY);
    });
    __publicField(this, "disposeEffect", () => this.cancel);
  }
  static create() {
    return new AnimationFrame();
  }
  static request(fn) {
    return scheduler.request(fn);
  }
  static cancel(id) {
    return scheduler.cancel(id);
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  request(fn) {
    this.cancel(), this.currentId = scheduler.request(() => {
      this.currentId = EMPTY, fn();
    });
  }
}
function useAnimationFrame() {
  const timeout = useRefWithInit(AnimationFrame.create).current;
  return useOnMount(timeout.disposeEffect), timeout;
}
function useClick(context, props = {}) {
  const {
    open,
    onOpenChange,
    dataRef
  } = context, {
    enabled = !0,
    event: eventOption = "click",
    toggle = !0,
    ignoreMouse = !1,
    stickIfOpen = !0
  } = props, pointerTypeRef = React.useRef(void 0), frame = useAnimationFrame(), reference = React.useMemo(() => ({
    onPointerDown(event) {
      pointerTypeRef.current = event.pointerType;
    },
    onMouseDown(event) {
      const pointerType = pointerTypeRef.current, nativeEvent = event.nativeEvent;
      if (event.button !== 0 || eventOption === "click" || isMouseLikePointerType(pointerType, !0) && ignoreMouse)
        return;
      const openEvent = dataRef.current.openEvent, openEventType = openEvent == null ? void 0 : openEvent.type, nextOpen = !(open && toggle && (!(openEvent && stickIfOpen) || openEventType === "click" || openEventType === "mousedown"));
      frame.request(() => {
        onOpenChange(nextOpen, nativeEvent, "click");
      });
    },
    onClick(event) {
      const pointerType = pointerTypeRef.current;
      if (eventOption === "mousedown" && pointerType) {
        pointerTypeRef.current = void 0;
        return;
      }
      if (isMouseLikePointerType(pointerType, !0) && ignoreMouse)
        return;
      const openEvent = dataRef.current.openEvent, openEventType = openEvent == null ? void 0 : openEvent.type;
      onOpenChange(!(open && toggle && (!(openEvent && stickIfOpen) || openEventType === "click" || openEventType === "mousedown" || openEventType === "keydown" || openEventType === "keyup")), event.nativeEvent, "click");
    },
    onKeyDown() {
      pointerTypeRef.current = void 0;
    }
  }), [dataRef, eventOption, ignoreMouse, onOpenChange, open, stickIfOpen, toggle, frame]);
  return React.useMemo(() => enabled ? {
    reference
  } : EMPTY_OBJECT, [enabled, reference]);
}
function createVirtualElement(domElement, data) {
  let offsetX = null, offsetY = null, isAutoUpdateEvent = !1;
  return {
    contextElement: domElement || void 0,
    getBoundingClientRect() {
      var _a;
      const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      }, isXAxis = data.axis === "x" || data.axis === "both", isYAxis = data.axis === "y" || data.axis === "both", canTrackCursorOnAutoUpdate = ["mouseenter", "mousemove"].includes(((_a = data.dataRef.current.openEvent) == null ? void 0 : _a.type) || "") && data.pointerType !== "touch";
      let width = domRect.width, height = domRect.height, x = domRect.x, y2 = domRect.y;
      return offsetX == null && data.x && isXAxis && (offsetX = domRect.x - data.x), offsetY == null && data.y && isYAxis && (offsetY = domRect.y - data.y), x -= offsetX || 0, y2 -= offsetY || 0, width = 0, height = 0, !isAutoUpdateEvent || canTrackCursorOnAutoUpdate ? (width = data.axis === "y" ? domRect.width : 0, height = data.axis === "x" ? domRect.height : 0, x = isXAxis && data.x != null ? data.x : x, y2 = isYAxis && data.y != null ? data.y : y2) : isAutoUpdateEvent && !canTrackCursorOnAutoUpdate && (height = data.axis === "x" ? domRect.height : height, width = data.axis === "y" ? domRect.width : width), isAutoUpdateEvent = !0, {
        width,
        height,
        x,
        y: y2,
        top: y2,
        right: x + width,
        bottom: y2 + height,
        left: x
      };
    }
  };
}
function isMouseBasedEvent(event) {
  return event != null && event.clientX != null;
}
function useClientPoint(context, props = {}) {
  const {
    open,
    dataRef,
    elements: {
      floating,
      domReference
    },
    refs
  } = context, {
    enabled = !0,
    axis = "both",
    x = null,
    y: y2 = null
  } = props, initialRef = React.useRef(!1), cleanupListenerRef = React.useRef(null), [pointerType, setPointerType] = React.useState(), [reactive, setReactive] = React.useState([]), setReference = useEventCallback((newX, newY) => {
    initialRef.current || dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent) || refs.setPositionReference(createVirtualElement(domReference, {
      x: newX,
      y: newY,
      axis,
      dataRef,
      pointerType
    }));
  }), handleReferenceEnterOrMove = useEventCallback((event) => {
    x != null || y2 != null || (open ? cleanupListenerRef.current || setReactive([]) : setReference(event.clientX, event.clientY));
  }), openCheck = isMouseLikePointerType(pointerType) ? floating : open, addListener = React.useCallback(() => {
    if (!openCheck || !enabled || x != null || y2 != null)
      return;
    const win = getWindow(floating);
    function handleMouseMove(event) {
      const target = getTarget(event);
      contains(floating, target) ? (win.removeEventListener("mousemove", handleMouseMove), cleanupListenerRef.current = null) : setReference(event.clientX, event.clientY);
    }
    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {
      win.addEventListener("mousemove", handleMouseMove);
      const cleanup = () => {
        win.removeEventListener("mousemove", handleMouseMove), cleanupListenerRef.current = null;
      };
      return cleanupListenerRef.current = cleanup, cleanup;
    }
    refs.setPositionReference(domReference);
  }, [openCheck, enabled, x, y2, floating, dataRef, refs, domReference, setReference]);
  React.useEffect(() => addListener(), [addListener, reactive]), React.useEffect(() => {
    enabled && !floating && (initialRef.current = !1);
  }, [enabled, floating]), React.useEffect(() => {
    !enabled && open && (initialRef.current = !0);
  }, [enabled, open]), useIsoLayoutEffect(() => {
    enabled && (x != null || y2 != null) && (initialRef.current = !1, setReference(x, y2));
  }, [enabled, x, y2, setReference]);
  const reference = React.useMemo(() => {
    function setPointerTypeRef(event) {
      setPointerType(event.pointerType);
    }
    return {
      onPointerDown: setPointerTypeRef,
      onPointerEnter: setPointerTypeRef,
      onMouseMove: handleReferenceEnterOrMove,
      onMouseEnter: handleReferenceEnterOrMove
    };
  }, [handleReferenceEnterOrMove]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const bubbleHandlerKeys = {
  intentional: "onClick",
  sloppy: "onPointerDown"
};
function normalizeProp(normalizable) {
  return {
    escapeKey: typeof normalizable == "boolean" ? normalizable : (normalizable == null ? void 0 : normalizable.escapeKey) ?? !1,
    outsidePress: typeof normalizable == "boolean" ? normalizable : (normalizable == null ? void 0 : normalizable.outsidePress) ?? !0
  };
}
function useDismiss(context, props = {}) {
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context, {
    enabled = !0,
    escapeKey: escapeKey2 = !0,
    outsidePress: outsidePressProp = !0,
    outsidePressEvent = "sloppy",
    referencePress = !1,
    referencePressEvent = "sloppy",
    ancestorScroll = !1,
    bubbles,
    capture
  } = props, tree = useFloatingTree(), outsidePressFn = useEventCallback(typeof outsidePressProp == "function" ? outsidePressProp : () => !1), outsidePress = typeof outsidePressProp == "function" ? outsidePressFn : outsidePressProp, endedOrStartedInsideRef = React.useRef(!1), {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles), {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture), touchStateRef = React.useRef(null), cancelDismissOnEndTimeout = useTimeout(), insideReactTreeTimeout = useTimeout(), isComposingRef = React.useRef(!1), currentPointerTypeRef = React.useRef(""), trackPointerType = useEventCallback((event) => {
    currentPointerTypeRef.current = event.pointerType;
  }), getOutsidePressEvent = useEventCallback(() => {
    const type = currentPointerTypeRef.current, computedType = type === "pen" || !type ? "mouse" : type;
    return typeof outsidePressEvent == "string" ? outsidePressEvent : outsidePressEvent[computedType];
  }), closeOnEscapeKeyDown = useEventCallback((event) => {
    var _a;
    if (!open || !enabled || !escapeKey2 || event.key !== "Escape" || isComposingRef.current)
      return;
    const nodeId = (_a = dataRef.current.floatingContext) == null ? void 0 : _a.nodeId, children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles && (event.stopPropagation(), children.length > 0)) {
      let shouldDismiss = !0;
      if (children.forEach((child) => {
        var _a2;
        (_a2 = child.context) != null && _a2.open && !child.context.dataRef.current.__escapeKeyBubbles && (shouldDismiss = !1);
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  }), shouldIgnoreEvent = useEventCallback((event) => {
    const computedOutsidePressEvent = getOutsidePressEvent();
    return computedOutsidePressEvent === "intentional" && event.type !== "click" || computedOutsidePressEvent === "sloppy" && event.type === "click";
  }), closeOnEscapeKeyDownCapture = useEventCallback((event) => {
    var _a;
    const callback = () => {
      var _a2;
      closeOnEscapeKeyDown(event), (_a2 = getTarget(event)) == null || _a2.removeEventListener("keydown", callback);
    };
    (_a = getTarget(event)) == null || _a.addEventListener("keydown", callback);
  }), closeOnPressOutside = useEventCallback((event) => {
    var _a;
    if (shouldIgnoreEvent(event))
      return;
    const insideReactTree = dataRef.current.insideReactTree;
    dataRef.current.insideReactTree = !1;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    if (endedOrStartedInsideRef.current = !1, getOutsidePressEvent() === "intentional" && endedOrStartedInside || insideReactTree || typeof outsidePress == "function" && !outsidePress(event))
      return;
    const target = getTarget(event), inertSelector = `[${createAttribute("inert")}]`, markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    for (; targetRootAncestor && !isLastTraversableNode(targetRootAncestor); ) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent))
        break;
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker)))
      return;
    if (isHTMLElement(target)) {
      const lastTraversableNode = isLastTraversableNode(target), style = getComputedStyle$1(target), scrollRe = /auto|scroll/, isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX), isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY), canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth, canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight, isRTL2 = style.direction === "rtl", pressedVerticalScrollbar = canScrollY && (isRTL2 ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth), pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
      if (pressedVerticalScrollbar || pressedHorizontalScrollbar)
        return;
    }
    const nodeId = (_a = dataRef.current.floatingContext) == null ? void 0 : _a.nodeId, targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some((node) => {
      var _a2;
      return isEventTargetWithin(event, (_a2 = node.context) == null ? void 0 : _a2.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren)
      return;
    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = !0;
      if (children.forEach((child) => {
        var _a2;
        (_a2 = child.context) != null && _a2.open && !child.context.dataRef.current.__outsidePressBubbles && (shouldDismiss = !1);
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, event, "outside-press");
  }), handlePointerDown = useEventCallback((event) => {
    if (!(getOutsidePressEvent() !== "sloppy" || !open || !enabled || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference))) {
      if (event.pointerType === "touch") {
        touchStateRef.current = {
          startTime: Date.now(),
          startX: event.clientX,
          startY: event.clientY,
          dismissOnPointerUp: !1,
          dismissOnMouseDown: !0
        }, cancelDismissOnEndTimeout.start(1e3, () => {
          touchStateRef.current && (touchStateRef.current.dismissOnPointerUp = !1, touchStateRef.current.dismissOnMouseDown = !1);
        });
        return;
      }
      closeOnPressOutside(event);
    }
  }), closeOnPressOutsideCapture = useEventCallback((event) => {
    var _a;
    if (shouldIgnoreEvent(event) || (cancelDismissOnEndTimeout.clear(), event.type === "mousedown" && touchStateRef.current && !touchStateRef.current.dismissOnMouseDown))
      return;
    const callback = () => {
      var _a2;
      event.type === "pointerdown" ? handlePointerDown(event) : closeOnPressOutside(event), (_a2 = getTarget(event)) == null || _a2.removeEventListener(event.type, callback);
    };
    (_a = getTarget(event)) == null || _a.addEventListener(event.type, callback);
  }), handlePointerMove = useEventCallback((event) => {
    if (getOutsidePressEvent() !== "sloppy" || event.pointerType !== "touch" || !touchStateRef.current || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference))
      return;
    const deltaX = Math.abs(event.clientX - touchStateRef.current.startX), deltaY = Math.abs(event.clientY - touchStateRef.current.startY), distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    distance > 5 && (touchStateRef.current.dismissOnPointerUp = !0), distance > 10 && (closeOnPressOutside(event), cancelDismissOnEndTimeout.clear(), touchStateRef.current = null);
  }), handlePointerUp = useEventCallback((event) => {
    getOutsidePressEvent() !== "sloppy" || event.pointerType !== "touch" || !touchStateRef.current || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || (touchStateRef.current.dismissOnPointerUp && closeOnPressOutside(event), cancelDismissOnEndTimeout.clear(), touchStateRef.current = null);
  });
  React.useEffect(() => {
    if (!open || !enabled)
      return;
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles, dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    const compositionTimeout = new Timeout();
    function onScroll(event) {
      onOpenChange(!1, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      compositionTimeout.clear(), isComposingRef.current = !0;
    }
    function handleCompositionEnd() {
      compositionTimeout.start(
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit$1() ? 5 : 0,
        () => {
          isComposingRef.current = !1;
        }
      );
    }
    const doc = getDocument(elements.floating);
    doc.addEventListener("pointerdown", trackPointerType, !0), escapeKey2 && (doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.addEventListener("compositionstart", handleCompositionStart), doc.addEventListener("compositionend", handleCompositionEnd)), outsidePress && (doc.addEventListener("click", outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), doc.addEventListener("pointerdown", outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), doc.addEventListener("pointermove", handlePointerMove, outsidePressCapture), doc.addEventListener("pointerup", handlePointerUp, outsidePressCapture), doc.addEventListener("mousedown", closeOnPressOutsideCapture, outsidePressCapture));
    let ancestors = [];
    return ancestorScroll && (isElement(elements.domReference) && (ancestors = getOverflowAncestors(elements.domReference)), isElement(elements.floating) && (ancestors = ancestors.concat(getOverflowAncestors(elements.floating))), !isElement(elements.reference) && elements.reference && elements.reference.contextElement && (ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement)))), ancestors = ancestors.filter((ancestor) => {
      var _a;
      return ancestor !== ((_a = doc.defaultView) == null ? void 0 : _a.visualViewport);
    }), ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: !0
      });
    }), () => {
      doc.removeEventListener("pointerdown", trackPointerType, !0), escapeKey2 && (doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.removeEventListener("compositionstart", handleCompositionStart), doc.removeEventListener("compositionend", handleCompositionEnd)), outsidePress && (doc.removeEventListener("click", outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), doc.removeEventListener("pointerdown", outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), doc.removeEventListener("pointermove", handlePointerMove, outsidePressCapture), doc.removeEventListener("pointerup", handlePointerUp, outsidePressCapture), doc.removeEventListener("mousedown", closeOnPressOutsideCapture, outsidePressCapture)), ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      }), compositionTimeout.clear();
    };
  }, [dataRef, elements, escapeKey2, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture, handlePointerDown, handlePointerMove, handlePointerUp, trackPointerType]), React.useEffect(() => {
    dataRef.current.insideReactTree = !1;
  }, [dataRef, outsidePress]);
  const reference = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    ...referencePress && {
      [bubbleHandlerKeys[referencePressEvent]]: (event) => {
        onOpenChange(!1, event.nativeEvent, "reference-press");
      },
      ...referencePressEvent !== "intentional" && {
        onClick(event) {
          onOpenChange(!1, event.nativeEvent, "reference-press");
        }
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]), handlePressedInside = useEventCallback((event) => {
    const target = getTarget(event.nativeEvent);
    contains(elements.floating, target) && (endedOrStartedInsideRef.current = !0);
  }), handleCaptureInside = useEventCallback(() => {
    dataRef.current.insideReactTree = !0, insideReactTreeTimeout.start(0, () => {
      dataRef.current.insideReactTree = !1;
    });
  }), floating = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown: handlePressedInside,
    onMouseUp: handlePressedInside,
    onPointerDownCapture: handleCaptureInside,
    onMouseDownCapture: handleCaptureInside,
    onClickCapture: handleCaptureInside
  }), [closeOnEscapeKeyDown, handlePressedInside, handleCaptureInside]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
var define_process_env_default$w = {};
function useFloatingRootContext(options) {
  const {
    open = !1,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options, floatingId = useId(), dataRef = React.useRef({}), [events] = React.useState(() => createEventEmitter()), nested = useFloatingParentNodeId() != null;
  if (define_process_env_default$w.NODE_ENV !== "production") {
    const optionDomReference = elementsProp.reference;
    optionDomReference && !isElement(optionDomReference) && console.error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEventCallback((newOpen, event, reason) => {
    dataRef.current.openEvent = newOpen ? event : void 0, events.emit("openchange", {
      open: newOpen,
      event,
      reason,
      nested
    }), onOpenChangeProp == null || onOpenChangeProp(newOpen, event, reason);
  }), refs = React.useMemo(() => ({
    setPositionReference
  }), []), elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options = {}) {
  const {
    nodeId
  } = options, internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [domReferenceState, setDomReference] = React.useState(null), [positionReference, setPositionReferenceRaw] = React.useState(null), domReference = (computedElements == null ? void 0 : computedElements.domReference) || domReferenceState, domReferenceRef = React.useRef(null), tree = useFloatingTree();
  useIsoLayoutEffect(() => {
    domReference && (domReferenceRef.current = domReference);
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  }), setPositionReference = React.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      getClientRects: () => node.getClientRects(),
      contextElement: node
    } : node;
    setPositionReferenceRaw(computedPositionReference), position.refs.setReference(computedPositionReference);
  }, [position.refs]), setReference = React.useCallback((node) => {
    (isElement(node) || node === null) && (domReferenceRef.current = node, setDomReference(node)), (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) && position.refs.setReference(node);
  }, [position.refs]), refs = React.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]), context = React.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  return useIsoLayoutEffect(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((n2) => n2.id === nodeId);
    node && (node.context = context);
  }), React.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
const isMacSafari = isMac && isSafari;
function useFocus(context, props = {}) {
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context, {
    enabled = !0,
    visibleOnly = !0
  } = props, blockFocusRef = React.useRef(!1), timeout = useTimeout(), keyboardModalityRef = React.useRef(!0);
  React.useEffect(() => {
    if (!enabled)
      return;
    const win = getWindow(elements.domReference);
    function onBlur() {
      !open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference)) && (blockFocusRef.current = !0);
    }
    function onKeyDown() {
      keyboardModalityRef.current = !0;
    }
    function onPointerDown() {
      keyboardModalityRef.current = !1;
    }
    return win.addEventListener("blur", onBlur), isMacSafari && (win.addEventListener("keydown", onKeyDown, !0), win.addEventListener("pointerdown", onPointerDown, !0)), () => {
      win.removeEventListener("blur", onBlur), isMacSafari && (win.removeEventListener("keydown", onKeyDown, !0), win.removeEventListener("pointerdown", onPointerDown, !0));
    };
  }, [elements.domReference, open, enabled]), React.useEffect(() => {
    if (!enabled)
      return;
    function onOpenChangeLocal({
      reason
    }) {
      (reason === "reference-press" || reason === "escape-key") && (blockFocusRef.current = !0);
    }
    return events.on("openchange", onOpenChangeLocal), () => {
      events.off("openchange", onOpenChangeLocal);
    };
  }, [events, enabled]);
  const reference = React.useMemo(() => ({
    onMouseLeave() {
      blockFocusRef.current = !1;
    },
    onFocus(event) {
      if (blockFocusRef.current)
        return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target)) {
        if (isMacSafari && !event.relatedTarget) {
          if (!keyboardModalityRef.current && !isTypeableElement(target))
            return;
        } else if (!matchesFocusVisible(target))
          return;
      }
      onOpenChange(!0, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = !1;
      const relatedTarget = event.relatedTarget, nativeEvent = event.nativeEvent, movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeout.start(0, () => {
        var _a;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        !relatedTarget && activeEl === elements.domReference || contains((_a = dataRef.current.floatingContext) == null ? void 0 : _a.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard || onOpenChange(!1, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly, timeout]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function useInteractions(propsList = []) {
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference), floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating), itemDeps = propsList.map((key) => key == null ? void 0 : key.item), getReferenceProps = React.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  ), getFloatingProps = React.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  ), getItemProps = React.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function mergeProps$1(userProps, propsList, elementKey) {
  var _a;
  const eventHandlers = /* @__PURE__ */ new Map(), isItem = elementKey === "item", outputProps = {};
  elementKey === "floating" && (outputProps.tabIndex = -1, outputProps[FOCUSABLE_ATTRIBUTE] = "");
  for (const key in userProps)
    isItem && userProps && (key === ACTIVE_KEY || key === SELECTED_KEY) || (outputProps[key] = userProps[key]);
  for (let i2 = 0; i2 < propsList.length; i2 += 1) {
    let props;
    const propsOrGetProps = (_a = propsList[i2]) == null ? void 0 : _a[elementKey];
    typeof propsOrGetProps == "function" ? props = userProps ? propsOrGetProps(userProps) : null : props = propsOrGetProps, props && mutablyMergeProps(outputProps, props, isItem, eventHandlers);
  }
  return mutablyMergeProps(outputProps, userProps, isItem, eventHandlers), outputProps;
}
function mutablyMergeProps(outputProps, props, isItem, eventHandlers) {
  var _a;
  for (const key in props) {
    const value = props[key];
    isItem && (key === ACTIVE_KEY || key === SELECTED_KEY) || (key.startsWith("on") ? (eventHandlers.has(key) || eventHandlers.set(key, []), typeof value == "function" && ((_a = eventHandlers.get(key)) == null || _a.push(value), outputProps[key] = (...args) => {
      var _a2;
      return (_a2 = eventHandlers.get(key)) == null ? void 0 : _a2.map((fn) => fn(...args)).find((val) => val !== void 0);
    })) : outputProps[key] = value);
  }
}
var define_process_env_default$v = {};
const ESCAPE = "Escape";
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case "vertical":
      return vertical;
    case "horizontal":
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  return doSwitch(orientation, key === ARROW_UP || key === ARROW_DOWN, key === ARROW_LEFT || key === ARROW_RIGHT);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  return doSwitch(orientation, key === ARROW_DOWN, rtl ? key === ARROW_LEFT : key === ARROW_RIGHT) || key === "Enter" || key === " " || key === "";
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  return doSwitch(orientation, rtl ? key === ARROW_LEFT : key === ARROW_RIGHT, key === ARROW_DOWN);
}
function isCrossOrientationCloseKey(key, orientation, rtl, cols) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT, horizontal = key === ARROW_UP;
  return orientation === "both" || orientation === "horizontal" && cols && cols > 1 ? key === ESCAPE : doSwitch(orientation, vertical, horizontal);
}
function useListNavigation(context, props) {
  const {
    open,
    onOpenChange,
    elements,
    floatingId
  } = context, {
    listRef,
    activeIndex,
    onNavigate: onNavigateProp = () => {
    },
    enabled = !0,
    selectedIndex = null,
    allowEscape = !1,
    loop = !1,
    nested = !1,
    rtl = !1,
    virtual = !1,
    focusItemOnOpen = "auto",
    focusItemOnHover = !0,
    openOnArrowKeyDown = !0,
    disabledIndices = void 0,
    orientation = "vertical",
    parentOrientation,
    cols = 1,
    scrollItemIntoView = !0,
    virtualItemRef,
    itemSizes,
    dense = !1
  } = props;
  define_process_env_default$v.NODE_ENV !== "production" && (allowEscape && (loop || console.warn("`useListNavigation` looping must be enabled to allow escaping."), virtual || console.warn("`useListNavigation` must be virtual to allow escaping.")), orientation === "vertical" && cols > 1 && console.warn("In grid list navigation mode (`cols` > 1), the `orientation` should", 'be either "horizontal" or "both".'));
  const floatingFocusElement = getFloatingFocusElement(elements.floating), floatingFocusElementRef = useLatestRef(floatingFocusElement), parentId = useFloatingParentNodeId(), tree = useFloatingTree();
  useIsoLayoutEffect(() => {
    context.dataRef.current.orientation = orientation;
  }, [context, orientation]);
  const typeableComboboxReference = isTypeableCombobox(elements.domReference), focusItemOnOpenRef = React.useRef(focusItemOnOpen), indexRef = React.useRef(selectedIndex ?? -1), keyRef = React.useRef(null), isPointerModalityRef = React.useRef(!0), onNavigate = useEventCallback(() => {
    onNavigateProp(indexRef.current === -1 ? null : indexRef.current);
  }), previousOnNavigateRef = React.useRef(onNavigate), previousMountedRef = React.useRef(!!elements.floating), previousOpenRef = React.useRef(open), forceSyncFocusRef = React.useRef(!1), forceScrollIntoViewRef = React.useRef(!1), disabledIndicesRef = useLatestRef(disabledIndices), latestOpenRef = useLatestRef(open), scrollItemIntoViewRef = useLatestRef(scrollItemIntoView), selectedIndexRef = useLatestRef(selectedIndex), [activeId, setActiveId] = React.useState(), focusItem = useEventCallback(() => {
    function runFocus(item2) {
      var _a;
      virtual ? ((_a = item2.id) != null && _a.endsWith("-fui-option") && (item2.id = `${floatingId}-${Math.random().toString(16).slice(2, 10)}`), setActiveId(item2.id), tree == null || tree.events.emit("virtualfocus", item2), virtualItemRef && (virtualItemRef.current = item2)) : enqueueFocus(item2, {
        sync: forceSyncFocusRef.current,
        preventScroll: !0
      });
    }
    const initialItem = listRef.current[indexRef.current], forceScrollIntoView = forceScrollIntoViewRef.current;
    initialItem && runFocus(initialItem), (forceSyncFocusRef.current ? (v2) => v2() : requestAnimationFrame)(() => {
      var _a;
      const waitedItem = listRef.current[indexRef.current] || initialItem;
      if (!waitedItem)
        return;
      initialItem || runFocus(waitedItem);
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current) && ((_a = waitedItem.scrollIntoView) == null || _a.call(waitedItem, typeof scrollIntoViewOptions == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : scrollIntoViewOptions));
    });
  });
  useIsoLayoutEffect(() => {
    enabled && (open && elements.floating ? focusItemOnOpenRef.current && selectedIndex != null && (forceScrollIntoViewRef.current = !0, indexRef.current = selectedIndex, onNavigate()) : previousMountedRef.current && (indexRef.current = -1, previousOnNavigateRef.current()));
  }, [enabled, open, elements.floating, selectedIndex, onNavigate]), useIsoLayoutEffect(() => {
    if (enabled && open && elements.floating)
      if (activeIndex == null) {
        if (forceSyncFocusRef.current = !1, selectedIndexRef.current != null)
          return;
        if (previousMountedRef.current && (indexRef.current = -1, focusItem()), (!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === !0 && keyRef.current == null)) {
          let runs = 0;
          const waitForListPopulated = () => {
            listRef.current[0] == null ? (runs < 2 && (runs ? requestAnimationFrame : queueMicrotask)(waitForListPopulated), runs += 1) : (indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinListIndex(listRef, disabledIndicesRef.current) : getMaxListIndex(listRef, disabledIndicesRef.current), keyRef.current = null, onNavigate());
          };
          waitForListPopulated();
        }
      } else isIndexOutOfListBounds(listRef, activeIndex) || (indexRef.current = activeIndex, focusItem(), forceScrollIntoViewRef.current = !1);
  }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]), useIsoLayoutEffect(() => {
    var _a, _b;
    if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current)
      return;
    const nodes = tree.nodesRef.current, parent = (_b = (_a = nodes.find((node) => node.id === parentId)) == null ? void 0 : _a.context) == null ? void 0 : _b.elements.floating, activeEl = activeElement(getDocument(elements.floating)), treeContainsActiveEl = nodes.some((node) => node.context && contains(node.context.elements.floating, activeEl));
    parent && !treeContainsActiveEl && isPointerModalityRef.current && parent.focus({
      preventScroll: !0
    });
  }, [enabled, elements.floating, tree, parentId, virtual]), useIsoLayoutEffect(() => {
    previousOnNavigateRef.current = onNavigate, previousOpenRef.current = open, previousMountedRef.current = !!elements.floating;
  }), useIsoLayoutEffect(() => {
    open || (keyRef.current = null, focusItemOnOpenRef.current = focusItemOnOpen);
  }, [open, focusItemOnOpen]);
  const hasActiveIndex = activeIndex != null, item = React.useMemo(() => {
    function syncCurrentTarget(currentTarget) {
      if (!latestOpenRef.current)
        return;
      const index2 = listRef.current.indexOf(currentTarget);
      index2 !== -1 && indexRef.current !== index2 && (indexRef.current = index2, onNavigate());
    }
    return {
      onFocus({
        currentTarget
      }) {
        forceSyncFocusRef.current = !0, syncCurrentTarget(currentTarget);
      },
      onClick: ({
        currentTarget
      }) => currentTarget.focus({
        preventScroll: !0
      }),
      // Safari
      onMouseMove({
        currentTarget
      }) {
        forceSyncFocusRef.current = !0, forceScrollIntoViewRef.current = !1, focusItemOnHover && syncCurrentTarget(currentTarget);
      },
      onPointerLeave({
        pointerType
      }) {
        var _a;
        !isPointerModalityRef.current || pointerType === "touch" || (forceSyncFocusRef.current = !0, focusItemOnHover && (indexRef.current = -1, onNavigate(), virtual || (_a = floatingFocusElementRef.current) == null || _a.focus({
          preventScroll: !0
        })));
      }
    };
  }, [latestOpenRef, floatingFocusElementRef, focusItemOnHover, listRef, onNavigate, virtual]), getParentOrientation = React.useCallback(() => {
    var _a, _b, _c;
    return parentOrientation ?? ((_c = (_b = (_a = tree == null ? void 0 : tree.nodesRef.current.find((node) => node.id === parentId)) == null ? void 0 : _a.context) == null ? void 0 : _b.dataRef) == null ? void 0 : _c.current.orientation);
  }, [parentId, tree, parentOrientation]), commonOnKeyDown = useEventCallback((event) => {
    if (isPointerModalityRef.current = !1, forceSyncFocusRef.current = !0, event.which === 229 || !latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current)
      return;
    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {
      isMainOrientationKey(event.key, getParentOrientation()) || stopEvent(event), onOpenChange(!1, event.nativeEvent, "list-navigation"), isHTMLElement(elements.domReference) && (virtual ? tree == null || tree.events.emit("virtualfocus", elements.domReference) : elements.domReference.focus());
      return;
    }
    const currentIndex = indexRef.current, minIndex = getMinListIndex(listRef, disabledIndices), maxIndex = getMaxListIndex(listRef, disabledIndices);
    if (typeableComboboxReference || (event.key === "Home" && (stopEvent(event), indexRef.current = minIndex, onNavigate()), event.key === "End" && (stopEvent(event), indexRef.current = maxIndex, onNavigate())), cols > 1) {
      const sizes = itemSizes || Array.from({
        length: listRef.current.length
      }, () => ({
        width: 1,
        height: 1
      })), cellMap = createGridCellMap(sizes, cols, dense), minGridIndex = cellMap.findIndex((index22) => index22 != null && !isListIndexDisabled(listRef, index22, disabledIndices)), maxGridIndex = cellMap.reduce((foundIndex, index22, cellIndex) => index22 != null && !isListIndexDisabled(listRef, index22, disabledIndices) ? cellIndex : foundIndex, -1), index2 = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex != null ? listRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getGridCellIndices([...(typeof disabledIndices != "function" ? disabledIndices : null) || listRef.current.map((_2, listIndex) => isListIndexDisabled(listRef, listIndex, disabledIndices) ? listIndex : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getGridCellIndexOfCorner(
          indexRef.current > maxIndex ? minIndex : indexRef.current,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction
          // we're moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          // eslint-disable-next-line no-nested-ternary
          event.key === ARROW_DOWN ? "bl" : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? "tr" : "tl"
        ),
        stopEvent: !0
      })];
      if (index2 != null && (indexRef.current = index2, onNavigate()), orientation === "both")
        return;
    }
    if (isMainOrientationKey(event.key, orientation)) {
      if (stopEvent(event), open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex, onNavigate();
        return;
      }
      isMainOrientationToEndKey(event.key, orientation, rtl) ? loop ? indexRef.current = // eslint-disable-next-line no-nested-ternary
      currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledListIndex(listRef, {
        startingIndex: currentIndex,
        disabledIndices
      }) : indexRef.current = Math.min(maxIndex, findNonDisabledListIndex(listRef, {
        startingIndex: currentIndex,
        disabledIndices
      })) : loop ? indexRef.current = // eslint-disable-next-line no-nested-ternary
      currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledListIndex(listRef, {
        startingIndex: currentIndex,
        decrement: !0,
        disabledIndices
      }) : indexRef.current = Math.max(minIndex, findNonDisabledListIndex(listRef, {
        startingIndex: currentIndex,
        decrement: !0,
        disabledIndices
      })), isIndexOutOfListBounds(listRef, indexRef.current) && (indexRef.current = -1), onNavigate();
    }
  }), ariaActiveDescendantProp = React.useMemo(() => virtual && open && hasActiveIndex && {
    "aria-activedescendant": activeId
  }, [virtual, open, hasActiveIndex, activeId]), floating = React.useMemo(() => ({
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    ...typeableComboboxReference ? {} : ariaActiveDescendantProp,
    onKeyDown(event) {
      if (event.key === "Tab" && event.shiftKey && open && !virtual) {
        stopEvent(event), onOpenChange(!1, event.nativeEvent, "list-navigation"), isHTMLElement(elements.domReference) && elements.domReference.focus();
        return;
      }
      commonOnKeyDown(event);
    },
    onPointerMove() {
      isPointerModalityRef.current = !0;
    }
  }), [ariaActiveDescendantProp, commonOnKeyDown, orientation, typeableComboboxReference, onOpenChange, open, virtual, elements.domReference]), reference = React.useMemo(() => {
    function checkVirtualMouse(event) {
      focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent) && (focusItemOnOpenRef.current = !0);
    }
    function checkVirtualPointer(event) {
      focusItemOnOpenRef.current = focusItemOnOpen, focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent) && (focusItemOnOpenRef.current = !0);
    }
    return {
      ...ariaActiveDescendantProp,
      onKeyDown(event) {
        isPointerModalityRef.current = !1;
        const isArrowKey = event.key.startsWith("Arrow"), isParentCrossOpenKey = isCrossOrientationOpenKey(event.key, getParentOrientation(), rtl), isMainKey = isMainOrientationKey(event.key, orientation), isNavigationKey = (nested ? isParentCrossOpenKey : isMainKey) || event.key === "Enter" || event.key.trim() === "";
        if (virtual && open)
          return commonOnKeyDown(event);
        if (!(!open && !openOnArrowKeyDown && isArrowKey)) {
          if (isNavigationKey) {
            const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());
            keyRef.current = nested && isParentMainKey ? null : event.key;
          }
          if (nested) {
            isParentCrossOpenKey && (stopEvent(event), open ? (indexRef.current = getMinListIndex(listRef, disabledIndicesRef.current), onNavigate()) : onOpenChange(!0, event.nativeEvent, "list-navigation"));
            return;
          }
          isMainKey && (selectedIndex != null && (indexRef.current = selectedIndex), stopEvent(event), !open && openOnArrowKeyDown ? onOpenChange(!0, event.nativeEvent, "list-navigation") : commonOnKeyDown(event), open && onNavigate());
        }
      },
      onFocus() {
        open && !virtual && (indexRef.current = -1, onNavigate());
      },
      onPointerDown: checkVirtualPointer,
      onPointerEnter: checkVirtualPointer,
      onMouseDown: checkVirtualMouse,
      onClick: checkVirtualMouse
    };
  }, [ariaActiveDescendantProp, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, getParentOrientation, rtl, selectedIndex, virtual]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function useRole(context, props = {}) {
  var _a;
  const {
    open,
    elements,
    floatingId: defaultFloatingId
  } = context, {
    enabled = !0,
    role = "dialog"
  } = props, defaultReferenceId = useId(), referenceId = ((_a = elements.domReference) == null ? void 0 : _a.id) || defaultReferenceId, floatingId = React.useMemo(() => {
    var _a2;
    return ((_a2 = getFloatingFocusElement(elements.floating)) == null ? void 0 : _a2.id) || defaultFloatingId;
  }, [elements.floating, defaultFloatingId]), ariaRole = componentRoleToAriaRoleMap.get(role) ?? role, isNested = useFloatingParentNodeId() != null, reference = React.useMemo(() => ariaRole === "tooltip" || role === "label" ? {
    [`aria-${role === "label" ? "labelledby" : "describedby"}`]: open ? floatingId : void 0
  } : {
    "aria-expanded": open ? "true" : "false",
    "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
    "aria-controls": open ? floatingId : void 0,
    ...ariaRole === "listbox" && {
      role: "combobox"
    },
    ...ariaRole === "menu" && {
      id: referenceId
    },
    ...ariaRole === "menu" && isNested && {
      role: "menuitem"
    },
    ...role === "select" && {
      "aria-autocomplete": "none"
    },
    ...role === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [ariaRole, floatingId, isNested, open, referenceId, role]), floating = React.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    return ariaRole === "tooltip" || role === "label" ? floatingProps : {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]), item = React.useCallback(({
    active,
    selected
  }) => {
    const commonProps = {
      role: "option",
      ...active && {
        id: `${floatingId}-fui-option`
      }
    };
    switch (role) {
      case "select":
      case "combobox":
        return {
          ...commonProps,
          "aria-selected": selected
        };
    }
    return {};
  }, [floatingId, role]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
function useTypeahead(context, props) {
  const {
    open,
    dataRef
  } = context, {
    listRef,
    activeIndex,
    onMatch: onMatchProp,
    onTypingChange: onTypingChangeProp,
    enabled = !0,
    findMatch = null,
    resetMs = 750,
    ignoreKeys = [],
    selectedIndex = null
  } = props, timeout = useTimeout(), stringRef = React.useRef(""), prevIndexRef = React.useRef(selectedIndex ?? activeIndex ?? -1), matchIndexRef = React.useRef(null), onMatch = useEventCallback(onMatchProp), onTypingChange = useEventCallback(onTypingChangeProp), findMatchRef = useLatestRef(findMatch), ignoreKeysRef = useLatestRef(ignoreKeys);
  useIsoLayoutEffect(() => {
    open && (timeout.clear(), matchIndexRef.current = null, stringRef.current = "");
  }, [open, timeout]), useIsoLayoutEffect(() => {
    open && stringRef.current === "" && (prevIndexRef.current = selectedIndex ?? activeIndex ?? -1);
  }, [open, selectedIndex, activeIndex]);
  const setTypingChange = useEventCallback((value) => {
    value ? dataRef.current.typing || (dataRef.current.typing = value, onTypingChange(value)) : dataRef.current.typing && (dataRef.current.typing = value, onTypingChange(value));
  }), onKeyDown = useEventCallback((event) => {
    function getMatchingIndex(list, orderedList, string) {
      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text) => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);
      return str ? list.indexOf(str) : -1;
    }
    const listContent = listRef.current;
    if (stringRef.current.length > 0 && stringRef.current[0] !== " " && (getMatchingIndex(listContent, listContent, stringRef.current) === -1 ? setTypingChange(!1) : event.key === " " && stopEvent(event)), listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.
    event.key.length !== 1 || // Modifier key.
    event.ctrlKey || event.metaKey || event.altKey)
      return;
    open && event.key !== " " && (stopEvent(event), setTypingChange(!0)), listContent.every((text) => {
      var _a, _b;
      return text ? ((_a = text[0]) == null ? void 0 : _a.toLocaleLowerCase()) !== ((_b = text[1]) == null ? void 0 : _b.toLocaleLowerCase()) : !0;
    }) && stringRef.current === event.key && (stringRef.current = "", prevIndexRef.current = matchIndexRef.current), stringRef.current += event.key, timeout.start(resetMs, () => {
      stringRef.current = "", prevIndexRef.current = matchIndexRef.current, setTypingChange(!1);
    });
    const prevIndex = prevIndexRef.current, index2 = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);
    index2 !== -1 ? (onMatch(index2), matchIndexRef.current = index2) : event.key !== " " && (stringRef.current = "", setTypingChange(!1));
  }), reference = React.useMemo(() => ({
    onKeyDown
  }), [onKeyDown]), floating = React.useMemo(() => ({
    onKeyDown,
    onKeyUp(event) {
      event.key === " " && setTypingChange(!1);
    }
  }), [onKeyDown, setTypingChange]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function isPointInPolygon(point, polygon) {
  const [x, y2] = point;
  let isInsideValue = !1;
  const length = polygon.length;
  for (let i2 = 0, j = length - 1; i2 < length; j = i2++) {
    const [xi, yi] = polygon[i2] || [0, 0], [xj, yj] = polygon[j] || [0, 0];
    yi >= y2 != yj >= y2 && x <= (xj - xi) * (y2 - yi) / (yj - yi) + xi && (isInsideValue = !isInsideValue);
  }
  return isInsideValue;
}
function isInside(point, rect) {
  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
}
function safePolygon(options = {}) {
  const {
    buffer = 0.5,
    blockPointerEvents = !1,
    requireIntent = !0
  } = options, timeout = new Timeout();
  let hasLanded = !1, lastX = null, lastY = null, lastCursorTime = typeof performance < "u" ? performance.now() : 0;
  function getCursorSpeed(x, y2) {
    const currentTime = performance.now(), elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0)
      return lastX = x, lastY = y2, lastCursorTime = currentTime, null;
    const deltaX = x - lastX, deltaY = y2 - lastY, speed = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / elapsedTime;
    return lastX = x, lastY = y2, lastCursorTime = currentTime, speed;
  }
  const fn = ({
    x,
    y: y2,
    placement,
    elements,
    onClose,
    nodeId,
    tree
  }) => function(event) {
    function close() {
      timeout.clear(), onClose();
    }
    if (timeout.clear(), !elements.domReference || !elements.floating || placement == null || x == null || y2 == null)
      return;
    const {
      clientX,
      clientY
    } = event, clientPoint = [clientX, clientY], target = getTarget(event), isLeave = event.type === "mouseleave", isOverFloatingEl = contains(elements.floating, target), isOverReferenceEl = contains(elements.domReference, target), refRect = elements.domReference.getBoundingClientRect(), rect = elements.floating.getBoundingClientRect(), side = placement.split("-")[0], cursorLeaveFromRight = x > rect.right - rect.width / 2, cursorLeaveFromBottom = y2 > rect.bottom - rect.height / 2, isOverReferenceRect = isInside(clientPoint, refRect), isFloatingWider = rect.width > refRect.width, isFloatingTaller = rect.height > refRect.height, left = (isFloatingWider ? refRect : rect).left, right = (isFloatingWider ? refRect : rect).right, top = (isFloatingTaller ? refRect : rect).top, bottom = (isFloatingTaller ? refRect : rect).bottom;
    if (isOverFloatingEl && (hasLanded = !0, !isLeave))
      return;
    if (isOverReferenceEl && (hasLanded = !1), isOverReferenceEl && !isLeave) {
      hasLanded = !0;
      return;
    }
    if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget) || tree && getNodeChildren(tree.nodesRef.current, nodeId).some(({
      context
    }) => context == null ? void 0 : context.open))
      return;
    if (side === "top" && y2 >= refRect.bottom - 1 || side === "bottom" && y2 <= refRect.top + 1 || side === "left" && x >= refRect.right - 1 || side === "right" && x <= refRect.left + 1)
      return close();
    let rectPoly = [];
    switch (side) {
      case "top":
        rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];
        break;
      case "bottom":
        rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];
        break;
      case "left":
        rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];
        break;
      case "right":
        rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];
        break;
    }
    function getPolygon([px, py]) {
      switch (side) {
        case "top": {
          const cursorPointOne = [isFloatingWider ? px + buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py + buffer + 1], cursorPointTwo = [isFloatingWider ? px - buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py + buffer + 1], commonPoints = [[rect.left, cursorLeaveFromRight || isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
          return [cursorPointOne, cursorPointTwo, ...commonPoints];
        }
        case "bottom": {
          const cursorPointOne = [isFloatingWider ? px + buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py - buffer], cursorPointTwo = [isFloatingWider ? px - buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py - buffer], commonPoints = [[rect.left, cursorLeaveFromRight || isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
          return [cursorPointOne, cursorPointTwo, ...commonPoints];
        }
        case "left": {
          const cursorPointOne = [px + buffer + 1, isFloatingTaller ? py + buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4], cursorPointTwo = [px + buffer + 1, isFloatingTaller ? py - buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];
          return [...[[cursorLeaveFromBottom || isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]], cursorPointOne, cursorPointTwo];
        }
        case "right": {
          const cursorPointOne = [px - buffer, isFloatingTaller ? py + buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4], cursorPointTwo = [px - buffer, isFloatingTaller ? py - buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4], commonPoints = [[cursorLeaveFromBottom || isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
          return [cursorPointOne, cursorPointTwo, ...commonPoints];
        }
        default:
          return [];
      }
    }
    if (!isPointInPolygon([clientX, clientY], rectPoly)) {
      if (hasLanded && !isOverReferenceRect)
        return close();
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        if (cursorSpeed !== null && cursorSpeed < 0.1)
          return close();
      }
      isPointInPolygon([clientX, clientY], getPolygon([x, y2])) ? !hasLanded && requireIntent && timeout.start(40, close) : close();
    }
  };
  return fn.__options = {
    blockPointerEvents
  }, fn;
}
const NOOP = () => {
};
let FieldControlDataAttributes = /* @__PURE__ */ (function(FieldControlDataAttributes2) {
  return FieldControlDataAttributes2.disabled = "data-disabled", FieldControlDataAttributes2.valid = "data-valid", FieldControlDataAttributes2.invalid = "data-invalid", FieldControlDataAttributes2.touched = "data-touched", FieldControlDataAttributes2.dirty = "data-dirty", FieldControlDataAttributes2.filled = "data-filled", FieldControlDataAttributes2.focused = "data-focused", FieldControlDataAttributes2;
})({});
const DEFAULT_VALIDITY_STATE = {
  badInput: !1,
  customError: !1,
  patternMismatch: !1,
  rangeOverflow: !1,
  rangeUnderflow: !1,
  stepMismatch: !1,
  tooLong: !1,
  tooShort: !1,
  typeMismatch: !1,
  valid: null,
  valueMissing: !1
}, fieldValidityMapping = {
  valid(value) {
    return value === null ? null : value ? {
      [FieldControlDataAttributes.valid]: ""
    } : {
      [FieldControlDataAttributes.invalid]: ""
    };
  }
};
var define_process_env_default$u = {};
const FieldRootContext = /* @__PURE__ */ React.createContext({
  invalid: void 0,
  controlId: void 0,
  setControlId: NOOP,
  labelId: void 0,
  setLabelId: NOOP,
  messageIds: [],
  setMessageIds: NOOP,
  name: void 0,
  validityData: {
    state: DEFAULT_VALIDITY_STATE,
    errors: [],
    error: "",
    value: "",
    initialValue: null
  },
  setValidityData: NOOP,
  disabled: void 0,
  touched: !1,
  setTouched: NOOP,
  dirty: !1,
  setDirty: NOOP,
  filled: !1,
  setFilled: NOOP,
  focused: !1,
  setFocused: NOOP,
  validate: () => null,
  validationMode: "onBlur",
  validationDebounceTime: 0,
  state: {
    disabled: !1,
    valid: null,
    touched: !1,
    dirty: !1,
    filled: !1,
    focused: !1
  },
  markedDirtyRef: {
    current: !1
  }
});
define_process_env_default$u.NODE_ENV !== "production" && (FieldRootContext.displayName = "FieldRootContext");
function useFieldRootContext(optional = !0) {
  const context = React.useContext(FieldRootContext);
  if (context.setControlId === NOOP && !optional)
    throw new Error("Base UI: FieldRootContext is missing. Field parts must be placed within <Field.Root>.");
  return context;
}
function mergeObjects(a2, b) {
  if (a2 && !b)
    return a2;
  if (!a2 && b)
    return b;
  if (a2 || b)
    return {
      ...a2,
      ...b
    };
}
const EMPTY_PROPS = {};
function mergeProps(a2, b, c2, d2, e2) {
  let merged = {
    ...resolvePropsGetter(a2, EMPTY_PROPS)
  };
  return b && (merged = mergeOne(merged, b)), c2 && (merged = mergeOne(merged, c2)), d2 && (merged = mergeOne(merged, d2)), e2 && (merged = mergeOne(merged, e2)), merged;
}
function mergePropsN(props) {
  if (props.length === 0)
    return EMPTY_PROPS;
  if (props.length === 1)
    return resolvePropsGetter(props[0], EMPTY_PROPS);
  let merged = {
    ...resolvePropsGetter(props[0], EMPTY_PROPS)
  };
  for (let i2 = 1; i2 < props.length; i2 += 1)
    merged = mergeOne(merged, props[i2]);
  return merged;
}
function mergeOne(merged, inputProps) {
  return isPropsGetter(inputProps) ? inputProps(merged) : mutablyMergeInto(merged, inputProps);
}
function mutablyMergeInto(mergedProps, externalProps) {
  if (!externalProps)
    return mergedProps;
  for (const propName in externalProps) {
    const externalPropValue = externalProps[propName];
    switch (propName) {
      case "style": {
        mergedProps[propName] = mergeObjects(mergedProps.style, externalPropValue);
        break;
      }
      case "className": {
        mergedProps[propName] = mergeClassNames(mergedProps.className, externalPropValue);
        break;
      }
      default:
        isEventHandler(propName, externalPropValue) ? mergedProps[propName] = mergeEventHandlers(mergedProps[propName], externalPropValue) : mergedProps[propName] = externalPropValue;
    }
  }
  return mergedProps;
}
function isEventHandler(key, value) {
  const code0 = key.charCodeAt(0), code1 = key.charCodeAt(1), code2 = key.charCodeAt(2);
  return code0 === 111 && code1 === 110 && code2 >= 65 && code2 <= 90 && (typeof value == "function" || typeof value > "u");
}
function isPropsGetter(inputProps) {
  return typeof inputProps == "function";
}
function resolvePropsGetter(inputProps, previousProps) {
  return isPropsGetter(inputProps) ? inputProps(previousProps) : inputProps ?? EMPTY_PROPS;
}
function mergeEventHandlers(ourHandler, theirHandler) {
  return theirHandler ? ourHandler ? (event) => {
    if (isSyntheticEvent(event)) {
      const baseUIEvent = event;
      makeEventPreventable(baseUIEvent);
      const result2 = theirHandler(baseUIEvent);
      return baseUIEvent.baseUIHandlerPrevented || ourHandler == null || ourHandler(baseUIEvent), result2;
    }
    const result = theirHandler(event);
    return ourHandler == null || ourHandler(event), result;
  } : theirHandler : ourHandler;
}
function makeEventPreventable(event) {
  return event.preventBaseUIHandler = () => {
    event.baseUIHandlerPrevented = !0;
  }, event;
}
function mergeClassNames(ourClassName, theirClassName) {
  return theirClassName ? ourClassName ? theirClassName + " " + ourClassName : theirClassName : ourClassName;
}
function isSyntheticEvent(event) {
  return event != null && typeof event == "object" && "nativeEvent" in event;
}
var define_process_env_default$t = {};
const FormContext = /* @__PURE__ */ React.createContext({
  formRef: {
    current: {
      fields: /* @__PURE__ */ new Map()
    }
  },
  errors: {},
  clearErrors: NOOP
});
define_process_env_default$t.NODE_ENV !== "production" && (FormContext.displayName = "FormContext");
function useFormContext() {
  return React.useContext(FormContext);
}
function getCombinedFieldValidityData(validityData, invalid) {
  return {
    ...validityData,
    state: {
      ...validityData.state,
      valid: !invalid && validityData.state.valid
    }
  };
}
const validityKeys = Object.keys(DEFAULT_VALIDITY_STATE);
function isOnlyValueMissing(state) {
  if (!state || state.valid || !state.valueMissing)
    return !1;
  let onlyValueMissing = !1;
  for (const key of validityKeys)
    key !== "valid" && (key === "valueMissing" && (onlyValueMissing = state[key]), state[key] && (onlyValueMissing = !1));
  return onlyValueMissing;
}
function useFieldControlValidation() {
  const {
    setValidityData,
    validate,
    messageIds,
    validityData,
    validationMode,
    validationDebounceTime,
    invalid,
    markedDirtyRef,
    controlId,
    state,
    name
  } = useFieldRootContext(), {
    formRef,
    clearErrors
  } = useFormContext(), timeout = useTimeout(), inputRef = React.useRef(null), commitValidation = useEventCallback(async (value, revalidate = !1) => {
    const element = inputRef.current;
    if (!element)
      return;
    if (revalidate) {
      if (state.valid !== !1)
        return;
      const currentNativeValidity = element.validity;
      if (!currentNativeValidity.valueMissing) {
        const nextValidityData2 = {
          value,
          state: {
            ...DEFAULT_VALIDITY_STATE,
            valid: !0
          },
          error: "",
          errors: [],
          initialValue: validityData.initialValue
        };
        if (element.setCustomValidity(""), controlId) {
          const currentFieldData = formRef.current.fields.get(controlId);
          currentFieldData && formRef.current.fields.set(controlId, {
            ...currentFieldData,
            ...getCombinedFieldValidityData(nextValidityData2, !1)
            // invalid = false
          });
        }
        setValidityData(nextValidityData2);
        return;
      }
      const currentNativeValidityObject = validityKeys.reduce((acc, key) => (acc[key] = currentNativeValidity[key], acc), {});
      if (!currentNativeValidityObject.valid && !isOnlyValueMissing(currentNativeValidityObject))
        return;
    }
    function getState(el) {
      const computedState = validityKeys.reduce((acc, key) => (acc[key] = el.validity[key], acc), {});
      let hasOnlyValueMissingError = !1;
      for (const key of validityKeys)
        if (key !== "valid") {
          if (key === "valueMissing" && computedState[key])
            hasOnlyValueMissingError = !0;
          else if (computedState[key])
            return computedState;
        }
      return hasOnlyValueMissingError && !markedDirtyRef.current && (computedState.valid = !0, computedState.valueMissing = !1), computedState;
    }
    timeout.clear();
    let result = null, validationErrors = [];
    const nextState = getState(element);
    let defaultValidationMessage;
    if (element.validationMessage)
      defaultValidationMessage = element.validationMessage, validationErrors = [element.validationMessage];
    else {
      const formValues = Array.from(formRef.current.fields.values()).reduce((acc, field) => {
        var _a, _b;
        return field.name && field.getValueRef && (acc[field.name] = (_b = (_a = field.getValueRef).current) == null ? void 0 : _b.call(_a)), acc;
      }, {}), resultOrPromise = validate(value, formValues);
      typeof resultOrPromise == "object" && resultOrPromise !== null && "then" in resultOrPromise ? result = await resultOrPromise : result = resultOrPromise, result !== null && (nextState.valid = !1, nextState.customError = !0, Array.isArray(result) ? (validationErrors = result, element.setCustomValidity(result.join(`
`))) : result && (validationErrors = [result], element.setCustomValidity(result)));
    }
    const nextValidityData = {
      value,
      state: nextState,
      error: defaultValidationMessage ?? (Array.isArray(result) ? result[0] : result ?? ""),
      errors: validationErrors,
      initialValue: validityData.initialValue
    };
    if (controlId) {
      const currentFieldData = formRef.current.fields.get(controlId);
      currentFieldData && formRef.current.fields.set(controlId, {
        ...currentFieldData,
        ...getCombinedFieldValidityData(nextValidityData, invalid)
      });
    }
    setValidityData(nextValidityData);
  }), getValidationProps = React.useCallback((externalProps = {}) => mergeProps({
    ...messageIds.length && {
      "aria-describedby": messageIds.join(" ")
    },
    ...state.valid === !1 && {
      "aria-invalid": !0
    }
  }, externalProps), [messageIds, state.valid]), getInputValidationProps = React.useCallback((externalProps = {}) => mergeProps({
    onChange(event) {
      if (event.nativeEvent.defaultPrevented)
        return;
      if (clearErrors(name), validationMode !== "onChange") {
        commitValidation(event.currentTarget.value, !0);
        return;
      }
      if (invalid)
        return;
      const element = event.currentTarget;
      if (element.value === "") {
        commitValidation(element.value);
        return;
      }
      timeout.clear(), validationDebounceTime ? timeout.start(validationDebounceTime, () => {
        commitValidation(element.value);
      }) : commitValidation(element.value);
    }
  }, getValidationProps(externalProps)), [getValidationProps, clearErrors, name, timeout, commitValidation, invalid, validationMode, validationDebounceTime]);
  return React.useMemo(() => ({
    getValidationProps,
    getInputValidationProps,
    inputRef,
    commitValidation
  }), [getValidationProps, getInputValidationProps, commitValidation]);
}
function useBaseUiId(idOverride) {
  return useId(idOverride, "base-ui");
}
function useTransitionStatus(open, enableIdleState = !1, deferEndingState = !1) {
  const [transitionStatus, setTransitionStatus] = React.useState(open && enableIdleState ? "idle" : void 0), [mounted, setMounted] = React.useState(open);
  return open && !mounted && (setMounted(!0), setTransitionStatus("starting")), !open && mounted && transitionStatus !== "ending" && !deferEndingState && setTransitionStatus("ending"), !open && !mounted && transitionStatus === "ending" && setTransitionStatus(void 0), useIsoLayoutEffect(() => {
    if (!open && mounted && transitionStatus !== "ending" && deferEndingState) {
      const frame = AnimationFrame.request(() => {
        setTransitionStatus("ending");
      });
      return () => {
        AnimationFrame.cancel(frame);
      };
    }
  }, [open, mounted, transitionStatus, deferEndingState]), useIsoLayoutEffect(() => {
    if (!open || enableIdleState)
      return;
    const frame = AnimationFrame.request(() => {
      ReactDOM.flushSync(() => {
        setTransitionStatus(void 0);
      });
    });
    return () => {
      AnimationFrame.cancel(frame);
    };
  }, [enableIdleState, open]), useIsoLayoutEffect(() => {
    if (!open || !enableIdleState)
      return;
    open && mounted && transitionStatus !== "idle" && setTransitionStatus("starting");
    const frame = AnimationFrame.request(() => {
      setTransitionStatus("idle");
    });
    return () => {
      AnimationFrame.cancel(frame);
    };
  }, [enableIdleState, open, mounted, setTransitionStatus, transitionStatus]), React.useMemo(() => ({
    mounted,
    setMounted,
    transitionStatus
  }), [mounted, transitionStatus]);
}
const selectors = {
  id: createSelector((state) => state.id),
  modal: createSelector((state) => state.modal),
  multiple: createSelector((state) => state.multiple),
  items: createSelector((state) => state.items),
  value: createSelector((state) => state.value),
  label: createSelector((state) => state.label),
  open: createSelector((state) => state.open),
  mounted: createSelector((state) => state.mounted),
  forceMount: createSelector((state) => state.forceMount),
  transitionStatus: createSelector((state) => state.transitionStatus),
  touchModality: createSelector((state) => state.touchModality),
  activeIndex: createSelector((state) => state.activeIndex),
  selectedIndex: createSelector((state) => state.selectedIndex),
  isActive: createSelector((state, index2) => state.activeIndex === index2),
  isSelected: createSelector((state, index2, value) => state.multiple ? Array.isArray(state.value) && state.value.includes(value) : state.selectedIndex === index2 || state.value === value),
  isSelectedByFocus: createSelector((state, index2) => state.selectedIndex === index2),
  popupProps: createSelector((state) => state.popupProps),
  triggerProps: createSelector((state) => state.triggerProps),
  triggerElement: createSelector((state) => state.triggerElement),
  positionerElement: createSelector((state) => state.positionerElement),
  scrollUpArrowVisible: createSelector((state) => state.scrollUpArrowVisible),
  scrollDownArrowVisible: createSelector((state) => state.scrollDownArrowVisible)
};
function translateOpenChangeReason(nativeReason) {
  if (nativeReason)
    return {
      // Identical mappings
      "focus-out": "focus-out",
      "escape-key": "escape-key",
      "outside-press": "outside-press",
      "list-navigation": "list-navigation",
      // New mappings
      click: "trigger-press",
      hover: "trigger-hover",
      focus: "trigger-focus",
      "reference-press": "trigger-press",
      "safe-polygon": "trigger-hover",
      "ancestor-scroll": void 0
      // Not supported
    }[nativeReason];
}
function useAnimationsFinished(elementOrRef, waitForNextTick = !1) {
  const frame = useAnimationFrame();
  return useEventCallback((fnToExecute, signal = null) => {
    if (frame.cancel(), elementOrRef == null)
      return;
    let element;
    if ("current" in elementOrRef) {
      if (elementOrRef.current == null)
        return;
      element = elementOrRef.current;
    } else
      element = elementOrRef;
    typeof element.getAnimations != "function" || globalThis.BASE_UI_ANIMATIONS_DISABLED ? fnToExecute() : frame.request(() => {
      function exec() {
        element && Promise.allSettled(element.getAnimations().map((anim) => anim.finished)).then(() => {
          signal != null && signal.aborted || ReactDOM.flushSync(fnToExecute);
        });
      }
      waitForNextTick ? frame.request(exec) : exec();
    });
  });
}
function useOpenChangeComplete(parameters) {
  const {
    enabled = !0,
    open,
    ref,
    onComplete: onCompleteParam
  } = parameters, openRef = useLatestRef(open), onComplete = useEventCallback(onCompleteParam), runOnceAnimationsFinish = useAnimationsFinished(ref, open);
  React.useEffect(() => {
    enabled && runOnceAnimationsFinish(() => {
      open === openRef.current && onComplete();
    });
  }, [enabled, open, onComplete, runOnceAnimationsFinish, openRef]);
}
function useField(params) {
  const {
    formRef
  } = useFormContext(), {
    invalid,
    markedDirtyRef,
    validityData,
    setValidityData
  } = useFieldRootContext(), {
    enabled = !0,
    value,
    id,
    name,
    controlRef,
    commitValidation
  } = params, getValueRef = useLatestRef(params.getValue);
  useIsoLayoutEffect(() => {
    var _a;
    if (!enabled)
      return;
    let initialValue = value;
    initialValue === void 0 && (initialValue = (_a = getValueRef.current) == null ? void 0 : _a.call(getValueRef)), validityData.initialValue === null && initialValue !== validityData.initialValue && setValidityData((prev) => ({
      ...prev,
      initialValue
    }));
  }, [enabled, setValidityData, value, validityData.initialValue, getValueRef]), useIsoLayoutEffect(() => {
    enabled && id && formRef.current.fields.set(id, {
      controlRef,
      validityData: getCombinedFieldValidityData(validityData, invalid),
      validate() {
        var _a;
        let nextValue = value;
        nextValue === void 0 && (nextValue = (_a = getValueRef.current) == null ? void 0 : _a.call(getValueRef)), markedDirtyRef.current = !0, ReactDOM.flushSync(() => commitValidation(nextValue));
      },
      getValueRef,
      name
    });
  }, [commitValidation, controlRef, enabled, formRef, getValueRef, id, invalid, markedDirtyRef, name, validityData, value]), useIsoLayoutEffect(() => {
    const fields = formRef.current.fields;
    return () => {
      id && fields.delete(id);
    };
  }, [formRef, id]);
}
var define_process_env_default$s = {};
function useSelectRoot(params) {
  const {
    id: idProp,
    disabled: disabledProp = !1,
    readOnly = !1,
    required = !1,
    modal = !1,
    name: nameProp,
    onOpenChangeComplete,
    items,
    multiple = !1
  } = params, {
    clearErrors
  } = useFormContext(), {
    setDirty,
    validityData,
    validationMode,
    setControlId,
    setFilled,
    name: fieldName,
    disabled: fieldDisabled
  } = useFieldRootContext(), fieldControlValidation = useFieldControlValidation(), id = useBaseUiId(idProp), disabled = fieldDisabled || disabledProp, name = fieldName ?? nameProp;
  useIsoLayoutEffect(() => (setControlId(id), () => {
    setControlId(void 0);
  }), [id, setControlId]);
  const [value, setValueUnwrapped] = useControlled({
    controlled: params.value,
    default: multiple ? params.defaultValue ?? EMPTY_ARRAY : params.defaultValue,
    name: "Select",
    state: "value"
  }), [open, setOpenUnwrapped] = useControlled({
    controlled: params.open,
    default: params.defaultOpen,
    name: "Select",
    state: "open"
  }), listRef = React.useRef([]), labelsRef = React.useRef([]), popupRef = React.useRef(null), valueRef = React.useRef(null), valuesRef = React.useRef([]), typingRef = React.useRef(!1), keyboardActiveRef = React.useRef(!1), selectedItemTextRef = React.useRef(null), lastSelectedIndexRef = React.useRef(null), selectionRef = React.useRef({
    allowSelectedMouseUp: !1,
    allowUnselectedMouseUp: !1,
    allowSelect: !1
  }), hasRegisteredRef = React.useRef(!1), alignItemWithTriggerActiveRef = React.useRef(!1), highlightTimeout = useTimeout(), {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open), store = useRefWithInit(() => new Store({
    id,
    modal,
    multiple,
    value,
    label: "",
    open,
    mounted,
    forceMount: !1,
    transitionStatus,
    items,
    touchModality: !1,
    activeIndex: null,
    selectedIndex: null,
    popupProps: {},
    triggerProps: {},
    triggerElement: null,
    positionerElement: null,
    scrollUpArrowVisible: !1,
    scrollDownArrowVisible: !1
  })).current, initialValueRef = React.useRef(value);
  useIsoLayoutEffect(() => {
    value !== initialValueRef.current && store.set("forceMount", !0);
  }, [store, value]);
  const activeIndex = useStore(store, selectors.activeIndex), selectedIndex = useStore(store, selectors.selectedIndex), triggerElement = useStore(store, selectors.triggerElement), positionerElement = useStore(store, selectors.positionerElement), controlRef = useLatestRef(store.state.triggerElement), commitValidation = fieldControlValidation.commitValidation;
  useField({
    id,
    commitValidation,
    value,
    controlRef,
    name,
    getValue: () => value
  });
  const prevValueRef = React.useRef(value);
  useIsoLayoutEffect(() => {
    setFilled(value !== null);
  }, [value, setFilled]), useIsoLayoutEffect(() => {
    if (prevValueRef.current !== value) {
      if (multiple) {
        const currentValue = Array.isArray(value) ? value : [], labels = currentValue.map((v2) => {
          const index2 = valuesRef.current.indexOf(v2);
          return index2 !== -1 ? labelsRef.current[index2] ?? "" : "";
        }).filter(Boolean), lastValue = currentValue[currentValue.length - 1], lastIndex = lastValue != null ? valuesRef.current.indexOf(lastValue) : -1;
        lastSelectedIndexRef.current = lastIndex === -1 ? null : lastIndex, store.apply({
          label: labels.join(", ")
        });
      } else {
        const index2 = valuesRef.current.indexOf(value);
        store.apply({
          selectedIndex: index2 === -1 ? null : index2,
          label: labelsRef.current[index2] ?? ""
        });
      }
      clearErrors(name), setDirty(value !== validityData.initialValue), commitValidation(value, validationMode !== "onChange"), validationMode === "onChange" && commitValidation(value);
    }
  }, [value, commitValidation, clearErrors, name, validationMode, store, setDirty, validityData.initialValue, setFilled, multiple]), useIsoLayoutEffect(() => {
    prevValueRef.current = value;
  }, [value]);
  const setOpen = useEventCallback((nextOpen, event, reason) => {
    var _a;
    if ((_a = params.onOpenChange) == null || _a.call(params, nextOpen, event, reason), setOpenUnwrapped(nextOpen), !nextOpen && multiple && store.set("selectedIndex", lastSelectedIndexRef.current), !nextOpen && store.state.activeIndex !== null) {
      const activeOption = listRef.current[store.state.activeIndex];
      queueMicrotask(() => {
        activeOption == null || activeOption.setAttribute("tabindex", "-1");
      });
    }
  }), handleUnmount = useEventCallback(() => {
    setMounted(!1), store.set("activeIndex", null), onOpenChangeComplete == null || onOpenChangeComplete(!1);
  });
  useOpenChangeComplete({
    enabled: !params.actionsRef,
    open,
    ref: popupRef,
    onComplete() {
      open || handleUnmount();
    }
  }), React.useImperativeHandle(params.actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  const setValue = useEventCallback((nextValue, event) => {
    var _a;
    (_a = params.onValueChange) == null || _a.call(params, nextValue, event), setValueUnwrapped(nextValue);
  }), syncSelectedState = useEventCallback(() => {
    if (hasRegisteredRef.current)
      if (multiple) {
        const currentValue = Array.isArray(value) ? value : [], labels = currentValue.map((v2) => {
          const index2 = valuesRef.current.indexOf(v2);
          return index2 !== -1 ? labelsRef.current[index2] ?? "" : "";
        }).filter(Boolean), lastValue = currentValue[currentValue.length - 1], lastIndex = lastValue !== void 0 ? valuesRef.current.indexOf(lastValue) : -1;
        lastSelectedIndexRef.current = lastIndex === -1 ? null : lastIndex;
        let computedSelectedIndex = store.state.selectedIndex;
        computedSelectedIndex === null && (computedSelectedIndex = lastIndex === -1 ? null : lastIndex), store.apply({
          selectedIndex: computedSelectedIndex,
          label: labels.join(", ")
        });
      } else {
        const index2 = valuesRef.current.indexOf(value), hasIndex = index2 !== -1;
        if (hasIndex || value === null) {
          store.apply({
            selectedIndex: hasIndex ? index2 : null,
            label: hasIndex ? labelsRef.current[index2] ?? "" : ""
          });
          return;
        }
        if (define_process_env_default$s.NODE_ENV !== "production" && value) {
          const stringValue = typeof value == "string" || value === null ? value : JSON.stringify(value);
          warn(`The value \`${stringValue}\` is not present in the select items.`);
        }
      }
  }), registerItemIndex = useEventCallback((index2) => {
    hasRegisteredRef.current = !0, multiple && (lastSelectedIndexRef.current = index2), syncSelectedState();
  });
  useIsoLayoutEffect(syncSelectedState, [value, syncSelectedState]);
  const floatingContext = useFloatingRootContext({
    open,
    onOpenChange(nextOpen, event, reason) {
      setOpen(nextOpen, event, translateOpenChangeReason(reason));
    },
    elements: {
      reference: triggerElement,
      floating: positionerElement
    }
  }), click = useClick(floatingContext, {
    enabled: !readOnly && !disabled,
    event: "mousedown"
  }), dismiss = useDismiss(floatingContext, {
    bubbles: !1
  }), role = useRole(floatingContext, {
    role: "select"
  }), listNavigation = useListNavigation(floatingContext, {
    enabled: !readOnly && !disabled,
    listRef,
    activeIndex,
    selectedIndex,
    disabledIndices: EMPTY_ARRAY,
    onNavigate(nextActiveIndex) {
      nextActiveIndex === null && !open || store.set("activeIndex", nextActiveIndex);
    },
    // Implement our own listeners since `onPointerLeave` on each option fires while scrolling with
    // the `alignItemWithTrigger=true`, causing a performance issue on Chrome.
    focusItemOnHover: !1
  }), typeahead = useTypeahead(floatingContext, {
    enabled: !readOnly && !disabled && (open || !multiple),
    listRef: labelsRef,
    activeIndex,
    selectedIndex,
    onMatch(index2) {
      open ? store.set("activeIndex", index2) : setValue(valuesRef.current[index2]);
    },
    onTypingChange(typing) {
      typingRef.current = typing;
    }
  }), {
    getReferenceProps,
    getFloatingProps,
    getItemProps
  } = useInteractions([click, dismiss, role, listNavigation, typeahead]);
  return useOnFirstRender(() => {
    store.apply({
      popupProps: getFloatingProps(),
      triggerProps: getReferenceProps()
    });
  }), React.useEffect(() => {
    store.apply({
      id,
      modal,
      multiple,
      value,
      open,
      mounted,
      transitionStatus,
      popupProps: getFloatingProps(),
      triggerProps: getReferenceProps()
    });
  }, [store, id, modal, multiple, value, open, mounted, transitionStatus, getFloatingProps, getReferenceProps]), {
    rootContext: React.useMemo(() => ({
      store,
      name,
      required,
      disabled,
      readOnly,
      multiple,
      setValue,
      setOpen,
      listRef,
      popupRef,
      getItemProps,
      events: floatingContext.events,
      valueRef,
      valuesRef,
      labelsRef,
      typingRef,
      selectionRef,
      selectedItemTextRef,
      fieldControlValidation,
      registerItemIndex,
      onOpenChangeComplete,
      keyboardActiveRef,
      alignItemWithTriggerActiveRef,
      highlightTimeout
    }), [store, name, required, disabled, readOnly, multiple, setValue, setOpen, listRef, popupRef, getItemProps, floatingContext.events, valueRef, valuesRef, labelsRef, typingRef, selectionRef, selectedItemTextRef, fieldControlValidation, registerItemIndex, onOpenChangeComplete, keyboardActiveRef, alignItemWithTriggerActiveRef, highlightTimeout]),
    floatingContext,
    value
  };
}
var define_process_env_default$r = {};
const SelectRootContext = /* @__PURE__ */ React.createContext(null);
define_process_env_default$r.NODE_ENV !== "production" && (SelectRootContext.displayName = "SelectRootContext");
const SelectFloatingContext = /* @__PURE__ */ React.createContext(null);
define_process_env_default$r.NODE_ENV !== "production" && (SelectFloatingContext.displayName = "SelectFloatingContext");
function useSelectRootContext() {
  const context = React.useContext(SelectRootContext);
  if (context === null)
    throw new Error("Base UI: SelectRootContext is missing. Select parts must be placed within <Select.Root>.");
  return context;
}
function useSelectFloatingContext() {
  const context = React.useContext(SelectFloatingContext);
  if (context === null)
    throw new Error("Base UI: SelectFloatingContext is missing. Select parts must be placed within <Select.Root>.");
  return context;
}
function serializeValue(value) {
  if (value == null)
    return "";
  if (typeof value == "string")
    return value;
  try {
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}
function SelectRoot(props) {
  const {
    id,
    value: valueProp,
    defaultValue = null,
    onValueChange,
    open,
    defaultOpen = !1,
    onOpenChange,
    name,
    disabled = !1,
    readOnly = !1,
    required = !1,
    modal = !0,
    actionsRef,
    inputRef,
    onOpenChangeComplete,
    items,
    multiple,
    children
  } = props, {
    rootContext,
    floatingContext,
    value
  } = useSelectRoot({
    id,
    value: valueProp,
    defaultValue,
    onValueChange,
    open,
    defaultOpen,
    onOpenChange,
    name,
    disabled,
    readOnly,
    required,
    modal,
    actionsRef,
    onOpenChangeComplete,
    items,
    multiple
  }), store = rootContext.store, isMultiple = multiple ?? !1, {
    setDirty,
    validityData,
    validationMode,
    controlId
  } = useFieldRootContext(), ref = useMergedRefs(inputRef, rootContext.fieldControlValidation.inputRef), serializedValue = React.useMemo(() => isMultiple && Array.isArray(value) && value.length === 0 ? "" : serializeValue(value), [isMultiple, value]), hiddenInputs = React.useMemo(() => !isMultiple || !Array.isArray(value) || !rootContext.name ? null : value.map((v2) => {
    const currentSerializedValue = serializeValue(v2);
    return /* @__PURE__ */ jsx("input", {
      type: "hidden",
      name: rootContext.name,
      value: currentSerializedValue
    }, currentSerializedValue);
  }), [isMultiple, value, rootContext.name]);
  return /* @__PURE__ */ jsx(SelectRootContext.Provider, {
    value: rootContext,
    children: /* @__PURE__ */ jsxs(SelectFloatingContext.Provider, {
      value: floatingContext,
      children: [children, /* @__PURE__ */ jsx("input", {
        ...rootContext.fieldControlValidation.getInputValidationProps({
          onFocus() {
            var _a;
            (_a = store.state.triggerElement) == null || _a.focus();
          },
          // Handle browser autofill.
          onChange(event) {
            if (event.nativeEvent.defaultPrevented)
              return;
            const nextValue = event.target.value;
            store.set("forceMount", !0), queueMicrotask(() => {
              var _a;
              if (!isMultiple) {
                const exactValue = rootContext.valuesRef.current.find((v2) => v2 === nextValue || typeof value == "string" && nextValue.toLowerCase() === v2.toLowerCase());
                exactValue != null && (setDirty(exactValue !== validityData.initialValue), (_a = rootContext.setValue) == null || _a.call(rootContext, exactValue, event.nativeEvent), validationMode === "onChange" && rootContext.fieldControlValidation.commitValidation(exactValue));
              }
            });
          },
          id: id || controlId || void 0,
          name: isMultiple ? void 0 : rootContext.name,
          value: serializedValue,
          disabled: rootContext.disabled,
          required: rootContext.required,
          readOnly: rootContext.readOnly,
          ref,
          style: visuallyHidden,
          tabIndex: -1,
          "aria-hidden": !0
        })
      }), hiddenInputs]
    })
  });
}
function ownerDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
let TransitionStatusDataAttributes = /* @__PURE__ */ (function(TransitionStatusDataAttributes2) {
  return TransitionStatusDataAttributes2.startingStyle = "data-starting-style", TransitionStatusDataAttributes2.endingStyle = "data-ending-style", TransitionStatusDataAttributes2;
})({});
const STARTING_HOOK = {
  [TransitionStatusDataAttributes.startingStyle]: ""
}, ENDING_HOOK = {
  [TransitionStatusDataAttributes.endingStyle]: ""
}, transitionStatusMapping = {
  transitionStatus(value) {
    return value === "starting" ? STARTING_HOOK : value === "ending" ? ENDING_HOOK : null;
  }
};
let CommonPopupDataAttributes = (function(CommonPopupDataAttributes2) {
  return CommonPopupDataAttributes2.open = "data-open", CommonPopupDataAttributes2.closed = "data-closed", CommonPopupDataAttributes2[CommonPopupDataAttributes2.startingStyle = TransitionStatusDataAttributes.startingStyle] = "startingStyle", CommonPopupDataAttributes2[CommonPopupDataAttributes2.endingStyle = TransitionStatusDataAttributes.endingStyle] = "endingStyle", CommonPopupDataAttributes2.anchorHidden = "data-anchor-hidden", CommonPopupDataAttributes2;
})({}), CommonTriggerDataAttributes = /* @__PURE__ */ (function(CommonTriggerDataAttributes2) {
  return CommonTriggerDataAttributes2.popupOpen = "data-popup-open", CommonTriggerDataAttributes2.pressed = "data-pressed", CommonTriggerDataAttributes2;
})({});
const TRIGGER_HOOK = {
  [CommonTriggerDataAttributes.popupOpen]: ""
}, PRESSABLE_TRIGGER_HOOK = {
  [CommonTriggerDataAttributes.popupOpen]: "",
  [CommonTriggerDataAttributes.pressed]: ""
}, POPUP_OPEN_HOOK = {
  [CommonPopupDataAttributes.open]: ""
}, POPUP_CLOSED_HOOK = {
  [CommonPopupDataAttributes.closed]: ""
}, ANCHOR_HIDDEN_HOOK = {
  [CommonPopupDataAttributes.anchorHidden]: ""
}, triggerOpenStateMapping = {
  open(value) {
    return value ? TRIGGER_HOOK : null;
  }
}, pressableTriggerOpenStateMapping = {
  open(value) {
    return value ? PRESSABLE_TRIGGER_HOOK : null;
  }
}, popupStateMapping = {
  open(value) {
    return value ? POPUP_OPEN_HOOK : POPUP_CLOSED_HOOK;
  },
  anchorHidden(value) {
    return value ? ANCHOR_HIDDEN_HOOK : null;
  }
}, majorVersion = parseInt(React.version, 10);
function isReactVersionAtLeast(reactVersionToCheck) {
  return majorVersion >= reactVersionToCheck;
}
function getStyleHookProps(state, customMapping) {
  const props = {};
  for (const key in state) {
    const value = state[key];
    if (customMapping != null && customMapping.hasOwnProperty(key)) {
      const customProps = customMapping[key](value);
      customProps != null && Object.assign(props, customProps);
      continue;
    }
    value === !0 ? props[`data-${key.toLowerCase()}`] = "" : value && (props[`data-${key.toLowerCase()}`] = value.toString());
  }
  return props;
}
function resolveClassName(className, state) {
  return typeof className == "function" ? className(state) : className;
}
function useRenderElement(element, componentProps, params = {}) {
  const renderProp = componentProps.render, outProps = useRenderElementProps(componentProps, params);
  if (params.enabled === !1)
    return null;
  const state = params.state ?? EMPTY_OBJECT;
  return evaluateRenderProp(element, renderProp, outProps, state);
}
function useRenderElementProps(componentProps, params = {}) {
  const {
    className: classNameProp,
    render: renderProp
  } = componentProps, {
    state = EMPTY_OBJECT,
    ref,
    props,
    disableStyleHooks,
    customStyleHookMapping: customStyleHookMapping2,
    enabled = !0
  } = params, className = enabled ? resolveClassName(classNameProp, state) : void 0;
  let styleHooks;
  disableStyleHooks !== !0 && (styleHooks = React.useMemo(() => enabled ? getStyleHookProps(state, customStyleHookMapping2) : EMPTY_OBJECT, [state, customStyleHookMapping2, enabled]));
  const outProps = enabled ? mergeObjects(styleHooks, Array.isArray(props) ? mergePropsN(props) : props) ?? EMPTY_OBJECT : EMPTY_OBJECT;
  return typeof document < "u" && (enabled ? Array.isArray(ref) ? outProps.ref = useMergedRefsN([outProps.ref, getChildRef(renderProp), ...ref]) : outProps.ref = useMergedRefs(outProps.ref, getChildRef(renderProp), ref) : useMergedRefs(null, null)), enabled ? (className !== void 0 && (outProps.className = mergeClassNames(outProps.className, className)), outProps) : EMPTY_OBJECT;
}
function evaluateRenderProp(element, render, props, state) {
  if (render) {
    if (typeof render == "function")
      return render(props, state);
    const mergedProps = mergeProps(props, render.props);
    return mergedProps.ref = props.ref, /* @__PURE__ */ React.cloneElement(render, mergedProps);
  }
  if (element && typeof element == "string")
    return renderTag(element, props);
  throw new Error("Base UI: Render element or function are not defined.");
}
function renderTag(Tag, props) {
  return Tag === "button" ? /* @__PURE__ */ jsx("button", {
    type: "button",
    ...props
  }) : Tag === "img" ? /* @__PURE__ */ jsx("img", {
    alt: "",
    ...props
  }) : /* @__PURE__ */ React.createElement(Tag, props);
}
function getChildRef(render) {
  return render && typeof render != "function" ? isReactVersionAtLeast(19) ? render.props.ref : render.ref : null;
}
var define_process_env_default$q = {};
function getPseudoElementBounds(element) {
  const elementRect = element.getBoundingClientRect();
  if (define_process_env_default$q.NODE_ENV === "test")
    return elementRect;
  const beforeStyles = window.getComputedStyle(element, "::before"), afterStyles = window.getComputedStyle(element, "::after");
  if (!(beforeStyles.content !== "none" || afterStyles.content !== "none"))
    return elementRect;
  const beforeWidth = parseFloat(beforeStyles.width) || 0, beforeHeight = parseFloat(beforeStyles.height) || 0, afterWidth = parseFloat(afterStyles.width) || 0, afterHeight = parseFloat(afterStyles.height) || 0, totalWidth = Math.max(elementRect.width, beforeWidth, afterWidth), totalHeight = Math.max(elementRect.height, beforeHeight, afterHeight), widthDiff = totalWidth - elementRect.width, heightDiff = totalHeight - elementRect.height;
  return {
    left: elementRect.left - widthDiff / 2,
    right: elementRect.right + widthDiff / 2,
    top: elementRect.top - heightDiff / 2,
    bottom: elementRect.bottom + heightDiff / 2
  };
}
var define_process_env_default$p = {};
let set;
define_process_env_default$p.NODE_ENV !== "production" && (set = /* @__PURE__ */ new Set());
function error(...messages) {
  if (define_process_env_default$p.NODE_ENV !== "production") {
    const messageKey = messages.join(" ");
    set.has(messageKey) || (set.add(messageKey), console.error(`Base UI: ${messageKey}`));
  }
}
var define_process_env_default$o = {};
const CompositeRootContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$o.NODE_ENV !== "production" && (CompositeRootContext.displayName = "CompositeRootContext");
function useCompositeRootContext(optional = !1) {
  const context = React.useContext(CompositeRootContext);
  if (context === void 0 && !optional)
    throw new Error("Base UI: CompositeRootContext is missing. Composite parts must be placed within <Composite.Root>.");
  return context;
}
function useFocusableWhenDisabled(parameters) {
  const {
    focusableWhenDisabled,
    disabled,
    composite = !1,
    tabIndex: tabIndexProp = 0,
    isNativeButton
  } = parameters, isFocusableComposite = composite && focusableWhenDisabled !== !1, isNonFocusableComposite = composite && focusableWhenDisabled === !1;
  return {
    props: React.useMemo(() => {
      const additionalProps = {
        // allow Tabbing away from focusableWhenDisabled elements
        onKeyDown(event) {
          disabled && focusableWhenDisabled && event.key !== "Tab" && event.preventDefault();
        }
      };
      return composite || (additionalProps.tabIndex = tabIndexProp, !isNativeButton && disabled && (additionalProps.tabIndex = focusableWhenDisabled ? tabIndexProp : -1)), (isNativeButton && (focusableWhenDisabled || isFocusableComposite) || !isNativeButton && disabled) && (additionalProps["aria-disabled"] = disabled), isNativeButton && (!focusableWhenDisabled || isNonFocusableComposite) && (additionalProps.disabled = disabled), additionalProps;
    }, [composite, disabled, focusableWhenDisabled, isFocusableComposite, isNonFocusableComposite, isNativeButton, tabIndexProp])
  };
}
var define_process_env_default$n = {};
function useButton(parameters = {}) {
  const {
    disabled = !1,
    focusableWhenDisabled,
    tabIndex = 0,
    native: isNativeButton = !0
  } = parameters, buttonRef = React.useRef(null), isCompositeItem = useCompositeRootContext(!0) !== void 0, isValidLink = useEventCallback(() => {
    const element = buttonRef.current;
    return !!((element == null ? void 0 : element.tagName) === "A" && (element != null && element.href));
  }), {
    props: focusableWhenDisabledProps
  } = useFocusableWhenDisabled({
    focusableWhenDisabled,
    disabled,
    composite: isCompositeItem,
    tabIndex,
    isNativeButton
  });
  return define_process_env_default$n.NODE_ENV !== "production" && React.useEffect(() => {
    if (!buttonRef.current)
      return;
    const isButtonTag = buttonRef.current.tagName === "BUTTON";
    isNativeButton ? isButtonTag || error("A component that acts as a button was not rendered as a native <button>, which does not match the default. Ensure that the element passed to the `render` prop of the component is a real <button>, or set the `nativeButton` prop on the component to `false`.") : isButtonTag && error("A component that acts as a button was rendered as a native <button>, which does not match the default. Ensure that the element passed to the `render` prop of the component is not a real <button>, or set the `nativeButton` prop on the component to `true`.");
  }, [isNativeButton]), useIsoLayoutEffect(() => {
    const element = buttonRef.current;
    element instanceof HTMLButtonElement && isCompositeItem && disabled && focusableWhenDisabledProps.disabled === void 0 && element.disabled && (element.disabled = !1);
  }, [disabled, focusableWhenDisabledProps.disabled, isCompositeItem]), {
    getButtonProps: React.useCallback((externalProps = {}) => {
      const {
        onClick: externalOnClick,
        onMouseDown: externalOnMouseDown,
        onKeyUp: externalOnKeyUp,
        onKeyDown: externalOnKeyDown,
        onPointerDown: externalOnPointerDown,
        ...otherExternalProps
      } = externalProps;
      return mergeProps({
        type: isNativeButton ? "button" : void 0,
        onClick(event) {
          if (disabled) {
            event.preventDefault();
            return;
          }
          externalOnClick == null || externalOnClick(event);
        },
        onMouseDown(event) {
          disabled || externalOnMouseDown == null || externalOnMouseDown(event);
        },
        onKeyDown(event) {
          if (disabled || (makeEventPreventable(event), externalOnKeyDown == null || externalOnKeyDown(event)), event.baseUIHandlerPrevented)
            return;
          const shouldClick = event.target === event.currentTarget && !isNativeButton && !isValidLink() && !disabled, isEnterKey = event.key === "Enter", isSpaceKey = event.key === " ";
          shouldClick && ((isSpaceKey || isEnterKey) && event.preventDefault(), isEnterKey && (externalOnClick == null || externalOnClick(event)));
        },
        onKeyUp(event) {
          disabled || (makeEventPreventable(event), externalOnKeyUp == null || externalOnKeyUp(event)), !event.baseUIHandlerPrevented && event.target === event.currentTarget && !isNativeButton && !disabled && event.key === " " && (externalOnClick == null || externalOnClick(event));
        },
        onPointerDown(event) {
          if (disabled) {
            event.preventDefault();
            return;
          }
          externalOnPointerDown == null || externalOnPointerDown(event);
        }
      }, isNativeButton ? void 0 : {
        role: "button"
      }, focusableWhenDisabledProps, otherExternalProps);
    }, [disabled, focusableWhenDisabledProps, isNativeButton, isValidLink]),
    buttonRef
  };
}
var define_process_env_default$m = {};
const BOUNDARY_OFFSET = 2, customStyleHookMapping$3 = {
  ...pressableTriggerOpenStateMapping,
  ...fieldValidityMapping,
  value: () => null
}, SelectTrigger = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = !1,
    nativeButton = !1,
    ...elementProps
  } = componentProps, {
    state: fieldState,
    disabled: fieldDisabled
  } = useFieldRootContext(), {
    store,
    setOpen,
    selectionRef,
    fieldControlValidation,
    readOnly,
    alignItemWithTriggerActiveRef,
    disabled: selectDisabled,
    keyboardActiveRef
  } = useSelectRootContext(), disabled = fieldDisabled || selectDisabled || disabledProp, open = useStore(store, selectors.open), value = useStore(store, selectors.value), triggerProps = useStore(store, selectors.triggerProps), positionerElement = useStore(store, selectors.positionerElement), positionerRef = useLatestRef(positionerElement), {
    labelId,
    setTouched,
    setFocused,
    validationMode
  } = useFieldRootContext(), triggerRef = React.useRef(null), timeoutFocus = useTimeout(), timeoutMouseDown = useTimeout(), {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  }), setTriggerElement = useEventCallback((element) => {
    store.set("triggerElement", element);
  }), mergedRef = useMergedRefs(forwardedRef, triggerRef, buttonRef, setTriggerElement), timeout1 = useTimeout(), timeout2 = useTimeout();
  React.useEffect(() => {
    if (open)
      return timeout2.start(200, () => {
        selectionRef.current.allowUnselectedMouseUp = !0, timeout1.start(200, () => {
          selectionRef.current.allowSelectedMouseUp = !0;
        });
      }), () => {
        timeout1.clear(), timeout2.clear();
      };
    selectionRef.current = {
      allowSelectedMouseUp: !1,
      allowUnselectedMouseUp: !1,
      allowSelect: !0
    }, timeoutMouseDown.clear();
  }, [open, selectionRef, timeoutMouseDown, timeout1, timeout2]);
  const props = mergeProps(triggerProps, {
    "aria-labelledby": labelId,
    "aria-readonly": readOnly || void 0,
    tabIndex: disabled ? -1 : 0,
    ref: mergedRef,
    onFocus(event) {
      setFocused(!0), open && alignItemWithTriggerActiveRef.current && setOpen(!1, event.nativeEvent, "focus-out"), timeoutFocus.start(0, () => {
        store.set("forceMount", !0);
      });
    },
    onBlur() {
      setTouched(!0), setFocused(!1), validationMode === "onBlur" && fieldControlValidation.commitValidation(value);
    },
    onPointerMove({
      pointerType
    }) {
      keyboardActiveRef.current = !1, store.set("touchModality", pointerType === "touch");
    },
    onPointerDown({
      pointerType
    }) {
      store.set("touchModality", pointerType === "touch");
    },
    onKeyDown(event) {
      keyboardActiveRef.current = !0, event.key === "ArrowDown" && setOpen(!0, event.nativeEvent, "list-navigation");
    },
    onMouseDown(event) {
      if (open)
        return;
      const doc = ownerDocument(event.currentTarget);
      function handleMouseUp(mouseEvent) {
        if (!triggerRef.current)
          return;
        const mouseUpTarget = mouseEvent.target;
        if (contains(triggerRef.current, mouseUpTarget) || contains(positionerRef.current, mouseUpTarget) || mouseUpTarget === triggerRef.current)
          return;
        const bounds = getPseudoElementBounds(triggerRef.current);
        mouseEvent.clientX >= bounds.left - BOUNDARY_OFFSET && mouseEvent.clientX <= bounds.right + BOUNDARY_OFFSET && mouseEvent.clientY >= bounds.top - BOUNDARY_OFFSET && mouseEvent.clientY <= bounds.bottom + BOUNDARY_OFFSET || setOpen(!1, mouseEvent, "cancel-open");
      }
      timeoutMouseDown.start(0, () => {
        doc.addEventListener("mouseup", handleMouseUp, {
          once: !0
        });
      });
    }
  }, fieldControlValidation.getValidationProps, elementProps, getButtonProps);
  props.role = "combobox";
  const state = React.useMemo(() => ({
    ...fieldState,
    open,
    disabled,
    value,
    readOnly
  }), [fieldState, open, disabled, readOnly, value]);
  return useRenderElement("div", componentProps, {
    ref: [forwardedRef, triggerRef],
    state,
    customStyleHookMapping: customStyleHookMapping$3,
    props
  });
});
define_process_env_default$m.NODE_ENV !== "production" && (SelectTrigger.displayName = "SelectTrigger");
var define_process_env_default$l = {};
const customStyleHookMapping$2 = {
  value: () => null
}, SelectValue = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    className,
    render,
    children: childrenProp,
    ...elementProps
  } = componentProps, {
    store,
    valueRef
  } = useSelectRootContext(), value = useStore(store, selectors.value), items = useStore(store, selectors.items), isChildrenPropFunction = typeof childrenProp == "function", labelFromItems = React.useMemo(() => {
    var _a;
    if (!isChildrenPropFunction) {
      if (Array.isArray(value))
        return value.join(", ");
      if (items)
        return Array.isArray(items) ? (_a = items.find((item) => item.value === value)) == null ? void 0 : _a.label : items[value];
    }
  }, [value, items, isChildrenPropFunction]), state = React.useMemo(() => ({
    value
  }), [value]), children = typeof childrenProp == "function" ? childrenProp(value) : childrenProp ?? labelFromItems ?? value;
  return useRenderElement("span", componentProps, {
    state,
    ref: [forwardedRef, valueRef],
    props: [{
      children
    }, elementProps],
    customStyleHookMapping: customStyleHookMapping$2
  });
});
define_process_env_default$l.NODE_ENV !== "production" && (SelectValue.displayName = "SelectValue");
var define_process_env_default$k = {};
const SelectIcon = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  return useRenderElement("span", componentProps, {
    ref: forwardedRef,
    props: [{
      "aria-hidden": !0,
      children: ""
    }, elementProps]
  });
});
define_process_env_default$k.NODE_ENV !== "production" && (SelectIcon.displayName = "SelectIcon");
var define_process_env_default$j = {};
const SelectPortalContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$j.NODE_ENV !== "production" && (SelectPortalContext.displayName = "SelectPortalContext");
function SelectPortal(props) {
  const {
    children,
    container
  } = props, {
    store
  } = useSelectRootContext(), mounted = useStore(store, selectors.mounted), forceMount = useStore(store, selectors.forceMount);
  return mounted || forceMount ? /* @__PURE__ */ jsx(SelectPortalContext.Provider, {
    value: !0,
    children: /* @__PURE__ */ jsx(FloatingPortal, {
      root: container,
      children
    })
  }) : null;
}
function inertValue(value) {
  return isReactVersionAtLeast(19) ? value : value ? "true" : void 0;
}
var define_process_env_default$i = {};
const CompositeListContext = /* @__PURE__ */ React.createContext({
  register: () => {
  },
  unregister: () => {
  },
  subscribeMapChange: () => () => {
  },
  elementsRef: {
    current: []
  },
  nextIndexRef: {
    current: 0
  }
});
define_process_env_default$i.NODE_ENV !== "production" && (CompositeListContext.displayName = "CompositeListContext");
function useCompositeListContext() {
  return React.useContext(CompositeListContext);
}
function CompositeList(props) {
  const {
    children,
    elementsRef,
    labelsRef,
    onMapChange
  } = props, nextIndexRef = React.useRef(0), listeners = useRefWithInit(createListeners).current, map = useRefWithInit(createMap).current, [mapTick, setMapTick] = React.useState(0), lastTickRef = React.useRef(mapTick), register = useEventCallback((node, metadata) => {
    map.set(node, metadata ?? null), lastTickRef.current += 1, setMapTick(lastTickRef.current);
  }), unregister = useEventCallback((node) => {
    map.delete(node), lastTickRef.current += 1, setMapTick(lastTickRef.current);
  }), sortedMap = React.useMemo(() => {
    const newMap = /* @__PURE__ */ new Map();
    return Array.from(map.keys()).sort(sortByDocumentPosition).forEach((node, index2) => {
      const metadata = map.get(node) ?? {};
      newMap.set(node, {
        ...metadata,
        index: index2
      });
    }), newMap;
  }, [map, mapTick]);
  useIsoLayoutEffect(() => {
    lastTickRef.current === mapTick && (elementsRef.current.length !== sortedMap.size && (elementsRef.current.length = sortedMap.size), labelsRef && labelsRef.current.length !== sortedMap.size && (labelsRef.current.length = sortedMap.size)), onMapChange == null || onMapChange(sortedMap);
  }, [onMapChange, sortedMap, elementsRef, labelsRef, mapTick, lastTickRef]);
  const subscribeMapChange = useEventCallback((fn) => (listeners.add(fn), () => {
    listeners.delete(fn);
  }));
  useIsoLayoutEffect(() => {
    listeners.forEach((l) => l(sortedMap));
  }, [listeners, sortedMap]);
  const contextValue = React.useMemo(() => ({
    register,
    unregister,
    subscribeMapChange,
    elementsRef,
    labelsRef,
    nextIndexRef
  }), [register, unregister, subscribeMapChange, elementsRef, labelsRef, nextIndexRef]);
  return /* @__PURE__ */ jsx(CompositeListContext.Provider, {
    value: contextValue,
    children
  });
}
function createMap() {
  return /* @__PURE__ */ new Map();
}
function createListeners() {
  return /* @__PURE__ */ new Set();
}
function sortByDocumentPosition(a2, b) {
  const position = a2.compareDocumentPosition(b);
  return position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY ? -1 : position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS ? 1 : 0;
}
var define_process_env_default$h = {};
const DirectionContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$h.NODE_ENV !== "production" && (DirectionContext.displayName = "DirectionContext");
function useDirection(optional = !0) {
  const context = React.useContext(DirectionContext);
  if (context === void 0 && !optional)
    throw new Error("Base UI: DirectionContext is missing.");
  return (context == null ? void 0 : context.direction) ?? "ltr";
}
const baseArrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    var _a, _b;
    const {
      x,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state, {
      element,
      padding = 0,
      offsetParent = "real"
    } = evaluate(options, state) || {};
    if (element == null)
      return {};
    const paddingObject = getPaddingObject(padding), coords = {
      x,
      y: y2
    }, axis = getAlignmentAxis(placement), length = getAxisLength(axis), arrowDimensions = await platform2.getDimensions(element), isYAxis = axis === "y", minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length], startDiff = coords[axis] - rects.reference[axis], arrowOffsetParent = offsetParent === "real" ? await ((_a = platform2.getOffsetParent) == null ? void 0 : _a.call(platform2, element)) : elements.floating;
    let clientSize = elements.floating[clientProp] || rects.floating[length];
    (!clientSize || !await ((_b = platform2.isElement) == null ? void 0 : _b.call(platform2, arrowOffsetParent))) && (clientSize = elements.floating[clientProp] || rects.floating[length]);
    const centerToReference = endDiff / 2 - startDiff / 2, largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1, minPadding = Math.min(paddingObject[minProp], largestPossiblePadding), maxPadding = Math.min(paddingObject[maxProp], largestPossiblePadding), min2 = minPadding, max2 = clientSize - arrowDimensions[length] - maxPadding, center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference, offset2 = clamp(min2, center, max2), shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min2 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0, alignmentOffset = shouldAddOffset ? center < min2 ? center - min2 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
}), arrow = (options, deps) => ({
  ...baseArrow(options),
  options: [options, deps]
});
function getLogicalSide(sideParam, renderedSide, isRtl) {
  const isLogicalSideParam = sideParam === "inline-start" || sideParam === "inline-end";
  return {
    top: "top",
    right: isLogicalSideParam ? isRtl ? "inline-start" : "inline-end" : "right",
    bottom: "bottom",
    left: isLogicalSideParam ? isRtl ? "inline-end" : "inline-start" : "left"
  }[renderedSide];
}
function getOffsetData(state, sideParam, isRtl) {
  const {
    rects,
    placement
  } = state;
  return {
    side: getLogicalSide(sideParam, getSide(placement), isRtl),
    align: getAlignment(placement) || "center",
    anchor: {
      width: rects.reference.width,
      height: rects.reference.height
    },
    positioner: {
      width: rects.floating.width,
      height: rects.floating.height
    }
  };
}
function useAnchorPositioning(params) {
  var _a, _b;
  const {
    // Public parameters
    anchor,
    positionMethod = "absolute",
    side: sideParam = "bottom",
    sideOffset = 0,
    align = "center",
    alignOffset = 0,
    collisionBoundary,
    collisionPadding = 5,
    sticky = !1,
    arrowPadding = 5,
    trackAnchor = !0,
    // Private parameters
    keepMounted = !1,
    floatingRootContext,
    mounted,
    collisionAvoidance,
    shiftCrossAxis = !1,
    nodeId,
    adaptiveOrigin
  } = params, collisionAvoidanceSide = collisionAvoidance.side || "flip", collisionAvoidanceAlign = collisionAvoidance.align || "flip", collisionAvoidanceFallbackAxisSide = collisionAvoidance.fallbackAxisSide || "end", anchorFn = typeof anchor == "function" ? anchor : void 0, anchorFnCallback = useEventCallback(anchorFn), anchorDep = anchorFn ? anchorFnCallback : anchor, anchorValueRef = useLatestRef(anchor), isRtl = useDirection() === "rtl", side = {
    top: "top",
    right: "right",
    bottom: "bottom",
    left: "left",
    "inline-end": isRtl ? "left" : "right",
    "inline-start": isRtl ? "right" : "left"
  }[sideParam], placement = align === "center" ? side : `${side}-${align}`, commonCollisionProps = {
    boundary: collisionBoundary === "clipping-ancestors" ? "clippingAncestors" : collisionBoundary,
    padding: collisionPadding
  }, arrowRef = React.useRef(null), sideOffsetRef = useLatestRef(sideOffset), alignOffsetRef = useLatestRef(alignOffset), middleware = [offset((state) => {
    const data = getOffsetData(state, sideParam, isRtl), sideAxis = typeof sideOffsetRef.current == "function" ? sideOffsetRef.current(data) : sideOffsetRef.current, alignAxis = typeof alignOffsetRef.current == "function" ? alignOffsetRef.current(data) : alignOffsetRef.current;
    return {
      mainAxis: sideAxis,
      crossAxis: alignAxis,
      alignmentAxis: alignAxis
    };
  }, [typeof sideOffset != "function" ? sideOffset : 0, typeof alignOffset != "function" ? alignOffset : 0, isRtl, sideParam])], shiftDisabled = collisionAvoidanceAlign === "none" && collisionAvoidanceSide !== "shift", crossAxisShiftEnabled = !shiftDisabled && (sticky || shiftCrossAxis || collisionAvoidanceSide === "shift"), flipMiddleware = collisionAvoidanceSide === "none" ? null : flip({
    ...commonCollisionProps,
    mainAxis: !shiftCrossAxis && collisionAvoidanceSide === "flip",
    crossAxis: collisionAvoidanceAlign === "flip" ? "alignment" : !1,
    fallbackAxisSideDirection: collisionAvoidanceFallbackAxisSide
  }), shiftMiddleware = shiftDisabled ? null : shift((data) => {
    const html = ownerDocument(data.elements.floating).documentElement;
    return {
      ...commonCollisionProps,
      // Use the Layout Viewport to avoid shifting around when pinch-zooming
      // for context menus.
      rootBoundary: shiftCrossAxis ? {
        x: 0,
        y: 0,
        width: html.clientWidth,
        height: html.clientHeight
      } : void 0,
      mainAxis: collisionAvoidanceAlign !== "none",
      crossAxis: crossAxisShiftEnabled,
      limiter: sticky || shiftCrossAxis ? void 0 : limitShift(() => {
        if (!arrowRef.current)
          return {};
        const {
          height
        } = arrowRef.current.getBoundingClientRect();
        return {
          offset: height / 2 + (typeof collisionPadding == "number" ? collisionPadding : 0)
        };
      })
    };
  }, [commonCollisionProps, sticky, shiftCrossAxis, collisionPadding, collisionAvoidanceAlign]);
  collisionAvoidanceSide === "shift" || collisionAvoidanceAlign === "shift" || align === "center" ? middleware.push(shiftMiddleware, flipMiddleware) : middleware.push(flipMiddleware, shiftMiddleware), middleware.push(size({
    ...commonCollisionProps,
    apply({
      elements: {
        floating
      },
      rects: {
        reference
      },
      availableWidth,
      availableHeight
    }) {
      Object.entries({
        "--available-width": `${availableWidth}px`,
        "--available-height": `${availableHeight}px`,
        "--anchor-width": `${reference.width}px`,
        "--anchor-height": `${reference.height}px`
      }).forEach(([key, value]) => {
        floating.style.setProperty(key, value);
      });
    }
  }), arrow(() => ({
    // `transform-origin` calculations rely on an element existing. If the arrow hasn't been set,
    // we'll create a fake element.
    element: arrowRef.current || document.createElement("div"),
    padding: arrowPadding,
    offsetParent: "floating"
  }), [arrowPadding]), hide(), {
    name: "transformOrigin",
    fn(state) {
      var _a2, _b2, _c;
      const {
        elements: elements2,
        middlewareData: middlewareData2,
        placement: renderedPlacement2,
        rects,
        y: y3
      } = state, currentRenderedSide = getSide(renderedPlacement2), currentRenderedAxis = getSideAxis(currentRenderedSide), arrowEl = arrowRef.current, arrowX = ((_a2 = middlewareData2.arrow) == null ? void 0 : _a2.x) || 0, arrowY = ((_b2 = middlewareData2.arrow) == null ? void 0 : _b2.y) || 0, arrowWidth = (arrowEl == null ? void 0 : arrowEl.clientWidth) || 0, arrowHeight = (arrowEl == null ? void 0 : arrowEl.clientHeight) || 0, transformX = arrowX + arrowWidth / 2, transformY = arrowY + arrowHeight / 2, shiftY = Math.abs(((_c = middlewareData2.shift) == null ? void 0 : _c.y) || 0), halfAnchorHeight = rects.reference.height / 2, isOverlappingAnchor = shiftY > (typeof sideOffset == "function" ? sideOffset(getOffsetData(state, sideParam, isRtl)) : sideOffset), adjacentTransformOrigin = {
        top: `${transformX}px calc(100% + ${sideOffset}px)`,
        bottom: `${transformX}px ${-sideOffset}px`,
        left: `calc(100% + ${sideOffset}px) ${transformY}px`,
        right: `${-sideOffset}px ${transformY}px`
      }[currentRenderedSide], overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y3}px`;
      return elements2.floating.style.setProperty("--transform-origin", crossAxisShiftEnabled && currentRenderedAxis === "y" && isOverlappingAnchor ? overlapTransformOrigin : adjacentTransformOrigin), {};
    }
  }, adaptiveOrigin);
  let rootContext = floatingRootContext;
  !mounted && floatingRootContext && (rootContext = {
    ...floatingRootContext,
    elements: {
      reference: null,
      floating: null,
      domReference: null
    }
  });
  const autoUpdateOptions = React.useMemo(() => ({
    elementResize: trackAnchor && typeof ResizeObserver < "u",
    layoutShift: trackAnchor && typeof IntersectionObserver < "u"
  }), [trackAnchor]), {
    refs,
    elements,
    x,
    y: y2,
    middlewareData,
    update: update2,
    placement: renderedPlacement,
    context,
    isPositioned,
    floatingStyles: originalFloatingStyles
  } = useFloating({
    rootContext,
    placement,
    middleware,
    strategy: positionMethod,
    whileElementsMounted: keepMounted ? void 0 : (...args) => autoUpdate(...args, autoUpdateOptions),
    nodeId
  }), {
    sideX,
    sideY
  } = middlewareData.adaptiveOrigin || {}, floatingStyles = React.useMemo(() => adaptiveOrigin ? {
    position: positionMethod,
    [sideX]: `${x}px`,
    [sideY]: `${y2}px`
  } : originalFloatingStyles, [adaptiveOrigin, sideX, sideY, positionMethod, x, y2, originalFloatingStyles]), registeredPositionReferenceRef = React.useRef(null);
  useIsoLayoutEffect(() => {
    if (!mounted)
      return;
    const anchorValue = anchorValueRef.current, resolvedAnchor = typeof anchorValue == "function" ? anchorValue() : anchorValue, finalAnchor = (isRef(resolvedAnchor) ? resolvedAnchor.current : resolvedAnchor) || null || null;
    finalAnchor !== registeredPositionReferenceRef.current && (refs.setPositionReference(finalAnchor), registeredPositionReferenceRef.current = finalAnchor);
  }, [mounted, refs, anchorDep, anchorValueRef]), React.useEffect(() => {
    if (!mounted)
      return;
    const anchorValue = anchorValueRef.current;
    typeof anchorValue != "function" && isRef(anchorValue) && anchorValue.current !== registeredPositionReferenceRef.current && (refs.setPositionReference(anchorValue.current), registeredPositionReferenceRef.current = anchorValue.current);
  }, [mounted, refs, anchorDep, anchorValueRef]), React.useEffect(() => {
    if (keepMounted && mounted && elements.domReference && elements.floating)
      return autoUpdate(elements.domReference, elements.floating, update2, autoUpdateOptions);
  }, [keepMounted, mounted, elements, update2, autoUpdateOptions]);
  const renderedSide = getSide(renderedPlacement), logicalRenderedSide = getLogicalSide(sideParam, renderedSide, isRtl), renderedAlign = getAlignment(renderedPlacement) || "center", anchorHidden = !!((_a = middlewareData.hide) != null && _a.referenceHidden), arrowStyles = React.useMemo(() => {
    var _a2, _b2;
    return {
      position: "absolute",
      top: (_a2 = middlewareData.arrow) == null ? void 0 : _a2.y,
      left: (_b2 = middlewareData.arrow) == null ? void 0 : _b2.x
    };
  }, [middlewareData.arrow]), arrowUncentered = ((_b = middlewareData.arrow) == null ? void 0 : _b.centerOffset) !== 0;
  return React.useMemo(() => ({
    positionerStyles: floatingStyles,
    arrowStyles,
    arrowRef,
    arrowUncentered,
    side: logicalRenderedSide,
    align: renderedAlign,
    anchorHidden,
    refs,
    context,
    isPositioned,
    update: update2
  }), [floatingStyles, arrowStyles, arrowRef, arrowUncentered, logicalRenderedSide, renderedAlign, anchorHidden, refs, context, isPositioned, update2]);
}
function isRef(param) {
  return param != null && "current" in param;
}
var define_process_env_default$g = {};
const SelectPositionerContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$g.NODE_ENV !== "production" && (SelectPositionerContext.displayName = "SelectPositionerContext");
function useSelectPositionerContext() {
  const context = React.useContext(SelectPositionerContext);
  if (!context)
    throw new Error("Base UI: SelectPositionerContext is missing. SelectPositioner parts must be placed within <Select.Positioner>.");
  return context;
}
var define_process_env_default$f = {};
const InternalBackdrop = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  const {
    cutout,
    ...otherProps
  } = props;
  let clipPath;
  if (cutout) {
    const rect = cutout == null ? void 0 : cutout.getBoundingClientRect();
    clipPath = `polygon(
      0% 0%,
      100% 0%,
      100% 100%,
      0% 100%,
      0% 0%,
      ${rect.left}px ${rect.top}px,
      ${rect.left}px ${rect.bottom}px,
      ${rect.right}px ${rect.bottom}px,
      ${rect.right}px ${rect.top}px,
      ${rect.left}px ${rect.top}px
    )`;
  }
  return /* @__PURE__ */ jsx("div", {
    ref,
    role: "presentation",
    "data-base-ui-inert": "",
    ...otherProps,
    style: {
      position: "fixed",
      inset: 0,
      userSelect: "none",
      WebkitUserSelect: "none",
      clipPath
    }
  });
});
define_process_env_default$f.NODE_ENV !== "production" && (InternalBackdrop.displayName = "InternalBackdrop");
function clearPositionerStyles(positionerElement, originalPositionerStyles) {
  Object.assign(positionerElement.style, originalPositionerStyles);
}
let originalHtmlStyles = {}, originalBodyStyles = {}, originalHtmlScrollBehavior = "";
function hasInsetScrollbars(referenceElement) {
  if (typeof document > "u")
    return !1;
  const doc = ownerDocument(referenceElement);
  return getWindow(doc).innerWidth - doc.documentElement.clientWidth > 0;
}
function preventScrollBasic(referenceElement) {
  const html = ownerDocument(referenceElement).documentElement, originalOverflow = html.style.overflow;
  return html.style.overflow = "hidden", () => {
    html.style.overflow = originalOverflow;
  };
}
function preventScrollStandard(referenceElement) {
  var _a;
  const doc = ownerDocument(referenceElement), html = doc.documentElement, body = doc.body, win = getWindow(html);
  let scrollTop = 0, scrollLeft = 0;
  const resizeFrame = AnimationFrame.create();
  if (isWebKit && (((_a = win.visualViewport) == null ? void 0 : _a.scale) ?? 1) !== 1)
    return () => {
    };
  function lockScroll() {
    var _a2;
    const htmlStyles = win.getComputedStyle(html), bodyStyles = win.getComputedStyle(body);
    scrollTop = html.scrollTop, scrollLeft = html.scrollLeft, originalHtmlStyles = {
      scrollbarGutter: html.style.scrollbarGutter,
      overflowY: html.style.overflowY,
      overflowX: html.style.overflowX
    }, originalHtmlScrollBehavior = html.style.scrollBehavior, originalBodyStyles = {
      position: body.style.position,
      height: body.style.height,
      width: body.style.width,
      boxSizing: body.style.boxSizing,
      overflowY: body.style.overflowY,
      overflowX: body.style.overflowX,
      scrollBehavior: body.style.scrollBehavior
    };
    const supportsStableScrollbarGutter = typeof CSS < "u" && ((_a2 = CSS.supports) == null ? void 0 : _a2.call(CSS, "scrollbar-gutter", "stable")), isScrollableY = html.scrollHeight > html.clientHeight, isScrollableX = html.scrollWidth > html.clientWidth, hasConstantOverflowY = htmlStyles.overflowY === "scroll" || bodyStyles.overflowY === "scroll", hasConstantOverflowX = htmlStyles.overflowX === "scroll" || bodyStyles.overflowX === "scroll", scrollbarWidth = Math.max(0, win.innerWidth - html.clientWidth), scrollbarHeight = Math.max(0, win.innerHeight - html.clientHeight), marginY = parseFloat(bodyStyles.marginTop) + parseFloat(bodyStyles.marginBottom), marginX = parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight);
    Object.assign(html.style, {
      scrollbarGutter: "stable",
      overflowY: !supportsStableScrollbarGutter && (isScrollableY || hasConstantOverflowY) ? "scroll" : "hidden",
      overflowX: !supportsStableScrollbarGutter && (isScrollableX || hasConstantOverflowX) ? "scroll" : "hidden"
    }), Object.assign(body.style, {
      position: "relative",
      height: marginY || scrollbarHeight ? `calc(100dvh - ${marginY + scrollbarHeight}px)` : "100dvh",
      width: marginX || scrollbarWidth ? `calc(100vw - ${marginX + scrollbarWidth}px)` : "100vw",
      boxSizing: "border-box",
      overflow: "hidden",
      scrollBehavior: "unset"
    }), body.scrollTop = scrollTop, body.scrollLeft = scrollLeft, html.setAttribute("data-base-ui-scroll-locked", ""), html.style.scrollBehavior = "unset";
  }
  function cleanup() {
    Object.assign(html.style, originalHtmlStyles), Object.assign(body.style, originalBodyStyles), html.scrollTop = scrollTop, html.scrollLeft = scrollLeft, html.removeAttribute("data-base-ui-scroll-locked"), html.style.scrollBehavior = originalHtmlScrollBehavior;
  }
  function handleResize() {
    cleanup(), resizeFrame.request(lockScroll);
  }
  return lockScroll(), win.addEventListener("resize", handleResize), () => {
    resizeFrame.cancel(), cleanup(), win.removeEventListener("resize", handleResize);
  };
}
class ScrollLocker {
  constructor() {
    __publicField(this, "lockCount", 0);
    __publicField(this, "restore", null);
    __publicField(this, "timeoutLock", Timeout.create());
    __publicField(this, "timeoutUnlock", Timeout.create());
    __publicField(this, "release", () => {
      this.lockCount -= 1, this.lockCount === 0 && this.restore && this.timeoutUnlock.start(0, this.unlock);
    });
    __publicField(this, "unlock", () => {
      var _a;
      this.lockCount === 0 && this.restore && ((_a = this.restore) == null || _a.call(this), this.restore = null);
    });
  }
  acquire(referenceElement) {
    return this.lockCount += 1, this.lockCount === 1 && this.restore === null && this.timeoutLock.start(0, () => this.lock(referenceElement)), this.release;
  }
  lock(referenceElement) {
    if (this.lockCount === 0 || this.restore !== null)
      return;
    const html = ownerDocument(referenceElement).documentElement, htmlOverflowY = getWindow(html).getComputedStyle(html).overflowY;
    if (htmlOverflowY === "hidden" || htmlOverflowY === "clip") {
      this.restore = NOOP;
      return;
    }
    const isOverflowHiddenLock = isIOS || !hasInsetScrollbars(referenceElement);
    this.restore = isOverflowHiddenLock ? preventScrollBasic(referenceElement) : preventScrollStandard(referenceElement);
  }
}
const SCROLL_LOCKER = new ScrollLocker();
function useScrollLock(params) {
  const {
    enabled = !0,
    mounted,
    open,
    referenceElement = null
  } = params;
  useIsoLayoutEffect(() => {
    if (enabled && isWebKit && mounted && !open) {
      const doc = ownerDocument(referenceElement), originalUserSelect = doc.body.style.userSelect, originalWebkitUserSelect = doc.body.style.webkitUserSelect;
      return doc.body.style.userSelect = "none", doc.body.style.webkitUserSelect = "none", () => {
        doc.body.style.userSelect = originalUserSelect, doc.body.style.webkitUserSelect = originalWebkitUserSelect;
      };
    }
  }, [enabled, mounted, open, referenceElement]), useIsoLayoutEffect(() => {
    if (enabled)
      return SCROLL_LOCKER.acquire(referenceElement);
  }, [enabled, referenceElement]);
}
var define_process_env_default$e = {};
const FIXED = {
  position: "fixed"
}, SelectPositioner = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    anchor,
    positionMethod = "absolute",
    className,
    render,
    side = "bottom",
    align = "center",
    sideOffset = 0,
    alignOffset = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding,
    arrowPadding = 5,
    sticky = !1,
    trackAnchor = !0,
    alignItemWithTrigger = !0,
    collisionAvoidance = DROPDOWN_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps, {
    store,
    listRef,
    labelsRef,
    alignItemWithTriggerActiveRef,
    valuesRef
  } = useSelectRootContext(), floatingRootContext = useSelectFloatingContext(), open = useStore(store, selectors.open), mounted = useStore(store, selectors.mounted), modal = useStore(store, selectors.modal), value = useStore(store, selectors.value), touchModality = useStore(store, selectors.touchModality), positionerElement = useStore(store, selectors.positionerElement), triggerElement = useStore(store, selectors.triggerElement), [controlledAlignItemWithTrigger, setControlledAlignItemWithTrigger] = React.useState(alignItemWithTrigger), alignItemWithTriggerActive = mounted && controlledAlignItemWithTrigger && !touchModality;
  !mounted && controlledAlignItemWithTrigger !== alignItemWithTrigger && setControlledAlignItemWithTrigger(alignItemWithTrigger), useIsoLayoutEffect(() => {
    (!alignItemWithTrigger || !mounted) && (selectors.scrollUpArrowVisible(store.state) && store.set("scrollUpArrowVisible", !1), selectors.scrollDownArrowVisible(store.state) && store.set("scrollDownArrowVisible", !1));
  }, [store, mounted, alignItemWithTrigger]), React.useImperativeHandle(alignItemWithTriggerActiveRef, () => alignItemWithTriggerActive), useScrollLock({
    enabled: (alignItemWithTriggerActive || modal) && open && !touchModality,
    mounted,
    open,
    referenceElement: triggerElement
  });
  const positioning = useAnchorPositioning({
    anchor,
    floatingRootContext,
    positionMethod,
    mounted,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    trackAnchor: trackAnchor ?? !alignItemWithTriggerActive,
    collisionAvoidance,
    keepMounted: !0
  }), renderedSide = alignItemWithTriggerActive ? "none" : positioning.side, positionerStyles = alignItemWithTriggerActive ? FIXED : positioning.positionerStyles, defaultProps = React.useMemo(() => {
    const hiddenStyles = {};
    return open || (hiddenStyles.pointerEvents = "none"), {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, mounted, positionerStyles]), state = React.useMemo(() => ({
    open,
    side: renderedSide,
    align: positioning.align,
    anchorHidden: positioning.anchorHidden
  }), [open, renderedSide, positioning.align, positioning.anchorHidden]), setPositionerElement = useEventCallback((element2) => {
    store.set("positionerElement", element2);
  }), element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, setPositionerElement],
    state,
    customStyleHookMapping: popupStateMapping,
    props: [defaultProps, elementProps]
  }), prevMapSizeRef = React.useRef(0), onMapChange = useEventCallback((map) => {
    if (map.size === 0 && prevMapSizeRef.current === 0 || valuesRef.current.length === 0)
      return;
    const prevSize = prevMapSizeRef.current;
    prevMapSizeRef.current = map.size, map.size !== prevSize && (!store.state.multiple && value !== null && valuesRef.current.indexOf(value) === -1 && store.apply({
      label: "",
      selectedIndex: null
    }), open && alignItemWithTriggerActive && (store.apply({
      scrollUpArrowVisible: !1,
      scrollDownArrowVisible: !1
    }), positionerElement && clearPositionerStyles(positionerElement, {
      height: ""
    })));
  }), contextValue = React.useMemo(() => ({
    ...positioning,
    side: renderedSide,
    alignItemWithTriggerActive,
    setControlledAlignItemWithTrigger
  }), [positioning, renderedSide, alignItemWithTriggerActive, setControlledAlignItemWithTrigger]);
  return /* @__PURE__ */ jsx(CompositeList, {
    elementsRef: listRef,
    labelsRef,
    onMapChange,
    children: /* @__PURE__ */ jsxs(SelectPositionerContext.Provider, {
      value: contextValue,
      children: [mounted && modal && /* @__PURE__ */ jsx(InternalBackdrop, {
        inert: inertValue(!open),
        cutout: triggerElement
      }), element]
    })
  });
});
define_process_env_default$e.NODE_ENV !== "production" && (SelectPositioner.displayName = "SelectPositioner");
function isMouseWithinBounds(event) {
  const targetRect = event.currentTarget.getBoundingClientRect();
  return targetRect.top + 1 <= event.clientY && event.clientY <= targetRect.bottom - 1 && targetRect.left + 1 <= event.clientX && event.clientX <= targetRect.right - 1;
}
const styleDisableScrollbar = {
  className: "base-ui-disable-scrollbar",
  element: /* @__PURE__ */ jsx("style", {
    href: "base-ui-disable-scrollbar",
    precedence: "base-ui:low",
    children: ".base-ui-disable-scrollbar{scrollbar-width:none}.base-ui-disable-scrollbar::-webkit-scrollbar{display:none}"
  })
};
var define_process_env_default$d = {};
const customStyleHookMapping$1 = {
  ...popupStateMapping,
  ...transitionStatusMapping
}, SelectPopup = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps, {
    store,
    popupRef,
    onOpenChangeComplete,
    setOpen,
    valueRef,
    selectedItemTextRef,
    keyboardActiveRef,
    highlightTimeout,
    multiple
  } = useSelectRootContext(), {
    side,
    align,
    context,
    alignItemWithTriggerActive,
    setControlledAlignItemWithTrigger
  } = useSelectPositionerContext(), open = useStore(store, selectors.open), mounted = useStore(store, selectors.mounted), popupProps = useStore(store, selectors.popupProps), transitionStatus = useStore(store, selectors.transitionStatus), triggerElement = useStore(store, selectors.triggerElement), positionerElement = useStore(store, selectors.positionerElement), scrollUpArrowVisible = useStore(store, selectors.scrollUpArrowVisible), scrollDownArrowVisible = useStore(store, selectors.scrollDownArrowVisible);
  useOpenChangeComplete({
    open,
    ref: popupRef,
    onComplete() {
      open && (onOpenChangeComplete == null || onOpenChangeComplete(!0));
    }
  });
  const state = React.useMemo(() => ({
    open,
    transitionStatus,
    side,
    align
  }), [open, transitionStatus, side, align]), initialHeightRef = React.useRef(0), reachedMaxHeightRef = React.useRef(!1), maxHeightRef = React.useRef(0), initialPlacedRef = React.useRef(!1), originalPositionerStylesRef = React.useRef({}), handleScrollArrowVisibility = useEventCallback(() => {
    if (!alignItemWithTriggerActive || !popupRef.current)
      return;
    const isScrolledToTop = popupRef.current.scrollTop < 1, isScrolledToBottom = popupRef.current.scrollTop + popupRef.current.clientHeight >= popupRef.current.scrollHeight - 1;
    scrollUpArrowVisible !== !isScrolledToTop && store.set("scrollUpArrowVisible", !isScrolledToTop), scrollDownArrowVisible !== !isScrolledToBottom && store.set("scrollDownArrowVisible", !isScrolledToBottom);
  });
  useIsoLayoutEffect(() => {
    !positionerElement || Object.keys(originalPositionerStylesRef.current).length || (originalPositionerStylesRef.current = {
      top: positionerElement.style.top || "0",
      left: positionerElement.style.left || "0",
      right: positionerElement.style.right,
      height: positionerElement.style.height,
      bottom: positionerElement.style.bottom,
      minHeight: positionerElement.style.minHeight,
      maxHeight: positionerElement.style.maxHeight,
      marginTop: positionerElement.style.marginTop,
      marginBottom: positionerElement.style.marginBottom
    });
  }, [positionerElement]), useIsoLayoutEffect(() => {
    mounted || alignItemWithTriggerActive || (initialPlacedRef.current = !1, reachedMaxHeightRef.current = !1, initialHeightRef.current = 0, maxHeightRef.current = 0, positionerElement && clearPositionerStyles(positionerElement, originalPositionerStylesRef.current));
  }, [mounted, alignItemWithTriggerActive, positionerElement]), useIsoLayoutEffect(() => {
    const popupElement = popupRef.current;
    !mounted || !alignItemWithTriggerActive || !triggerElement || !positionerElement || !popupRef.current || !popupElement || queueMicrotask(() => {
      var _a;
      const positionerStyles = getComputedStyle(positionerElement), popupStyles = getComputedStyle(popupElement), doc = ownerDocument(triggerElement), win = getWindow(positionerElement), triggerRect = triggerElement.getBoundingClientRect(), positionerRect = positionerElement.getBoundingClientRect(), triggerX = triggerRect.left, triggerHeight = triggerRect.height, scrollHeight = popupElement.scrollHeight, borderBottom = parseFloat(popupStyles.borderBottomWidth), marginTop = parseFloat(positionerStyles.marginTop) || 10, marginBottom = parseFloat(positionerStyles.marginBottom) || 10, minHeight = parseFloat(positionerStyles.minHeight) || 100, paddingLeft = 5, paddingRight = 5, triggerCollisionThreshold = 20, viewportHeight = doc.documentElement.clientHeight - marginTop - marginBottom, viewportWidth = doc.documentElement.clientWidth, availableSpaceBeneathTrigger = viewportHeight - triggerRect.bottom + triggerHeight, textElement = selectedItemTextRef.current, valueElement = valueRef.current;
      let offsetX = 0, offsetY = 0;
      if (textElement && valueElement) {
        const valueRect = valueElement.getBoundingClientRect(), textRect = textElement.getBoundingClientRect(), valueLeftFromTriggerLeft = valueRect.left - triggerX, textLeftFromPositionerLeft = textRect.left - positionerRect.left, valueCenterFromPositionerTop = valueRect.top - triggerRect.top + valueRect.height / 2, textCenterFromTriggerTop = textRect.top - positionerRect.top + textRect.height / 2;
        offsetX = valueLeftFromTriggerLeft - textLeftFromPositionerLeft, offsetY = textCenterFromTriggerTop - valueCenterFromPositionerTop;
      }
      const idealHeight = availableSpaceBeneathTrigger + offsetY + marginBottom + borderBottom;
      let height = Math.min(viewportHeight, idealHeight);
      const maxHeight = viewportHeight - marginTop - marginBottom, scrollTop = idealHeight - height, left = Math.max(paddingLeft, triggerX + offsetX), maxRight = viewportWidth - paddingRight, rightOverflow = Math.max(0, left + positionerRect.width - maxRight);
      positionerElement.style.left = `${left - rightOverflow}px`, positionerElement.style.height = `${height}px`, positionerElement.style.maxHeight = "auto", positionerElement.style.marginTop = `${marginTop}px`, positionerElement.style.marginBottom = `${marginBottom}px`;
      const maxScrollTop = popupElement.scrollHeight - popupElement.clientHeight, isTopPositioned = scrollTop >= maxScrollTop;
      isTopPositioned && (height = Math.min(viewportHeight, positionerRect.height) - (scrollTop - maxScrollTop));
      const fallbackToAlignPopupToTrigger = triggerRect.top < triggerCollisionThreshold || triggerRect.bottom > viewportHeight - triggerCollisionThreshold || height < Math.min(scrollHeight, minHeight), isPinchZoomed = (((_a = win.visualViewport) == null ? void 0 : _a.scale) ?? 1) !== 1 && isWebKit;
      if (fallbackToAlignPopupToTrigger || isPinchZoomed) {
        initialPlacedRef.current = !0, clearPositionerStyles(positionerElement, originalPositionerStylesRef.current), ReactDOM.flushSync(() => setControlledAlignItemWithTrigger(!1));
        return;
      }
      if (isTopPositioned) {
        const topOffset = Math.max(0, viewportHeight - idealHeight);
        positionerElement.style.top = positionerRect.height >= maxHeight ? "0" : `${topOffset}px`, positionerElement.style.height = `${height}px`, popupElement.scrollTop = popupElement.scrollHeight - popupElement.clientHeight, initialHeightRef.current = Math.max(minHeight, height);
      } else
        positionerElement.style.bottom = "0", initialHeightRef.current = Math.max(minHeight, height), popupElement.scrollTop = scrollTop;
      initialHeightRef.current === viewportHeight && (reachedMaxHeightRef.current = !0), handleScrollArrowVisibility(), setTimeout(() => {
        initialPlacedRef.current = !0;
      });
    });
  }, [store, mounted, positionerElement, triggerElement, valueRef, selectedItemTextRef, popupRef, handleScrollArrowVisibility, alignItemWithTriggerActive, setControlledAlignItemWithTrigger]), React.useEffect(() => {
    if (!alignItemWithTriggerActive || !positionerElement || !mounted)
      return;
    const win = getWindow(positionerElement);
    function handleResize(event) {
      setOpen(!1, event, "window-resize");
    }
    return win.addEventListener("resize", handleResize), () => {
      win.removeEventListener("resize", handleResize);
    };
  }, [setOpen, alignItemWithTriggerActive, positionerElement, mounted]);
  const defaultProps = {
    "aria-multiselectable": multiple || void 0,
    onKeyDown() {
      keyboardActiveRef.current = !0;
    },
    onMouseMove() {
      keyboardActiveRef.current = !1;
    },
    onPointerLeave(event) {
      if (isMouseWithinBounds(event) || event.pointerType === "touch")
        return;
      const popup = event.currentTarget;
      highlightTimeout.start(0, () => {
        store.set("activeIndex", null), popup.focus({
          preventScroll: !0
        });
      });
    },
    onScroll(event) {
      if (!alignItemWithTriggerActive || !positionerElement || !popupRef.current || !initialPlacedRef.current)
        return;
      if (reachedMaxHeightRef.current) {
        handleScrollArrowVisibility();
        return;
      }
      const isTopPositioned = positionerElement.style.top === "0px", isBottomPositioned = positionerElement.style.bottom === "0px", currentHeight = positionerElement.getBoundingClientRect().height, doc = ownerDocument(positionerElement), positionerStyles = getComputedStyle(positionerElement), marginTop = parseFloat(positionerStyles.marginTop), marginBottom = parseFloat(positionerStyles.marginBottom), viewportHeight = doc.documentElement.clientHeight - marginTop - marginBottom;
      if (isTopPositioned) {
        const scrollTop = event.currentTarget.scrollTop, maxScrollTop = event.currentTarget.scrollHeight - event.currentTarget.clientHeight, diff = maxScrollTop - scrollTop, nextHeight = Math.min(currentHeight + diff, viewportHeight);
        positionerElement.style.height = `${Math.min(currentHeight + diff, viewportHeight)}px`, nextHeight !== viewportHeight ? event.currentTarget.scrollTop = maxScrollTop : reachedMaxHeightRef.current = !0;
      } else if (isBottomPositioned) {
        const diff = event.currentTarget.scrollTop - 0, nextHeight = Math.min(currentHeight + diff, viewportHeight), idealHeight = currentHeight + diff, overshoot = idealHeight - viewportHeight;
        positionerElement.style.height = `${Math.min(idealHeight, viewportHeight)}px`, nextHeight !== viewportHeight ? event.currentTarget.scrollTop = 0 : (reachedMaxHeightRef.current = !0, event.currentTarget.scrollTop < event.currentTarget.scrollHeight - event.currentTarget.clientHeight && (event.currentTarget.scrollTop -= diff - overshoot));
      }
      handleScrollArrowVisibility();
    },
    ...alignItemWithTriggerActive && {
      style: {
        position: "relative",
        maxHeight: "100%",
        overflowX: "hidden",
        overflowY: "auto"
      }
    }
  }, element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, popupRef],
    state,
    customStyleHookMapping: customStyleHookMapping$1,
    props: [popupProps, defaultProps, {
      style: transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE.style : void 0,
      className: alignItemWithTriggerActive ? styleDisableScrollbar.className : void 0
    }, elementProps]
  });
  return /* @__PURE__ */ jsxs(React.Fragment, {
    children: [styleDisableScrollbar.element, /* @__PURE__ */ jsx(FloatingFocusManager, {
      context,
      modal: !1,
      disabled: !mounted,
      restoreFocus: !0,
      children: element
    })]
  });
});
define_process_env_default$d.NODE_ENV !== "production" && (SelectPopup.displayName = "SelectPopup");
let IndexGuessBehavior = /* @__PURE__ */ (function(IndexGuessBehavior2) {
  return IndexGuessBehavior2[IndexGuessBehavior2.None = 0] = "None", IndexGuessBehavior2[IndexGuessBehavior2.GuessFromOrder = 1] = "GuessFromOrder", IndexGuessBehavior2;
})({});
function useCompositeListItem(params = {}) {
  const {
    label,
    metadata,
    textRef,
    indexGuessBehavior
  } = params, {
    register,
    unregister,
    subscribeMapChange,
    elementsRef,
    labelsRef,
    nextIndexRef
  } = useCompositeListContext(), indexRef = React.useRef(-1), [index2, setIndex] = React.useState(indexGuessBehavior === IndexGuessBehavior.GuessFromOrder ? () => {
    if (indexRef.current === -1) {
      const newIndex = nextIndexRef.current;
      nextIndexRef.current += 1, indexRef.current = newIndex;
    }
    return indexRef.current;
  } : -1), componentRef = React.useRef(null), ref = React.useCallback((node) => {
    var _a;
    if (componentRef.current = node, index2 !== -1 && node !== null && (elementsRef.current[index2] = node, labelsRef)) {
      const isLabelDefined = label !== void 0;
      labelsRef.current[index2] = isLabelDefined ? label : ((_a = textRef == null ? void 0 : textRef.current) == null ? void 0 : _a.textContent) ?? node.textContent;
    }
  }, [index2, elementsRef, labelsRef, label, textRef]);
  return useIsoLayoutEffect(() => {
    const node = componentRef.current;
    if (node)
      return register(node, metadata), () => {
        unregister(node);
      };
  }, [register, unregister, metadata]), useIsoLayoutEffect(() => subscribeMapChange((map) => {
    var _a;
    const i2 = componentRef.current ? (_a = map.get(componentRef.current)) == null ? void 0 : _a.index : null;
    i2 != null && setIndex(i2);
  }), [subscribeMapChange, setIndex]), React.useMemo(() => ({
    ref,
    index: index2
  }), [index2, ref]);
}
var define_process_env_default$c = {};
const SelectItemContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$c.NODE_ENV !== "production" && (SelectItemContext.displayName = "SelectItemContext");
function useSelectItemContext() {
  const context = React.useContext(SelectItemContext);
  if (!context)
    throw new Error("Base UI: SelectItemContext is missing. SelectItem parts must be placed within <Select.Item>.");
  return context;
}
var define_process_env_default$b = {};
const SelectItem = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    render,
    className,
    value = null,
    label,
    disabled = !1,
    nativeButton = !1,
    ...elementProps
  } = componentProps, textRef = React.useRef(null), listItem = useCompositeListItem({
    label,
    textRef,
    indexGuessBehavior: IndexGuessBehavior.GuessFromOrder
  }), {
    store,
    getItemProps,
    setOpen,
    setValue,
    selectionRef,
    typingRef,
    valuesRef,
    registerItemIndex,
    keyboardActiveRef,
    highlightTimeout,
    multiple
  } = useSelectRootContext(), highlighted = useStore(store, selectors.isActive, listItem.index), selected = useStore(store, selectors.isSelected, listItem.index, value), rootValue = useStore(store, selectors.value), selectedByFocus = useStore(store, selectors.isSelectedByFocus, listItem.index), itemRef = React.useRef(null), indexRef = useLatestRef(listItem.index), hasRegistered = listItem.index !== -1;
  useIsoLayoutEffect(() => {
    if (!hasRegistered)
      return;
    const values = valuesRef.current;
    return values[listItem.index] = value, () => {
      delete values[listItem.index];
    };
  }, [hasRegistered, listItem.index, value, valuesRef]), useIsoLayoutEffect(() => {
    hasRegistered && (multiple ? Array.isArray(rootValue) && rootValue.includes(value) && registerItemIndex(listItem.index) : value === rootValue && registerItemIndex(listItem.index));
  }, [hasRegistered, listItem.index, registerItemIndex, value, rootValue, multiple]);
  const state = React.useMemo(() => ({
    disabled,
    selected,
    highlighted
  }), [disabled, selected, highlighted]), rootProps = getItemProps({
    active: highlighted,
    selected
  });
  delete rootProps.onFocus, delete rootProps.id;
  const lastKeyRef = React.useRef(null), pointerTypeRef = React.useRef("mouse"), didPointerDownRef = React.useRef(!1), {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: !0,
    native: nativeButton
  });
  function commitSelection(event) {
    if (multiple) {
      const currentValue = Array.isArray(rootValue) ? rootValue : [], nextValue = selected ? currentValue.filter((v2) => v2 !== value) : [...currentValue, value];
      setValue(nextValue, event);
    } else
      setValue(value, event), setOpen(!1, event, "item-press");
  }
  const defaultProps = {
    "aria-disabled": disabled || void 0,
    tabIndex: highlighted ? 0 : -1,
    onFocus() {
      store.set("activeIndex", indexRef.current);
    },
    onMouseEnter() {
      !keyboardActiveRef.current && store.state.selectedIndex === null && store.set("activeIndex", indexRef.current);
    },
    onMouseMove() {
      store.set("activeIndex", indexRef.current);
    },
    onMouseLeave(event) {
      keyboardActiveRef.current || isMouseWithinBounds(event) || highlightTimeout.start(0, () => {
        store.state.activeIndex === indexRef.current && store.set("activeIndex", null);
      });
    },
    onTouchStart() {
      selectionRef.current = {
        allowSelectedMouseUp: !1,
        allowUnselectedMouseUp: !1,
        allowSelect: !0
      };
    },
    onKeyDown(event) {
      selectionRef.current.allowSelect = !0, lastKeyRef.current = event.key, store.set("activeIndex", indexRef.current);
    },
    onClick(event) {
      didPointerDownRef.current = !1, !(event.type === "keydown" && lastKeyRef.current === null) && (disabled || lastKeyRef.current === " " && typingRef.current || pointerTypeRef.current !== "touch" && !highlighted || selectionRef.current.allowSelect && (lastKeyRef.current = null, commitSelection(event.nativeEvent)));
    },
    onPointerEnter(event) {
      pointerTypeRef.current = event.pointerType;
    },
    onPointerDown(event) {
      pointerTypeRef.current = event.pointerType, didPointerDownRef.current = !0;
    },
    onMouseUp(event) {
      if (disabled)
        return;
      if (didPointerDownRef.current) {
        didPointerDownRef.current = !1;
        return;
      }
      const disallowSelectedMouseUp = !selectionRef.current.allowSelectedMouseUp && selected, disallowUnselectedMouseUp = !selectionRef.current.allowUnselectedMouseUp && !selected;
      disallowSelectedMouseUp || disallowUnselectedMouseUp || pointerTypeRef.current !== "touch" && !highlighted || ((selectionRef.current.allowSelect || !selected) && commitSelection(event.nativeEvent), selectionRef.current.allowSelect = !0);
    }
  }, element = useRenderElement("div", componentProps, {
    ref: [buttonRef, forwardedRef, listItem.ref, itemRef],
    state,
    props: [rootProps, defaultProps, elementProps, getButtonProps]
  }), contextValue = React.useMemo(() => ({
    selected,
    indexRef,
    textRef,
    selectedByFocus
  }), [selected, indexRef, textRef, selectedByFocus]);
  return /* @__PURE__ */ jsx(SelectItemContext.Provider, {
    value: contextValue,
    children: element
  });
}));
define_process_env_default$b.NODE_ENV !== "production" && (SelectItem.displayName = "SelectItem");
var define_process_env_default$a = {};
const SelectItemText = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    indexRef,
    textRef,
    selectedByFocus
  } = useSelectItemContext(), {
    selectedItemTextRef
  } = useSelectRootContext(), {
    className,
    render,
    ...elementProps
  } = componentProps, localRef = React.useCallback((node) => {
    node && queueMicrotask(() => {
      const hasNoSelectedItemText = selectedItemTextRef.current === null || !selectedItemTextRef.current.isConnected;
      (selectedByFocus || hasNoSelectedItemText && indexRef.current === 0) && (selectedItemTextRef.current = node);
    });
  }, [selectedItemTextRef, indexRef, selectedByFocus]);
  return useRenderElement("div", componentProps, {
    ref: [localRef, forwardedRef, textRef],
    props: elementProps
  });
}));
define_process_env_default$a.NODE_ENV !== "production" && (SelectItemText.displayName = "SelectItemText");
var define_process_env_default$9 = {};
const SelectScrollArrow = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    render,
    className,
    direction,
    keepMounted = !1,
    ...elementProps
  } = componentProps, {
    store,
    popupRef,
    listRef
  } = useSelectRootContext(), {
    side,
    alignItemWithTriggerActive
  } = useSelectPositionerContext(), selector = direction === "up" ? selectors.scrollUpArrowVisible : selectors.scrollDownArrowVisible, visible = useStore(store, selector), timeout = useTimeout(), scrollArrowRef = React.useRef(null), {
    mounted,
    transitionStatus,
    setMounted
  } = useTransitionStatus(visible);
  useOpenChangeComplete({
    open: visible,
    ref: scrollArrowRef,
    onComplete() {
      visible || setMounted(!1);
    }
  });
  const state = React.useMemo(() => ({
    direction,
    visible,
    side,
    transitionStatus
  }), [direction, visible, side, transitionStatus]), element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, scrollArrowRef],
    state,
    props: [{
      hidden: !mounted,
      "aria-hidden": !0,
      children: direction === "up" ? "" : "",
      style: {
        position: "absolute"
      },
      onMouseMove(event) {
        if (event.movementX === 0 && event.movementY === 0 || !alignItemWithTriggerActive || timeout.isStarted())
          return;
        store.set("activeIndex", null);
        function scrollNextItem() {
          var _a;
          const popupElement = popupRef.current;
          if (!popupElement)
            return;
          store.set("activeIndex", null);
          const isScrolledToTop = popupElement.scrollTop === 0, isScrolledToBottom = Math.round(popupElement.scrollTop + popupElement.clientHeight) >= popupElement.scrollHeight;
          if (direction === "up" ? store.set("scrollUpArrowVisible", !isScrolledToTop) : direction === "down" && store.set("scrollDownArrowVisible", !isScrolledToBottom), direction === "up" && isScrolledToTop || direction === "down" && isScrolledToBottom) {
            timeout.clear();
            return;
          }
          if (popupRef.current && listRef.current && listRef.current.length > 0) {
            const items = listRef.current, scrollArrowHeight = ((_a = scrollArrowRef.current) == null ? void 0 : _a.offsetHeight) || 0;
            if (direction === "up") {
              let firstVisibleIndex = 0;
              const scrollTop = popupElement.scrollTop + scrollArrowHeight;
              for (let i2 = 0; i2 < items.length; i2 += 1) {
                const item = items[i2];
                if (item && item.offsetTop >= scrollTop) {
                  firstVisibleIndex = i2;
                  break;
                }
              }
              const targetIndex = Math.max(0, firstVisibleIndex - 1), targetItem = items[targetIndex];
              targetIndex < firstVisibleIndex && targetItem && (popupElement.scrollTop = targetItem.offsetTop - scrollArrowHeight);
            } else {
              let lastVisibleIndex = items.length - 1;
              const scrollBottom = popupElement.scrollTop + popupElement.clientHeight - scrollArrowHeight;
              for (let i2 = 0; i2 < items.length; i2 += 1) {
                const item = items[i2];
                if (item && item.offsetTop + item.offsetHeight > scrollBottom) {
                  lastVisibleIndex = Math.max(0, i2 - 1);
                  break;
                }
              }
              const targetIndex = Math.min(items.length - 1, lastVisibleIndex + 1);
              if (targetIndex > lastVisibleIndex) {
                const targetItem = items[targetIndex];
                targetItem && (popupElement.scrollTop = targetItem.offsetTop + targetItem.offsetHeight - popupElement.clientHeight + scrollArrowHeight);
              }
            }
          }
          timeout.start(40, scrollNextItem);
        }
        timeout.start(40, scrollNextItem);
      },
      onMouseLeave() {
        timeout.clear();
      }
    }, elementProps]
  });
  return visible || keepMounted ? element : null;
});
define_process_env_default$9.NODE_ENV !== "production" && (SelectScrollArrow.displayName = "SelectScrollArrow");
var define_process_env_default$8 = {};
const SelectScrollDownArrow = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  return /* @__PURE__ */ jsx(SelectScrollArrow, {
    ...props,
    ref: forwardedRef,
    direction: "down"
  });
});
define_process_env_default$8.NODE_ENV !== "production" && (SelectScrollDownArrow.displayName = "SelectScrollDownArrow");
var define_process_env_default$7 = {};
const SelectScrollUpArrow = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  return /* @__PURE__ */ jsx(SelectScrollArrow, {
    ...props,
    ref: forwardedRef,
    direction: "up"
  });
});
define_process_env_default$7.NODE_ENV !== "production" && (SelectScrollUpArrow.displayName = "SelectScrollUpArrow");
function Select({
  items,
  value,
  onChange,
  placeholder = "Select an option",
  className
}) {
  return /* @__PURE__ */ jsxs(SelectRoot, { items, value, onValueChange: onChange, children: [
    /* @__PURE__ */ jsxs(
      SelectTrigger,
      {
        className: cn(
          "relative flex h-8 w-full items-center justify-between gap-2 rounded-lg px-3 py-2",
          "bg-white/90 backdrop-blur-sm",
          "border border-zinc-200/80 shadow-sm",
          "hover:border-zinc-300 hover:bg-white hover:shadow-md",
          "focus:border-blue-400 focus:outline-none focus:ring-2 focus:ring-blue-500/20",
          "transition-all duration-150 ease-out",
          "font-normal text-foreground/80 text-sm",
          className
        ),
        children: [
          /* @__PURE__ */ jsx(SelectValue, { className: "flex items-center gap-2 truncate", children: (selectedValue) => {
            const selectedItem = items.find(
              (item) => item.value === selectedValue
            );
            return /* @__PURE__ */ jsxs(Fragment$1, { children: [
              (selectedItem == null ? void 0 : selectedItem.icon) && /* @__PURE__ */ jsx("span", { className: "size-4 flex-shrink-0", children: selectedItem.icon }),
              /* @__PURE__ */ jsx("span", { className: "truncate", children: (selectedItem == null ? void 0 : selectedItem.label) || placeholder })
            ] });
          } }),
          /* @__PURE__ */ jsx(SelectIcon, { children: /* @__PURE__ */ jsx(ChevronDownIcon, { className: "size-3 text-foreground/60" }) })
        ]
      }
    ),
    /* @__PURE__ */ jsx(SelectPortal, { children: /* @__PURE__ */ jsx(SelectPositioner, { sideOffset: 4, children: /* @__PURE__ */ jsxs(
      SelectPopup,
      {
        className: cn(
          glassyBoxClassName,
          "z-50 w-full min-w-[8rem] overflow-hidden rounded-xl p-1",
          "shadow-black/10 shadow-xl",
          "fade-in-0 zoom-in-95 animate-in"
        ),
        children: [
          /* @__PURE__ */ jsx(SelectScrollUpArrow, { className: "flex h-6 items-center justify-center text-zinc-400", children: /* @__PURE__ */ jsx(ChevronUpIcon, { className: "size-4" }) }),
          items.map((item, _index) => /* @__PURE__ */ jsx(
            SelectItem,
            {
              value: item.value,
              className: cn(
                "relative flex cursor-pointer select-none items-center rounded-lg px-2 py-2 text-sm",
                "text-foreground/80 outline-none",
                "transition-colors duration-150",
                "hover:bg-zinc-100/80",
                "data-[selected]:bg-blue-600 data-[selected]:text-white",
                "data-[selected]:data-[focused]:bg-blue-600 data-[focused]:bg-zinc-100/80"
              ),
              children: /* @__PURE__ */ jsxs(SelectItemText, { className: "flex items-center gap-2", children: [
                item.icon && /* @__PURE__ */ jsx("span", { className: "size-4 flex-shrink-0", children: item.icon }),
                /* @__PURE__ */ jsx("span", { children: item.label })
              ] })
            },
            typeof item.value == "object" ? JSON.stringify(item.value) : String(item.value)
          )),
          /* @__PURE__ */ jsx(SelectScrollDownArrow, { className: "flex h-6 items-center justify-center text-zinc-400", children: /* @__PURE__ */ jsx(ChevronDownIcon, { className: "size-4" }) })
        ]
      }
    ) }) })
  ] });
}
function ChevronUpIcon(props) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      width: "12",
      height: "12",
      viewBox: "0 0 12 12",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ jsx("path", { d: "M3 7.5L6 4.5L9 7.5" })
    }
  );
}
function ChevronDownIcon(props) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      width: "12",
      height: "12",
      viewBox: "0 0 12 12",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ jsx("path", { d: "M3 4.5L6 7.5L9 4.5" })
    }
  );
}
function ContextElementsChips() {
  const { domContextElements, removeChatDomContext } = useChatState(), { setHoveredElement } = useContextChipHover();
  return domContextElements.length === 0 ? null : /* @__PURE__ */ jsx("div", { className: "mb-1.5", children: /* @__PURE__ */ jsx("div", { className: "scrollbar-thin scrollbar-thumb-black/15 scrollbar-track-transparent flex gap-2 overflow-x-auto pb-1", children: domContextElements.map((contextElement, index2) => /* @__PURE__ */ jsx(
    ContextElementChip,
    {
      element: contextElement.element,
      pluginContext: contextElement.pluginContext,
      onDelete: () => removeChatDomContext(contextElement.element),
      onHover: setHoveredElement,
      onUnhover: () => setHoveredElement(null)
    },
    `${contextElement.element.tagName}-${index2}`
  )) }) });
}
function ContextElementChip({
  element,
  pluginContext,
  onDelete,
  onHover,
  onUnhover
}) {
  const chipLabel = useMemo(() => {
    var _a, _b;
    const firstAnnotation = (_b = (_a = pluginContext.find(
      (plugin) => {
        var _a2;
        return (_a2 = plugin.context) == null ? void 0 : _a2.annotation;
      }
    )) == null ? void 0 : _a.context) == null ? void 0 : _b.annotation;
    if (firstAnnotation)
      return firstAnnotation;
    const tagName = element.tagName.toLowerCase(), id = element.id ? `#${element.id}` : "";
    return `${tagName}${id}`;
  }, [element, pluginContext]);
  return /* @__PURE__ */ jsxs(
    "button",
    {
      type: "button",
      tabIndex: -1,
      className: cn(
        "flex min-w-fit shrink-0 items-center gap-1 rounded-lg border border-border/20 bg-white/30 px-2 py-1 text-xs shadow-sm backdrop-blur-lg transition-all hover:border-border/40 hover:bg-white/80"
      ),
      onMouseEnter: () => onHover(element),
      onMouseLeave: () => onUnhover(),
      children: [
        /* @__PURE__ */ jsx(SquareDashedMousePointer, { className: "size-3 text-foreground/60" }),
        /* @__PURE__ */ jsx("span", { className: "max-w-24 truncate font-medium text-foreground/80", children: chipLabel }),
        /* @__PURE__ */ jsx(
          "button",
          {
            type: "button",
            onClick: (e2) => {
              e2.stopPropagation(), onDelete();
            },
            className: "text-muted-foreground transition-colors hover:text-red-500",
            children: /* @__PURE__ */ jsx(X, { className: "size-3" })
          }
        )
      ]
    }
  );
}
function AgentMessageDisplay() {
  var _a, _b, _c, _d, _e;
  const messaging = useAgentMessaging(), agentState = useAgentState(), scrollContainerRef = useRef(null), wasAtBottomRef = useRef(!0), scrollToBottom = () => {
    const container = scrollContainerRef.current;
    container && setTimeout(() => {
      container.scrollTop = container.scrollHeight;
    }, 0);
  }, checkIfAtBottom = () => {
    const container = scrollContainerRef.current;
    return container ? container.scrollTop + container.clientHeight >= container.scrollHeight - 10 : !0;
  }, handleScroll = () => {
    const isAtBottom = checkIfAtBottom();
    wasAtBottomRef.current = isAtBottom;
  };
  return useEffect(() => {
    scrollContainerRef.current && wasAtBottomRef.current && scrollToBottom();
  }, [(_a = messaging.agentMessage) == null ? void 0 : _a.contentItems, agentState.state]), useEffect(() => {
    const container = scrollContainerRef.current;
    if (container)
      return container.addEventListener("scroll", handleScroll), scrollToBottom(), wasAtBottomRef.current = !0, () => {
        container.removeEventListener("scroll", handleScroll);
      };
  }, []), ((_c = (_b = messaging.agentMessage) == null ? void 0 : _b.contentItems) == null ? void 0 : _c.length) > 0 || agentState.state === AgentStateType.IDLE ? /* @__PURE__ */ jsx(
    "section",
    {
      ref: scrollContainerRef,
      "aria-label": "Agent message display",
      className: "scrollbar-thin scrollbar-thumb-black/15 scrollbar-track-transparent pointer-events-auto space-y-2 overflow-y-scroll overscroll-contain px-3 py-4 text-foreground text-sm focus-within:outline-none hover:bg-white/0 focus:outline-none",
      onScroll: handleScroll,
      onMouseEnter: () => {
        var _a2;
        (_a2 = scrollContainerRef.current) == null || _a2.focus();
      },
      children: (_e = (_d = messaging.agentMessage) == null ? void 0 : _d.contentItems) == null ? void 0 : _e.map((item, index2) => item.type === "text" ? /* @__PURE__ */ jsx("p", { className: "whitespace-pre-wrap", children: item.text }, `item_${index2 + 1}`) : item.type === "image" ? /* @__PURE__ */ jsx("div", { className: "text-sm", children: /* @__PURE__ */ jsx(
        "img",
        {
          src: item.data,
          alt: "Agent message attachment",
          className: "max-w-full rounded-lg border border-black/15 ring-1 ring-white/20"
        }
      ) }, `item_${index2 + 1}`) : null)
    }
  ) : null;
}
var define_process_env_default$6 = {};
const TooltipRootContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$6.NODE_ENV !== "production" && (TooltipRootContext.displayName = "TooltipRootContext");
function useTooltipRootContext() {
  const context = React.useContext(TooltipRootContext);
  if (context === void 0)
    throw new Error("Base UI: TooltipRootContext is missing. Tooltip parts must be placed within <Tooltip.Root>.");
  return context;
}
const OPEN_DELAY = 600;
var define_process_env_default$5 = {};
const TooltipProviderContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$5.NODE_ENV !== "production" && (TooltipProviderContext.displayName = "TooltipProviderContext");
function useTooltipProviderContext() {
  return React.useContext(TooltipProviderContext);
}
function TooltipRoot(props) {
  const {
    disabled = !1,
    defaultOpen = !1,
    onOpenChange,
    open: openProp,
    delay,
    closeDelay,
    hoverable = !0,
    trackCursorAxis = "none",
    actionsRef,
    onOpenChangeComplete
  } = props, delayWithDefault = delay ?? OPEN_DELAY, closeDelayWithDefault = closeDelay ?? 0, [triggerElement, setTriggerElement] = React.useState(null), [positionerElement, setPositionerElement] = React.useState(null), [instantTypeState, setInstantTypeState] = React.useState(), popupRef = React.useRef(null), [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Tooltip",
    state: "open"
  }), open = !disabled && openState;
  function setOpenUnwrapped(nextOpen, event, reason) {
    const isHover = reason === "trigger-hover", isFocusOpen = nextOpen && reason === "trigger-focus", isDismissClose = !nextOpen && (reason === "trigger-press" || reason === "escape-key");
    function changeState() {
      onOpenChange == null || onOpenChange(nextOpen, event, reason), setOpenState(nextOpen);
    }
    isHover ? ReactDOM.flushSync(changeState) : changeState(), isFocusOpen || isDismissClose ? setInstantTypeState(isFocusOpen ? "focus" : "dismiss") : reason === "trigger-hover" && setInstantTypeState(void 0);
  }
  const setOpen = useEventCallback(setOpenUnwrapped);
  openState && disabled && setOpenUnwrapped(!1, void 0, "disabled");
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open), handleUnmount = useEventCallback(() => {
    setMounted(!1), onOpenChangeComplete == null || onOpenChangeComplete(!1);
  });
  useOpenChangeComplete({
    enabled: !actionsRef,
    open,
    ref: popupRef,
    onComplete() {
      open || handleUnmount();
    }
  }), React.useImperativeHandle(actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  const floatingRootContext = useFloatingRootContext({
    elements: {
      reference: triggerElement,
      floating: positionerElement
    },
    open,
    onOpenChange(openValue, eventValue, reasonValue) {
      setOpen(openValue, eventValue, translateOpenChangeReason(reasonValue));
    }
  }), providerContext = useTooltipProviderContext(), {
    delayRef,
    isInstantPhase,
    hasProvider
  } = useDelayGroup(floatingRootContext), instantType = isInstantPhase ? "delay" : instantTypeState, hover = useHover(floatingRootContext, {
    enabled: !disabled,
    mouseOnly: !0,
    move: !1,
    handleClose: hoverable && trackCursorAxis !== "both" ? safePolygon() : null,
    restMs() {
      const providerDelay = providerContext == null ? void 0 : providerContext.delay, groupOpenValue = typeof delayRef.current == "object" ? delayRef.current.open : void 0;
      let computedRestMs = delayWithDefault;
      return hasProvider && (groupOpenValue !== 0 ? computedRestMs = delay ?? providerDelay ?? delayWithDefault : computedRestMs = 0), computedRestMs;
    },
    delay() {
      const closeValue = typeof delayRef.current == "object" ? delayRef.current.close : void 0;
      let computedCloseDelay = closeDelayWithDefault;
      return closeDelay == null && hasProvider && (computedCloseDelay = closeValue), {
        close: computedCloseDelay
      };
    }
  }), focus = useFocus(floatingRootContext, {
    enabled: !disabled
  }), dismiss = useDismiss(floatingRootContext, {
    enabled: !disabled,
    referencePress: !0
  }), clientPoint = useClientPoint(floatingRootContext, {
    enabled: !disabled && trackCursorAxis !== "none",
    axis: trackCursorAxis === "none" ? void 0 : trackCursorAxis
  }), {
    getReferenceProps,
    getFloatingProps
  } = useInteractions([hover, focus, dismiss, clientPoint]), tooltipRoot = React.useMemo(() => ({
    open,
    setOpen,
    mounted,
    setMounted,
    setTriggerElement,
    positionerElement,
    setPositionerElement,
    popupRef,
    triggerProps: getReferenceProps(),
    popupProps: getFloatingProps(),
    floatingRootContext,
    instantType,
    transitionStatus,
    onOpenChangeComplete
  }), [open, setOpen, mounted, setMounted, setTriggerElement, positionerElement, setPositionerElement, popupRef, getReferenceProps, getFloatingProps, floatingRootContext, instantType, transitionStatus, onOpenChangeComplete]), contextValue = React.useMemo(() => ({
    ...tooltipRoot,
    delay: delayWithDefault,
    closeDelay: closeDelayWithDefault,
    trackCursorAxis,
    hoverable
  }), [tooltipRoot, delayWithDefault, closeDelayWithDefault, trackCursorAxis, hoverable]);
  return /* @__PURE__ */ jsx(TooltipRootContext.Provider, {
    value: contextValue,
    children: props.children
  });
}
var define_process_env_default$4 = {};
const TooltipTrigger$1 = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps, {
    open,
    setTriggerElement,
    triggerProps
  } = useTooltipRootContext(), state = React.useMemo(() => ({
    open
  }), [open]);
  return useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, setTriggerElement],
    props: [triggerProps, elementProps],
    customStyleHookMapping: triggerOpenStateMapping
  });
});
define_process_env_default$4.NODE_ENV !== "production" && (TooltipTrigger$1.displayName = "TooltipTrigger");
var define_process_env_default$3 = {};
const TooltipPortalContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$3.NODE_ENV !== "production" && (TooltipPortalContext.displayName = "TooltipPortalContext");
function useTooltipPortalContext() {
  const value = React.useContext(TooltipPortalContext);
  if (value === void 0)
    throw new Error("Base UI: <Tooltip.Portal> is missing.");
  return value;
}
function FloatingPortalLite(props) {
  const node = useFloatingPortalNode({
    root: props.root
  });
  return node && /* @__PURE__ */ ReactDOM.createPortal(props.children, node);
}
function TooltipPortal(props) {
  const {
    children,
    keepMounted = !1,
    container
  } = props, {
    mounted
  } = useTooltipRootContext();
  return mounted || keepMounted ? /* @__PURE__ */ jsx(TooltipPortalContext.Provider, {
    value: keepMounted,
    children: /* @__PURE__ */ jsx(FloatingPortalLite, {
      root: container,
      children
    })
  }) : null;
}
var define_process_env_default$2 = {};
const TooltipPositionerContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$2.NODE_ENV !== "production" && (TooltipPositionerContext.displayName = "TooltipPositionerContext");
function useTooltipPositionerContext() {
  const context = React.useContext(TooltipPositionerContext);
  if (context === void 0)
    throw new Error("Base UI: TooltipPositionerContext is missing. TooltipPositioner parts must be placed within <Tooltip.Positioner>.");
  return context;
}
var define_process_env_default$1 = {};
const TooltipPositioner = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    render,
    className,
    anchor,
    positionMethod = "absolute",
    side = "top",
    align = "center",
    sideOffset = 0,
    alignOffset = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    arrowPadding = 5,
    sticky = !1,
    trackAnchor = !0,
    collisionAvoidance = POPUP_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps, {
    open,
    setPositionerElement,
    mounted,
    floatingRootContext,
    trackCursorAxis,
    hoverable
  } = useTooltipRootContext(), keepMounted = useTooltipPortalContext(), positioning = useAnchorPositioning({
    anchor,
    positionMethod,
    floatingRootContext,
    mounted,
    side,
    sideOffset,
    align,
    alignOffset,
    collisionBoundary,
    collisionPadding,
    sticky,
    arrowPadding,
    trackAnchor,
    keepMounted,
    collisionAvoidance
  }), defaultProps = React.useMemo(() => {
    const hiddenStyles = {};
    return (!open || trackCursorAxis === "both" || !hoverable) && (hiddenStyles.pointerEvents = "none"), {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positioning.positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, trackCursorAxis, hoverable, mounted, positioning.positionerStyles]), positioner = React.useMemo(() => ({
    props: defaultProps,
    ...positioning
  }), [defaultProps, positioning]), state = React.useMemo(() => ({
    open,
    side: positioner.side,
    align: positioner.align,
    anchorHidden: positioner.anchorHidden
  }), [open, positioner.side, positioner.align, positioner.anchorHidden]), contextValue = React.useMemo(() => ({
    ...state,
    arrowRef: positioner.arrowRef,
    arrowStyles: positioner.arrowStyles,
    arrowUncentered: positioner.arrowUncentered
  }), [state, positioner.arrowRef, positioner.arrowStyles, positioner.arrowUncentered]), element = useRenderElement("div", componentProps, {
    state,
    props: [positioner.props, elementProps],
    ref: [forwardedRef, setPositionerElement],
    customStyleHookMapping: popupStateMapping
  });
  return /* @__PURE__ */ jsx(TooltipPositionerContext.Provider, {
    value: contextValue,
    children: element
  });
});
define_process_env_default$1.NODE_ENV !== "production" && (TooltipPositioner.displayName = "TooltipPositioner");
var define_process_env_default = {};
const customStyleHookMapping = {
  ...popupStateMapping,
  ...transitionStatusMapping
}, TooltipPopup = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps, {
    open,
    instantType,
    transitionStatus,
    popupProps,
    popupRef,
    onOpenChangeComplete
  } = useTooltipRootContext(), {
    side,
    align
  } = useTooltipPositionerContext();
  useOpenChangeComplete({
    open,
    ref: popupRef,
    onComplete() {
      open && (onOpenChangeComplete == null || onOpenChangeComplete(!0));
    }
  });
  const state = React.useMemo(() => ({
    open,
    side,
    align,
    instant: instantType,
    transitionStatus
  }), [open, side, align, instantType, transitionStatus]);
  return useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, popupRef],
    props: [popupProps, transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE : EMPTY_OBJECT, elementProps],
    customStyleHookMapping
  });
});
define_process_env_default.NODE_ENV !== "production" && (TooltipPopup.displayName = "TooltipPopup");
const Tooltip = ({
  children
}) => /* @__PURE__ */ jsx(TooltipRoot, { delay: 200, children }), TooltipTrigger = ({ children }) => /* @__PURE__ */ jsx(TooltipTrigger$1, { render: children }), TooltipContent = ({ children }) => /* @__PURE__ */ jsx(TooltipPortal, { children: /* @__PURE__ */ jsx(TooltipPositioner, { sideOffset: 2, alignOffset: 2, children: /* @__PURE__ */ jsx(TooltipPopup, { className: "rounded-lg border border-border/20 bg-gradient-to-b from-white/40 to-zinc-50/60 px-1.5 py-0.5 text-xs text-zinc-950/80 shadow-md backdrop-blur-sm", children }) }) }), BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua))
      return _const;
  }
  static getWindowsVersionName(version) {
    switch (version) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version) {
    const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    if (v2.push(0), v2[0] === 10)
      switch (v2[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version) {
    const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    if (v2.push(0), !(v2[0] === 1 && v2[1] < 5)) {
      if (v2[0] === 1 && v2[1] < 6) return "Cupcake";
      if (v2[0] === 1 && v2[1] >= 6) return "Donut";
      if (v2[0] === 2 && v2[1] < 2) return "Eclair";
      if (v2[0] === 2 && v2[1] === 2) return "Froyo";
      if (v2[0] === 2 && v2[1] > 2) return "Gingerbread";
      if (v2[0] === 3) return "Honeycomb";
      if (v2[0] === 4 && v2[1] < 1) return "Ice Cream Sandwich";
      if (v2[0] === 4 && v2[1] < 4) return "Jelly Bean";
      if (v2[0] === 4 && v2[1] >= 4) return "KitKat";
      if (v2[0] === 5) return "Lollipop";
      if (v2[0] === 6) return "Marshmallow";
      if (v2[0] === 7) return "Nougat";
      if (v2[0] === 8) return "Oreo";
      if (v2[0] === 9) return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version) {
    return version.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = !1) {
    const versionAPrecision = Utils.getVersionPrecision(versionA), versionBPrecision = Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision), lastPrecision = 0;
    const chunks = Utils.map([versionA, versionB], (version) => {
      const delta = precision - Utils.getVersionPrecision(version), _version = version + new Array(delta + 1).join(".0");
      return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    for (isLoose && (lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision)), precision -= 1; precision >= lastPrecision; ) {
      if (chunks[0][precision] > chunks[1][precision])
        return 1;
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision)
          return 0;
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator) {
    const result = [];
    let i2;
    if (Array.prototype.map)
      return Array.prototype.map.call(arr, iterator);
    for (i2 = 0; i2 < arr.length; i2 += 1)
      result.push(iterator(arr[i2]));
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i2, l;
    if (Array.prototype.find)
      return Array.prototype.find.call(arr, predicate);
    for (i2 = 0, l = arr.length; i2 < l; i2 += 1) {
      const value = arr[i2];
      if (predicate(value, i2))
        return value;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i2, l;
    if (Object.assign)
      return Object.assign(obj, ...assigners);
    for (i2 = 0, l = assigners.length; i2 < l; i2 += 1) {
      const assigner = assigners[i2];
      typeof assigner == "object" && assigner !== null && Object.keys(assigner).forEach((key) => {
        result[key] = assigner[key];
      });
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i, browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      }, version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      }, version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      }, version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      }, version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      }, version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      }, version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      }, version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      }, version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      }, version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      }, version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      }, version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      }, version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      }, version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      }, version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      }, version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      }, version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      }, version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      }, version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      }, version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      }, version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      }, version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      }, version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      }, version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      }, version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      }, version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      }, version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      }, version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i), butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /, regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/, regexp = ua.search("\\(") !== -1 ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
], osParsersList = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua) {
      const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua), versionName = Utils.getWindowsVersionName(version);
      return {
        name: OS_MAP.Windows,
        version,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      }, version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      return version && (result.version = version), result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, "."), versionName = Utils.getMacOSVersionName(version), os = {
        name: OS_MAP.MacOS,
        version
      };
      return versionName && (os.versionName = versionName), os;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i), butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua), versionName = Utils.getAndroidVersionName(version), os = {
        name: OS_MAP.Android,
        version
      };
      return versionName && (os.versionName = versionName), os;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua), os = {
        name: OS_MAP.WebOS
      };
      return version && version.length && (os.version = version), os;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version
      };
    }
  }
], platformParsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova", platform2 = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      return model && (platform2.model = model), platform2;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i), likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(!0) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
], enginesParsersList = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(!0) === "microsoft edge";
    },
    describe(ua) {
      if (/\sedg\//i.test(ua))
        return {
          name: ENGINE_MAP.Blink
        };
      const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      }, version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (engine.version = version), engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      }, version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (engine.version = version), engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i), likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      }, version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (engine.version = version), engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      }, version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (engine.version = version), engine;
    }
  }
];
class Parser {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA, skipParsing = !1) {
    if (UA == null || UA === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = UA, this.parsedResult = {}, skipParsing !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex) {
    return regex.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(browsersList, (_browser) => {
      if (typeof _browser.test == "function")
        return _browser.test(this);
      if (_browser.test instanceof Array)
        return _browser.test.some((condition) => this.test(condition));
      throw new Error("Browser's test function is not valid");
    });
    return browserDescriptor && (this.parsedResult.browser = browserDescriptor.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    return toLowerCase ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(osParsersList, (_os) => {
      if (typeof _os.test == "function")
        return _os.test(this);
      if (_os.test instanceof Array)
        return _os.test.some((condition) => this.test(condition));
      throw new Error("Browser's test function is not valid");
    });
    return os && (this.parsedResult.os = os.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name } = this.getOS();
    return toLowerCase ? String(name).toLowerCase() || "" : name || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = !1) {
    const { type } = this.getPlatform();
    return toLowerCase ? String(type).toLowerCase() || "" : type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform2 = Utils.find(platformParsersList, (_platform) => {
      if (typeof _platform.test == "function")
        return _platform.test(this);
      if (_platform.test instanceof Array)
        return _platform.test.some((condition) => this.test(condition));
      throw new Error("Browser's test function is not valid");
    });
    return platform2 && (this.parsedResult.platform = platform2.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    return toLowerCase ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(enginesParsersList, (_engine) => {
      if (typeof _engine.test == "function")
        return _engine.test(this);
      if (_engine.test instanceof Array)
        return _engine.test.some((condition) => this.test(condition));
      throw new Error("Browser's test function is not valid");
    });
    return engine && (this.parsedResult.engine = engine.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    if (Object.keys(checkTree).forEach((key) => {
      const currentDefinition = checkTree[key];
      typeof currentDefinition == "string" ? (browsers[key] = currentDefinition, browsersCounter += 1) : typeof currentDefinition == "object" && (platformsAndOSes[key] = currentDefinition, platformsAndOSCounter += 1);
    }), platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes), OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0)
          return osResult;
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name) => this.isPlatform(name)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0)
          return platformResult;
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers), matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, !0));
      if (matchingDefinition !== void 0)
        return this.compareVersion(browsers[matchingDefinition]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = !1) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    return includingAlias && alias && (browserNameLower = alias.toLowerCase()), browserNameLower === defaultBrowserName;
  }
  compareVersion(version) {
    let expectedResults = [0], comparableVersion = version, isLoose = !1;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion == "string")
      return version[0] === ">" || version[0] === "<" ? (comparableVersion = version.substr(1), version[1] === "=" ? (isLoose = !0, comparableVersion = version.substr(2)) : expectedResults = [], version[0] === ">" ? expectedResults.push(1) : expectedResults.push(-1)) : version[0] === "=" ? comparableVersion = version.substr(1) : version[0] === "~" && (isLoose = !0, comparableVersion = version.substr(1)), expectedResults.indexOf(
        Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
      ) > -1;
  }
  isOS(osName) {
    return this.getOSName(!0) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(!0) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(!0) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = !1) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA, skipParsing = !1) {
    if (typeof UA != "string")
      throw new Error("UserAgent should be a string");
    return new Parser(UA, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA) {
    return new Parser(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
const useBrowserInfo = () => useMemo(() => {
  const iframeWindow = getIFrameWindow(), userAgent2 = (iframeWindow == null ? void 0 : iframeWindow.navigator.userAgent) || window.navigator.userAgent, result = Bowser.parse(userAgent2);
  return {
    browser: result.browser,
    engine: result.engine,
    os: result.os
  };
}, []);
function HotkeyComboText({ action }) {
  return useBrowserInfo().os.name.toLowerCase().includes("mac") ? hotkeyActionDefinitions[action].keyComboMac : hotkeyActionDefinitions[action].keyComboDefault;
}
const DEFAULT_VARIANTS = {
  blue: {
    activeSpeed: "slow",
    backgroundColor: "#0d253f",
    colors: ["#1e40af", "#2563eb", "#3b82f6", "#60a5fa"]
  },
  green: {
    activeSpeed: "fast",
    backgroundColor: "#062a22",
    colors: ["#059669", "#10b981", "#34d399", "#6ee7b7"]
  },
  transparent: {
    activeSpeed: "slow",
    backgroundColor: "transparent",
    colors: ["transparent", "transparent", "transparent", "transparent"]
  }
}, SHAPE_DEFAULTS = [
  // This is now just a template for generating shapes for each speed group
  { type: "circle", cx: "15%", cy: "20%", r: "30%", color: 1 },
  {
    type: "rect",
    x: "50%",
    y: "0%",
    width: "40%",
    height: "40%",
    color: 2
  },
  { type: "circle", cx: "75%", cy: "60%", r: "25%", color: 3 },
  {
    type: "rect",
    x: "10%",
    y: "55%",
    width: "35%",
    height: "35%",
    color: 4
  },
  { type: "circle", cx: "40%", cy: "80%", r: "20%", color: 1 }
], random = (min2, max2) => Math.random() * (max2 - min2) + min2, ShapeGroup = ({
  shapes,
  speed,
  speedClass
}) => {
  const animationMultipliers = useMemo(() => shapes.map((_2, i2) => ({
    duration: random(0.8, 1.2),
    delay: random(0, -1),
    direction: i2 % 2 === 0 ? "alternate" : "alternate-reverse"
  })), [shapes]), shapesWithColorVar = shapes.map((shape, i2) => ({
    ...shape,
    colorVar: `--chat-grad-bg-c${shape.color}`,
    id: `${shape.type}-${shape.color}-${i2}`,
    // Better key for React
    animationMultipliers: animationMultipliers[i2]
  }));
  return /* @__PURE__ */ jsx("g", { className: speedClass, children: shapesWithColorVar.map((shape) => {
    const multipliers = shape.animationMultipliers, animationProps = {
      animationDuration: `calc(${speed}s * ${multipliers.duration})`,
      animationDelay: `calc(${speed}s * ${multipliers.delay})`,
      animationDirection: multipliers.direction
    };
    return shape.type === "circle" ? /* @__PURE__ */ jsx(
      "circle",
      {
        cx: shape.cx,
        cy: shape.cy,
        r: shape.r,
        fill: `var(${shape.colorVar})`,
        className: "shape-anim",
        style: animationProps
      },
      shape.id
    ) : /* @__PURE__ */ jsx(
      "rect",
      {
        x: shape.x,
        y: shape.y,
        width: shape.width,
        height: shape.height,
        fill: `var(${shape.colorVar})`,
        className: "shape-anim",
        style: animationProps
      },
      shape.id
    );
  }) });
}, GradientBackgroundChat = ({
  currentVariant,
  variants = DEFAULT_VARIANTS,
  className,
  blurAmount = 80,
  shapes = SHAPE_DEFAULTS,
  transparent = !1
}) => {
  const [style, setStyle] = useState({});
  return useEffect(() => {
    const activeVariant = variants[currentVariant];
    if (!activeVariant) {
      console.warn(
        `Variant "${currentVariant}" not found, falling back to default`
      );
      return;
    }
    const shouldBeTransparent = transparent || currentVariant === "transparent";
    setStyle({
      "--chat-grad-bg-bg-color": activeVariant.backgroundColor,
      backgroundColor: "var(--chat-grad-bg-bg-color)",
      "--chat-grad-bg-c1": activeVariant.colors[0],
      "--chat-grad-bg-c2": activeVariant.colors[1],
      "--chat-grad-bg-c3": activeVariant.colors[2],
      "--chat-grad-bg-c4": activeVariant.colors[3],
      "--chat-grad-bg-opacity-slow": activeVariant.activeSpeed === "slow" ? 1 : 0,
      "--chat-grad-bg-opacity-medium": activeVariant.activeSpeed === "medium" ? 1 : 0,
      "--chat-grad-bg-opacity-fast": activeVariant.activeSpeed === "fast" ? 1 : 0,
      "--chat-grad-bg-overall-opacity": shouldBeTransparent ? 0 : 1,
      opacity: "var(--chat-grad-bg-overall-opacity)"
    });
  }, [currentVariant, variants, transparent]), /* @__PURE__ */ jsx(
    "div",
    {
      className: `absolute inset-0 overflow-hidden transition-all duration-1000 ${className}`,
      style,
      children: /* @__PURE__ */ jsxs(
        "svg",
        {
          className: "-inset-[25%] absolute h-[150%] w-[150%]",
          xmlns: "http://www.w3.org/2000/svg",
          "aria-hidden": "true",
          role: "presentation",
          children: [
            /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("filter", { id: "blur-filter", children: /* @__PURE__ */ jsx("feGaussianBlur", { stdDeviation: blurAmount }) }) }),
            /* @__PURE__ */ jsxs("g", { filter: "url(#blur-filter)", children: [
              /* @__PURE__ */ jsx(ShapeGroup, { shapes, speed: 40, speedClass: "g-slow" }),
              /* @__PURE__ */ jsx(ShapeGroup, { shapes, speed: 20, speedClass: "g-medium" }),
              /* @__PURE__ */ jsx(ShapeGroup, { shapes, speed: 5, speedClass: "g-fast" })
            ] })
          ]
        }
      )
    }
  );
}, textSlideshowVariants = cva(
  "relative block h-[1.2em] h-full overflow-hidden"
);
function TextSlideshow({
  className,
  texts,
  changeEveryMs = 3e3,
  ...props
}) {
  const [currentIndex, setCurrentIndex] = React.useState(0), [isAnimating, setIsAnimating] = React.useState(!1);
  return React.useEffect(() => {
    if (texts.length <= 1) return;
    const interval = setInterval(() => {
      setIsAnimating(!0), setTimeout(() => {
        setCurrentIndex((prevIndex) => (prevIndex + 1) % texts.length), setIsAnimating(!1);
      }, 300);
    }, changeEveryMs);
    return () => clearInterval(interval);
  }, [texts.length, changeEveryMs]), texts.length === 0 ? null : /* @__PURE__ */ jsxs(
    "span",
    {
      "data-slot": "text-slideshow",
      className: cn(textSlideshowVariants(), className),
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "span",
          {
            className: cn(
              "absolute inset-0 transition-all duration-300 ease-in-out",
              isAnimating ? "-translate-y-2 transform opacity-0 blur-sm" : "translate-y-0 transform opacity-100"
            ),
            children: texts[currentIndex]
          },
          `current-${currentIndex}`
        ),
        /* @__PURE__ */ jsx(
          "span",
          {
            className: cn(
              "absolute inset-0 transition-all duration-300 ease-in-out",
              isAnimating ? "translate-y-0 opacity-100" : "translate-y-2 opacity-0 blur-sm"
            ),
            children: texts[(currentIndex + 1) % texts.length]
          },
          `next-${(currentIndex + 1) % texts.length}`
        )
      ]
    }
  );
}
function getElementAttributes(element) {
  const attrs = {}, priorityAttrs = [
    "id",
    "class",
    "name",
    "type",
    "href",
    "src",
    "alt",
    "for",
    "placeholder"
  ], dataAttrs = [];
  for (let i2 = 0; i2 < element.attributes.length; i2++) {
    const attr2 = element.attributes[i2];
    attr2.name.startsWith("data-") ? dataAttrs.push({ name: attr2.name, value: attr2.value }) : (priorityAttrs.includes(attr2.name.toLowerCase()) || attr2.name.toLowerCase() !== "style") && (attrs[attr2.name] = attr2.value);
  }
  return dataAttrs.forEach((da) => {
    attrs[da.name] = da.value;
  }), attrs;
}
function generateChildrenContext(element, currentDepth = 1, maxDepth = 3, maxChildrenPerLevel = 3, indent = "      ") {
  if (currentDepth > maxDepth || !element.children || element.children.length === 0)
    return "";
  let context = "";
  const childrenToProcess = Math.min(
    element.children.length,
    maxChildrenPerLevel
  );
  for (let i2 = 0; i2 < childrenToProcess; i2++) {
    const child = element.children[i2];
    if (!child) continue;
    context += `${indent}<child depth="${currentDepth}" index="${i2 + 1}">
`, context += `${indent}  <tag>${child.tagName.toLowerCase()}</tag>
`, child.id && (context += `${indent}  <id>${child.id}</id>
`);
    const classes = Array.from(child.classList).join(" ");
    classes && (context += `${indent}  <classes>${classes}</classes>
`);
    const directText = Array.from(child.childNodes).filter((node) => node.nodeType === Node.TEXT_NODE).map((node) => {
      var _a;
      return (_a = node.textContent) == null ? void 0 : _a.trim();
    }).filter((text) => text).join(" ");
    if (directText) {
      const truncatedText = directText.length > 100 ? `${directText.substring(0, 100)}...` : directText;
      context += `${indent}  <text>${truncatedText}</text>
`;
    }
    if (currentDepth < maxDepth && child.children.length > 0) {
      const childrenContext = generateChildrenContext(
        child,
        currentDepth + 1,
        maxDepth,
        maxChildrenPerLevel,
        `${indent}    `
      );
      childrenContext && (context += `${indent}  <children>
`, context += childrenContext, context += `${indent}  </children>
`);
    }
    context += `${indent}</child>
`;
  }
  return element.children.length > maxChildrenPerLevel && (context += `${indent}<!-- ${element.children.length - maxChildrenPerLevel} more child element(s) not shown -->
`), context;
}
function generateElementContext(element, index2) {
  var _a;
  let context = `  <element index="${index2 + 1}">
`;
  context += `    <tag>${element.tagName.toLowerCase()}</tag>
`;
  const id = element.id;
  id && (context += `    <id>${id}</id>
`);
  const classes = Array.from(element.classList).join(" ");
  classes && (context += `    <classes>${classes}</classes>
`);
  const attributes = getElementAttributes(element);
  if (Object.keys(attributes).length > 0) {
    context += `    <attributes>
`;
    for (const [key, value] of Object.entries(attributes))
      key.toLowerCase() !== "class" && key.toLowerCase() !== "id" && (context += `      <${key}>${value}</${key}>
`);
    context += `    </attributes>
`;
  }
  const text = (_a = element.innerText) == null ? void 0 : _a.trim();
  if (text && (context += `    <text>${text.length > 200 ? `${text.substring(0, 200)}...` : text}</text>
`), context += `    <!-- PARENT ELEMENT -->
`, context += `    <parent_element>
`, element.parentElement) {
    const parent = element.parentElement;
    context += `      <tag>${parent.tagName.toLowerCase()}</tag>
`, parent.id && (context += `      <id>${parent.id}</id>
`);
    const parentClasses = Array.from(parent.classList).join(" ");
    parentClasses && (context += `      <classes>${parentClasses}</classes>
`);
  } else
    context += `      <note>No parent element found (likely root or disconnected)</note>
`;
  if (context += `    </parent_element>
`, element.children && element.children.length > 0) {
    context += `    <!-- CHILD ELEMENTS (recursive, max 3 levels deep) -->
`, context += `    <child_elements>
`;
    const childrenContext = generateChildrenContext(element);
    context += childrenContext, context += `    </child_elements>
`;
  }
  try {
    const styles = window.getComputedStyle(element), relevantStyles = {
      display: styles.display,
      position: styles.position,
      color: styles.color,
      backgroundColor: styles.backgroundColor,
      fontSize: styles.fontSize,
      fontWeight: styles.fontWeight,
      width: styles.width,
      height: styles.height,
      padding: styles.padding,
      margin: styles.margin
    };
    context += `    <computed_styles>
`;
    for (const [key, value] of Object.entries(relevantStyles))
      value && value !== "none" && value !== "auto" && value !== "0px" && (context += `      <${key}>${value}</${key}>
`);
    context += `    </computed_styles>
`;
  } catch {
    context += `    <computed_styles>Could not retrieve computed styles</computed_styles>
`;
  }
  return context += `  </element>
`, context;
}
function createPrompt(selectedElements, userPrompt, url, contextSnippets) {
  const pluginContext = contextSnippets.length > 0 ? `
<plugin_contexts>
${contextSnippets.map(
    (snippet) => `  <${snippet.pluginName}>
${snippet.contextSnippets.map(
      (s2) => `    <${s2.promptContextName}>${s2.content}</${s2.promptContextName}>`
    ).join(`
`)}
  </${snippet.pluginName}>`
  ).join(`
`)}
</plugin_contexts>` : "";
  if (!selectedElements || selectedElements.length === 0)
    return `<task>
  <action>Implement the frontend changes based on my request and the provided context below.</action>
  <user_request>${userPrompt}</user_request>
  <page_url>${url}</page_url>
  <note>No specific elements were selected. Analyze the general page implementation or request clarification.</note>
</task>${pluginContext}`.trim();
  let elementContext = "";
  return selectedElements.forEach((element, index2) => {
    elementContext += generateElementContext(element, index2);
  }), `<task>
  <action>Implement the frontend changes based on my request and the provided context below.</action>
  <user_request>${userPrompt}</user_request>
  <page_url>${url}</page_url>
</task>

<selected_elements>
${elementContext}</selected_elements>${pluginContext}`.trim();
}
const CursorLogoImg = "data:image/png;base64,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", StagewiseLogoImg = "data:image/png;base64,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", WindsurfLogoImg = "data:image/png;base64,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", ClineLogoImg = "data:image/png;base64,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", RooCodeLogoImg = "data:image/png;base64,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", GithubCopilotLogoImg = "data:image/png;base64,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", TraeLogoImg = "data:image/png;base64,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QIAAAQIGoRsgQIAAAQIECBAgQIBAVMAgjBYvNgECBAgQIECAAAECBAxCN0CAAAECBAgQIECAAIGogEEYLV5sAgQIECBAgAABAgQIGIRugAABAgQIECBAgAABAlEBgzBavNgECBAgQIAAAQIECBAwCN0AAQIECBAgQIAAAQIEogIGYbR4sQkQIECAAAECBAgQIGAQugECBAgQIECAAAECBAhEBQzCaPFiEyBAgAABAgQIECBAwCB0AwQIECBAgAABAgQIEIgKGITR4sUmQIAAAQIECBAgQICAQegGCBAgQIAAAQIECBAgEBUwCKPFi02AAAECBAgQIECAAAGD0A0QIECAAAECBAgQIEAgKmAQRosXmwABAgQIECBAgAABAgahGyBAgAABAgQIECBAgEBUwCCMFi82AQIECBAgQIAAAQIEDEI3QIAAAQIECBAgQIAAgaiAQRgtXmwCBAgQIECAAAECBAgYhG6AAAECBAgQIECAAAECUQGDMFq82AQIECBAgAABAgQIEDAI3QABAgQIECBAgAABAgSiAgZhtHixCRAgQIAAAQIECBAgYBC6AQIECBAgQIAAAQIECEQFDMJo8WITIECAAAECBAgQIEDAIHQDBAgQIECAAAECBAgQiAoYhNHixSZAgAABAgQIECBAgIBB6AYIECBAgAABAgQIECAQFTAIo8WLTYAAAQIECBAgQIAAAYPQDRAgQIAAAQIECBAgQCAqYBBGixebAAECBAgQIECAAAECBqEbIECAAAECBAgQIECAQFTAIIwWLzYBAgQIECBAgAABAgQMQjdAgAABAgQIECBAgACBqIBBGC1ebAIECBAgQIAAAQIECBiEboAAAQIECBAgQIAAAQJRAYMwWrzYBAgQIECAAAECBAgQMAjdAAECBAgQIECAAAECBKICBmG0eLEJECBAgAABAgQIECBgELoBAgQIECBAgAABAgQIRAUMwmjxYhMgQIAAAQIECBAgQMAgdAMECBAgQIAAAQIECBCIChiE0eLFJkCAAAECBAgQIECAgEHoBggQIECAAAECBAgQIBAVMAijxYtNgAABAgQIECBAgAABg9ANECBAgAABAgQIECBAICpgEEaLF5sAAQIECBAgQIAAAQIGoRsgQIAAAQIECBAgQIBAVMAgjBYvNgECBAgQIECAAAECBAxCN0CAAAECBAgQIECAAIGogEEYLV5sAgQIECBAgAABAgQIGIRugAABAgQIECBAgAABAlEBgzBavNgECBAgQIAAAQIECBAwCN0AAQIECBAgQIAAAQIEogIGYbR4sQkQIECAAAECBAgQIGAQugECBAgQIECAAAECBAhEBQzCaPFiEyBAgAABAgQIECBAwCB0AwQIECBAgAABAgQIEIgKGITR4sUmQIAAAQIECBAgQICAQegGCBAgQIAAAQIECBAgEBUwCKPFi02AAAECBAgQIECAAAGD0A0QIECAAAECBAgQIEAgKmAQRosXmwABAgQIECBAgAABAgahGyBAgAABAgQIECBAgEBUwCCMFi82AQIECBAgQIAAAQIEDEI3QIAAAQIECBAgQIAAgaiAQRgtXmwCBAgQIECAAAECBAgYhG6AAAECBAgQIECAAAECUQGDMFq82AQIECBAgAABAgQIEDAI3QABAgQIECBAgAABAgSiAgZhtHixCRAgQIAAAQIECBAgYBC6AQIECBAgQIAAAQIECEQFDMJo8WITIECAAAECBAgQIEDAIHQDBAgQIECAAAECBAgQiAoYhNHixSZAgAABAgQIECBAgIBB6AYIECBAgAABAgQIECAQFTAIo8WLTYAAAQIECBAgQIAAAYPQDRAgQIAAAQIECBAgQCAqYBBGixebAAECBAgQIECAAAECBqEbIECAAAECBAgQIECAQFTAIIwWLzYBAgQIECBAgAABAgQMQjdAgAABAgQIECBAgACBqIBBGC1ebAIECBAgQIAAAQIECBiEboAAAQIECBAgQIAAAQJRAYMwWrzYBAgQIECAAAECBAgQMAjdAAECBAgQIECAAAECBKICBmG0eLEJECBAgAABAgQIECBgELoBAgQIECBAgAABAgQIRAUMwmjxYhMgQIAAAQIECBAgQMAgdAMECBAgQIAAAQIECBCIChiE0eLFJkCAAAECBAgQIECAgEHoBggQIECAAAECBAgQIBAVMAijxYtNgAABAgQIECBAgAABg9ANECBAgAABAgQIECBAICpgEEaLF5sAAQIECBAgQIAAAQIGoRsgQIAAAQIECBAgQIBAVMAgjBYvNgECBAgQIECAAAECBAxCN0CAAAECBAgQIECAAIGogEEYLV5sAgQIECBAgAABAgQIGIRugAABAgQIECBAgAABAlEBgzBavNgECBAgQIAAAQIECBAwCN0AAQIECBAgQIAAAQIEogIGYbR4sQkQIECAAAECBAgQIGAQugECBAgQIECAAAECBAhEBQzCaPFiEyBAgAABAgQIECBAwCB0AwQIECBAgAABAgQIEIgKGITR4sUmQIAAAQIECBAgQICAQegGCBAgQIAAAQIECBAgEBUwCKPFi02AAAECBAgQIECAAAGD0A0QIECAAAECBAgQIEAgKmAQRosXmwABAgQIECBAgAABAgahGyBAgAABAgQIECBAgEBUwCCMFi82AQIECBAgQIAAAQIEDEI3QIAAAQIECBAgQIAAgaiAQRgtXmwCBAgQIECAAAECBAgYhG6AAAECBAgQIECAAAECUQGDMFq82AQIECBAgAABAgQIEDAI3QABAgQIECBAgAABAgSiAgZhtHixCRAgQIAAAQIECBAgYBC6AQIECBAgQIAAAQIECEQFDMJo8WITIECAAAECBAgQIEDAIHQDBAgQIECAAAECBAgQiAoYhNHixSZAgAABAgQIECBAgIBB6AYIECBAgAABAgQIECAQFTAIo8WLTYAAAQIECBAgQIAAAYPQDRAgQIAAAQIECBAgQCAqYBBGixebAAECBAgQIECAAAECBqEbIECAAAECBAgQIECAQFTAIIwWLzYBAgQIECBAgAABAgQMQjdAgAABAgQIECBAgACBqIBBGC1ebAIECBAgQIAAAQIECBiEboAAAQIECBAgQIAAAQJRAYMwWrzYBAgQIECAAAECBAgQMAjdAAECBAgQIECAAAECBKICt6K5xb5mgd/85jeXV1555fLWW29d85f88gQIECBAgACBvQLvvffe5Xvf+97eB3pZXsDvEOZP4NEC/P73v7/84Ac/uPzwhz80Bh8trV+NAAECBAgQuIECzzzzzOVnP/vZ5f3337+Br/fkgsDVp5/9UQgq4/ULvPHGG5eXXnrp+j/kCwQIECBAgACBGyjw9ttvX370ox/dwJd78pkFDMIztzuY7erqavBrPkWAAAECBAgQuJkCr7322uUnP/nJzXy8V59SwN8yespaZ0Pd/51BfxAgQIAAAQIECHy5wMsvv3z57W9/++V/oj+DwJCA3yEcgj7rZ959993Ls88+e9Z4chEgQIAAAQIErkXgj3/84+X27dvX8mv7RQk8iIDfIXwQLX/ufwi8/vrr//EzPyBAgAABAgQIEPjfAvf/29j9QWCDgN8h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IEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAABAgQIEKgLGIT1C5CfAAECBAgQIECAAIGsgEGYrV5wAgQIECBAgAABAgTqAgZh/QLkJ0CAAAECBAgQIEAgK2AQZqsXnAABAgQIECBAgACBuoBBWL8A+QkQIECAAAECBAgQyAoYhNnqBSdAgAABAgQIECBAoC5gENYvQH4CBAgQIECAAAECBLICBmG2esEJECBAgAAB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AgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBAgAABAgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBAgAABAgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBAgAABAgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBAgAABAgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBAgAABAgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBAgAABAgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBAgAABAgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBAgAABAgQIECBwegGD8PQVC0iAAAECBAgQIECAAIFjAYPw2MVPCRAgQIAAAQIECBAgcHoBg/D0FQtIgAABAgQIECBAgACBYwGD8NjFTwkQIECAAAECBAgQIHB6AYPw9BULSIAAAQIECBAgQIAAgWMBg/DYxU8JECBA4IYK3L1794a+3LMJfH2BX/3qV1//F/ErECCQErj69LM/UomFfWQCV1dXj+zX8gsRIECAAAECBIoC/qN4sfVdmf0O4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirD68hQIAAAQIECBAgQIDAmIBBOEbtQwQIECBAgAABAgQIENglYBDu6sNrCBAgQIAAAQIECBAgMCZgEI5R+xABAgQIECBAgAABAgR2CRiEu/rwGgIECBAgQIAAAQIECIwJGIRj1D5EgAABAgQIECBAgACBXQIG4a4+vIYAAQIECBAgQIAAAQJjAgbhGLUPESBAgAABAgQIECBAYJeAQbirjxv1mh//+Mc36r0eS4AAAQIECBAgQIDAFwWuPv3sjy/+yD8i8NUE/vSnP12ef/75r/Yn+7MIECBAgAABAgS+IHDv3r3Lt771rS/8zD8gMC3gdwinxU/0vdu3b19efPHFEyUShQABAgQIECAwI/Dqq68agzPUvvIlAn6H8EuA/NP/W+DPf/7z5bvf/e7//pP8swQIECBAgAABAl8Q+Pjjjy+3bt36ws/8AwLfhIDfIfwm1E/0zaeffvry61//+kSJRCFAgAABAgQIXK/AO++8YwxeL7Ff/QEE/A7hA2D5U/+7wBNPPHG5e/fuf/8T/DMECBAgQIAAAQKX+/+lfG+++SYJAmsE/A7hmipu9kP++c9/Xn73u9/d7BBeT4AAAQIECBC4RoH7/1nJGLxGYL/0QwkYhA/F5i86Evj+979/+etf/3q5/38k7Q8CBAgQIECAAIH/F3j55Zcv9/+X5/f/s5I/CGwT8LeMbmvkJO/529/+dvn2t799kjRiECBAgAABAgQeXOD+fxv7nTt3Lt/5znce/C/2VxAYEjAIh6B9hgABAgQIECBAgAABAtsE/C2j2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBCZKUs/AAAFZ0lEQVQgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQIG4bZGvIcAAQIECBAgQIAAAQJDAgbhELTPECBAgAABAgQIECBAYJuAQbitEe8hQIAAAQIECBAgQIDAkIBBOATtMwQIECBAgAABAgQIENgmYBBua8R7CBAgQIAAAQIECBAgMCRgEA5B+wwBAgQIECBAgAABAgS2CRiE2xrxHgIECBAgQIAAAQIECAwJGIRD0D5DgAABAgQIECBAgACBbQL/Akwc5rVxSa84AAAAAElFTkSuQmCC", KilocodeLogoImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIABAMAAAAGVsnJAAAACXBIWXMAAAsSAAALEgHS3X78AAAAIVBMVEUAAAAwMDBAQEBgYGCAgICQkJCgoKDAwMDQ0NDw8PD////lRaZBAAADQElEQVR42u3dMW4TURSGUUdPKBI7oEOUVFOnpmIDtCyBAgnBUlwhRhqHrJKSGcczc19j2feer4wd2zn6K3ueczhIkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRl6O3LTfQbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuALA7C6P66/11/8fn84f+eFYHODwrjpAzwRSAvRMICdAxwRyAnRMIClAfAJJAeITyAoQnkBWgPAE0gJEJ5AWIDqBvADBCeQFCE4gMUBsAokBYhPIDPAIAAAAAAAApAf4+2NeQYDorwO4P4D2adGX2dKPJQDOapE/KDPA4ak6QKsOEJlAboBWHSAwgeQArTrA/gSyA7TqALsTSA/QqgPsTSA/QKsOsDOBAgCtOsD2BCoAtOoAmxMoAdCqA2xNoAZAqw6wMYFUAA8fFr2PTMAHIwAAVAM4xZ4PAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuEGA2bGQn8tbTpdPjCwPTa12NwBXDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3Nfb4vOew2+HJ/pgZN6f18/zVB2gVQfYmUABgFYdYHsCFQBadYDNCZQAaNUBtiZQA6BVB9iYQBGAVh1gfQJVAFp1gNUJlAFo1QEOAAAAAAAAwF0DrPQ8+7Kpj8ubvpUAOK0/KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO4C4M36N4MdLwM8Lu/1ffa/6+8RYKPYt8l93t8PAAAAAAAAcEsAX3sBXoZcAFM3wJgLIDaBxXWCQy6AqRtgzAUQmsDyStEhF8DUDTDmAohM4Oxa4SEXwNQNMOYCCEzg/GrxIRfA1A0w5gLYn8Cr8wJDLoCpG2DMBbA7gdcnRoZcAFM3wJgLYG8CF84MDbkApm6AMRfAtQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkSZIkSZIkSZIkSZIkSZIkSZIkSZIkSZIkSZIkSZIkSZIkSZIkSZIkSZIkSZJutX+ROb5kGqaiGgAAAABJRU5ErkJggg==", ClaudeCodeLogoImg = "data:image/png;base64,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";
function DiscordLogo({
  size: size2 = 24,
  color = "#5865F2",
  width,
  height,
  ...props
}) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      role: "img",
      viewBox: "0 0 24 24",
      xmlns: "http://www.w3.org/2000/svg",
      width: width || size2,
      height: height || size2,
      fill: color,
      ...props,
      children: [
        /* @__PURE__ */ jsx("title", { children: "Discord" }),
        /* @__PURE__ */ jsx("path", { d: "M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189Z" })
      ]
    }
  );
}
const agentStateToText = {
  [AgentStateType.WAITING_FOR_USER_RESPONSE]: "Waiting for user response",
  [AgentStateType.IDLE]: "",
  [AgentStateType.THINKING]: "Thinking",
  [AgentStateType.FAILED]: "Failed",
  [AgentStateType.COMPLETED]: "Completed",
  [AgentStateType.WORKING]: "Working",
  [AgentStateType.CALLING_TOOL]: "Calling tool"
}, agentStateToIcon = {
  [AgentStateType.WAITING_FOR_USER_RESPONSE]: /* @__PURE__ */ jsx(MessageCircleQuestionMark, { className: "size-6" }),
  [AgentStateType.IDLE]: /* @__PURE__ */ jsx(Fragment$1, {}),
  [AgentStateType.THINKING]: /* @__PURE__ */ jsx(LoaderCircle, { className: "size-6 animate-spin stroke-violet-600" }),
  [AgentStateType.FAILED]: /* @__PURE__ */ jsx(CircleX, { className: "size-6 stroke-rose-600" }),
  [AgentStateType.COMPLETED]: /* @__PURE__ */ jsx(Check, { className: "size-6 stroke-green-600" }),
  [AgentStateType.WORKING]: /* @__PURE__ */ jsx(LoaderCircle, { className: "size-6 animate-spin stroke-blue-600" }),
  [AgentStateType.CALLING_TOOL]: /* @__PURE__ */ jsx(Cog, { className: "size-6 animate-spin stroke-fuchsia-700" })
}, getAgentLogo = (name, description) => {
  const searchText = `${name} ${description}`.toLowerCase();
  return searchText.includes("cursor") ? CursorLogoImg : searchText.includes("windsurf") ? WindsurfLogoImg : searchText.includes("cline") ? ClineLogoImg : searchText.includes("roo") && searchText.includes("code") ? RooCodeLogoImg : searchText.includes("trae") ? TraeLogoImg : searchText.includes("kilocode") || searchText.includes("kilo-code") ? KilocodeLogoImg : searchText.includes("github") || searchText.includes("copilot") ? GithubCopilotLogoImg : searchText.includes("claude") ? ClaudeCodeLogoImg : null;
};
function ChatPanel() {
  var _a;
  const agentState = useAgentState(), chatState = useChatState(), chatMessaging = useAgentMessaging(), trackCopyToClipboard = useKartonProcedure(
    (p2) => p2.trackCopyToClipboard
  ), [isComposing, setIsComposing] = useState(!1), [isCopied, setIsCopied] = useState(!1), [selectedAgent, setSelectedAgent] = useState(
    "clipboard"
  ), { connected, availableAgents, connectAgent, disconnectAgent } = useAgents(), { plugins: plugins2 } = usePlugins(), { openInfo } = usePanels(), enableInputField = useMemo(() => connected ? agentState.state === AgentStateType.WAITING_FOR_USER_RESPONSE || agentState.state === AgentStateType.IDLE : !0, [agentState.state, connected]), canSendMessage = useMemo(() => enableInputField && chatState.chatInput.trim().length > 2 && chatState.isPromptCreationActive, [enableInputField, chatState.chatInput, chatState.isPromptCreationActive]), anyMessageInChat = useMemo(() => {
    var _a2, _b;
    return ((_b = (_a2 = chatMessaging.agentMessage) == null ? void 0 : _a2.contentItems) == null ? void 0 : _b.length) > 0;
  }, [(_a = chatMessaging.agentMessage) == null ? void 0 : _a.contentItems]), handleSubmit = useCallback(() => {
    chatState.sendMessage(), chatState.stopPromptCreation();
  }, [chatState]), buildFullPrompt = useCallback(async () => {
    const metadata = collectUserMessageMetadata(
      chatState.domContextElements.map(
        (item) => getSelectedElementInfo(item.element)
      )
    ), pluginProcessingPromises = plugins2.map(async (plugin) => {
      var _a2;
      try {
        const baseUserMessage = {
          id: "",
          createdAt: /* @__PURE__ */ new Date(),
          contentItems: [{ type: "text", text: chatState.chatInput }],
          metadata,
          pluginContent: {},
          sentByPlugin: !1
        }, handlerResult = await ((_a2 = plugin.onPromptSend) == null ? void 0 : _a2.call(plugin, baseUserMessage));
        if (!handlerResult || !handlerResult.contextSnippets || handlerResult.contextSnippets.length === 0)
          return null;
        const snippetPromises = handlerResult.contextSnippets.map(
          async (snippet) => {
            try {
              const resolvedContent = typeof snippet.content == "string" ? snippet.content : await snippet.content();
              return {
                promptContextName: snippet.promptContextName,
                content: resolvedContent
              };
            } catch (snippetError) {
              return console.error(
                `Failed to resolve snippet for plugin ${plugin.pluginName}:`,
                snippetError
              ), null;
            }
          }
        ), validSnippets = (await Promise.all(snippetPromises)).filter(
          (snippet) => snippet !== null
        );
        return validSnippets.length > 0 ? {
          pluginName: plugin.pluginName,
          contextSnippets: validSnippets
        } : null;
      } catch (pluginError) {
        return console.error(
          `Failed to process plugin ${plugin.pluginName}:`,
          pluginError
        ), null;
      }
    }), validPluginContexts = (await Promise.all(pluginProcessingPromises)).filter(
      (context) => context !== null
    );
    return createPrompt(
      chatState.domContextElements.map((item) => item.element),
      chatState.chatInput,
      metadata.currentUrl || "",
      validPluginContexts
    );
  }, [chatState.chatInput, chatState.domContextElements, plugins2]), handleCopyToClipboard = useCallback(async () => {
    if (trackCopyToClipboard(), chatState.chatInput.trim())
      try {
        const fullPrompt = await buildFullPrompt();
        await navigator.clipboard.writeText(fullPrompt), chatState.setChatInput(""), chatState.stopPromptCreation(), copyTimeoutRef.current && clearTimeout(copyTimeoutRef.current), setIsCopied(!0), copyTimeoutRef.current = setTimeout(() => {
          setIsCopied(!1), copyTimeoutRef.current = null;
        }, 1e3);
      } catch (error2) {
        console.error("Failed to copy prompt to clipboard:", error2);
      }
  }, [chatState, buildFullPrompt]), handleKeyDown = useCallback(
    (e2) => {
      e2.key === "Enter" && !e2.shiftKey && !isComposing && (e2.preventDefault(), connected ? canSendMessage && handleSubmit() : handleCopyToClipboard());
    },
    [
      handleSubmit,
      handleCopyToClipboard,
      isComposing,
      connected,
      canSendMessage
    ]
  ), handleCompositionStart = useCallback(() => {
    setIsComposing(!0);
  }, []), handleCompositionEnd = useCallback(() => {
    setIsComposing(!1);
  }, []), inputRef = useRef(null), isIntentionallyStoppingRef = useRef(!1), copyTimeoutRef = useRef(null);
  return useEffect(() => {
    connected != null && connected.port ? setSelectedAgent(connected.port) : setSelectedAgent("clipboard");
  }, [connected == null ? void 0 : connected.port]), useEffect(() => {
    var _a2, _b, _c;
    const blurHandler = () => {
      var _a3;
      if (isIntentionallyStoppingRef.current) {
        isIntentionallyStoppingRef.current = !1;
        return;
      }
      (_a3 = inputRef.current) == null || _a3.focus();
    };
    return chatState.isPromptCreationActive && enableInputField ? ((_a2 = inputRef.current) == null || _a2.focus(), (_b = inputRef.current) == null || _b.addEventListener("blur", blurHandler), isIntentionallyStoppingRef.current = !1) : (inputRef.current === document.activeElement && (isIntentionallyStoppingRef.current = !0), (_c = inputRef.current) == null || _c.blur()), () => {
      var _a3;
      (_a3 = inputRef.current) == null || _a3.removeEventListener("blur", blurHandler);
    };
  }, [chatState.isPromptCreationActive, enableInputField]), /* @__PURE__ */ jsxs(
    Panel,
    {
      className: cn(
        anyMessageInChat ? "h-[35vh] max-h-[50vh] min-h-[20vh]" : "!h-[calc-size(auto,size)] h-auto min-h-0"
      ),
      children: [
        /* @__PURE__ */ jsx(
          PanelHeader,
          {
            className: cn(
              "mb-0 origin-bottom transition-all duration-300 ease-out",
              agentState.state !== AgentStateType.IDLE ? "!h-[calc-size(auto,size)] h-auto" : "h-0 scale-x-75 scale-y-0 p-0 opacity-0 blur-md"
            ),
            title: /* @__PURE__ */ jsx("span", { className: "text-base", children: agentStateToText[agentState.state] }),
            description: agentState.description && /* @__PURE__ */ jsx("span", { className: "text-sm", children: agentState.description }),
            iconArea: /* @__PURE__ */ jsx("div", { className: "flex size-8 items-center justify-center", children: Object.values(AgentStateType).map((state) => /* @__PURE__ */ jsx(StateIcon, { shouldRender: agentState.state === state, children: agentStateToIcon[state] }, state)) }),
            actionArea: /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx("div", { className: "-z-10 pointer-events-none absolute inset-0 overflow-hidden rounded-[inherit] opacity-50", children: /* @__PURE__ */ jsx(
              GradientBackgroundChat,
              {
                className: "size-full",
                currentVariant: agentState.state,
                variants: GradientBackgroundVariants,
                transparent: agentState.state === AgentStateType.IDLE
              }
            ) }) })
          }
        ),
        /* @__PURE__ */ jsx(
          PanelContent,
          {
            className: cn(
              "flex basis-[initial] flex-col gap-0 px-1 py-0",
              anyMessageInChat ? "!h-[calc-size(auto,size)] h-auto flex-1" : "h-0",
              agentState.state === AgentStateType.IDLE ? "rounded-t-[inherit]" : "rounded-t-none",
              "mask-alpha mask-[linear-gradient(to_bottom,transparent_0px,black_48px,black_calc(95%_-_16px),transparent_calc(100%_-_16px))]",
              "overflow-hidden"
            ),
            children: /* @__PURE__ */ jsx(AgentMessageDisplay, {})
          }
        ),
        /* @__PURE__ */ jsxs(
          PanelFooter,
          {
            className: cn(
              "mt-0 flex origin-top flex-col items-stretch gap-1 px-2 pt-1 pb-2 duration-150 ease-out",
              !enableInputField && "pointer-events-none opacity-80 brightness-75",
              chatState.isPromptCreationActive && "bg-blue-400/10",
              !anyMessageInChat && agentState.state === AgentStateType.IDLE && "rounded-t-[inherit] border-transparent border-t-none pt-3"
            ),
            children: [
              /* @__PURE__ */ jsx(ContextElementsChips, {}),
              /* @__PURE__ */ jsxs("div", { className: "flex flex-col gap-2", children: [
                /* @__PURE__ */ jsxs("div", { className: "relative w-full", children: [
                  /* @__PURE__ */ jsx(
                    J,
                    {
                      ref: inputRef,
                      value: chatState.chatInput,
                      onChange: (e2) => {
                        chatState.setChatInput(e2.target.value);
                      },
                      onFocus: () => {
                        chatState.isPromptCreationActive || (chatState.startPromptCreation(), chatState.startContextSelector());
                      },
                      onKeyDown: handleKeyDown,
                      onCompositionStart: handleCompositionStart,
                      onCompositionEnd: handleCompositionEnd,
                      disabled: !enableInputField,
                      className: "m-1 h-16 w-full resize-none focus:outline-none"
                    }
                  ),
                  /* @__PURE__ */ jsx("div", { className: "pointer-events-none absolute inset-0 z-10 p-1", children: /* @__PURE__ */ jsx(
                    TextSlideshow,
                    {
                      className: cn(
                        "text-foreground/40 text-sm",
                        chatState.chatInput.length !== 0 && "opacity-0"
                      ),
                      texts: [
                        "Try: Add a new button into the top right corner",
                        "Try: Convert these cards into accordions",
                        "Try: Add a gradient to the background"
                      ]
                    }
                  ) })
                ] }),
                /* @__PURE__ */ jsxs("div", { className: "flex flex-row items-center justify-end gap-4", children: [
                  /* @__PURE__ */ jsx(
                    Select,
                    {
                      value: selectedAgent,
                      onChange: (value) => {
                        if (value === "connect-other-agents") {
                          openInfo(), setSelectedAgent("clipboard");
                          return;
                        }
                        if (setSelectedAgent(value), value === "clipboard") {
                          disconnectAgent(!0);
                          return;
                        }
                        const port = typeof value == "number" ? value : Number.parseInt(String(value));
                        port && !Number.isNaN(port) && connectAgent(port);
                      },
                      items: [
                        {
                          label: "Copy Mode",
                          value: "clipboard"
                        },
                        ...availableAgents.map((agent) => {
                          const logo = getAgentLogo(agent.name, agent.description);
                          return {
                            label: `${agent.name} - ${agent.description} - Port ${agent.port}`,
                            value: agent.port,
                            icon: logo ? /* @__PURE__ */ jsx(
                              "img",
                              {
                                src: logo,
                                alt: `${agent.name} logo`,
                                className: "size-4 object-contain"
                              }
                            ) : null
                          };
                        }),
                        {
                          label: "Connect other agents...",
                          value: "connect-other-agents",
                          icon: /* @__PURE__ */ jsx(Plus, { className: "size-4" })
                        }
                      ],
                      placeholder: "Select destination...",
                      className: "h-8 w-max max-w-48 border-none bg-transparent shadow-none hover:bg-blue-400/10 hover:shadow-none"
                    }
                  ),
                  /* @__PURE__ */ jsxs("div", { className: "flex shrink-0 flex-row gap-2", children: [
                    chatState.isPromptCreationActive && /* @__PURE__ */ jsxs(Tooltip, { children: [
                      /* @__PURE__ */ jsx(TooltipTrigger, { children: /* @__PURE__ */ jsx(
                        Button,
                        {
                          onMouseDown: (e2) => {
                            e2.preventDefault();
                          },
                          onClick: (e2) => {
                            var _a2;
                            e2.preventDefault(), e2.stopPropagation(), chatState.isContextSelectorActive ? chatState.stopContextSelector() : chatState.startContextSelector(), (_a2 = inputRef.current) == null || _a2.focus();
                          },
                          "aria-label": "Select context elements",
                          variant: "ghost",
                          className: cn(
                            "size-8 cursor-pointer rounded-full border-none bg-transparent p-1 backdrop-blur-lg",
                            chatState.isContextSelectorActive ? "bg-blue-600/10 text-blue-600" : "text-zinc-500 opacity-70"
                          ),
                          children: /* @__PURE__ */ jsx(MousePointer, { className: "size-4" })
                        }
                      ) }),
                      /* @__PURE__ */ jsx(TooltipContent, { children: chatState.isContextSelectorActive ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
                        "Stop selecting elements (",
                        /* @__PURE__ */ jsx(HotkeyComboText, { action: HotkeyActions.ESC }),
                        ")"
                      ] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
                        "Add reference elements (",
                        /* @__PURE__ */ jsx(
                          HotkeyComboText,
                          {
                            action: HotkeyActions.CTRL_ALT_PERIOD
                          }
                        ),
                        ")"
                      ] }) })
                    ] }),
                    !connected && /* @__PURE__ */ jsx(
                      Button,
                      {
                        disabled: !chatState.chatInput.trim() && !isCopied,
                        onClick: handleCopyToClipboard,
                        glassy: !0,
                        variant: "primary",
                        className: "h-8 cursor-pointer",
                        children: /* @__PURE__ */ jsxs(
                          "div",
                          {
                            className: cn(
                              "flex items-center justify-center gap-2 transition-all duration-300 ease-out"
                            ),
                            children: [
                              /* @__PURE__ */ jsx("div", { children: isCopied ? "Copied" : "Copy" }),
                              isCopied ? /* @__PURE__ */ jsx(Check, { className: "size-4" }) : /* @__PURE__ */ jsx(Copy, { className: "size-4" })
                            ]
                          }
                        )
                      }
                    ),
                    connected && /* @__PURE__ */ jsx(
                      Button,
                      {
                        disabled: !canSendMessage,
                        onClick: handleSubmit,
                        glassy: !0,
                        variant: "primary",
                        className: "size-8 cursor-pointer rounded-full p-1",
                        children: /* @__PURE__ */ jsx(ArrowUp, { className: "size-4 stroke-3" })
                      }
                    )
                  ] })
                ] })
              ] })
            ]
          }
        )
      ]
    }
  );
}
const StateIcon = ({
  children,
  shouldRender
}) => /* @__PURE__ */ jsx(
  "div",
  {
    className: cn(
      "absolute origin-center transition-all duration-500 ease-spring-soft",
      shouldRender ? "scale-100" : "scale-0 opacity-0 blur-md"
    ),
    children
  }
), GradientBackgroundVariants = {
  [AgentStateType.WAITING_FOR_USER_RESPONSE]: {
    activeSpeed: "slow",
    backgroundColor: "var(--color-blue-200)",
    colors: [
      "var(--color-blue-200)",
      "var(--color-indigo-400)",
      "var(--color-sky-100)",
      "var(--color-cyan-200)"
    ]
  },
  [AgentStateType.IDLE]: {
    activeSpeed: "slow",
    backgroundColor: "var(--color-white/0)",
    colors: [
      "var(--color-white/0)",
      "var(--color-white/0)",
      "var(--color-white/0)",
      "var(--color-white/0)"
    ]
  },
  [AgentStateType.THINKING]: {
    activeSpeed: "medium",
    backgroundColor: "var(--color-blue-400)",
    colors: [
      "var(--color-orange-300)",
      "var(--color-teal-300)",
      "var(--color-fuchsia-400)",
      "var(--color-indigo-200)"
    ]
  },
  [AgentStateType.WORKING]: {
    activeSpeed: "medium",
    backgroundColor: "var(--color-indigo-400)",
    colors: [
      "var(--color-sky-300)",
      "var(--color-teal-500)",
      "var(--color-violet-400)",
      "var(--color-indigo-200)"
    ]
  },
  [AgentStateType.CALLING_TOOL]: {
    activeSpeed: "fast",
    backgroundColor: "var(--color-fuchsia-400)",
    colors: [
      "var(--color-fuchsia-400)",
      "var(--color-violet-400)",
      "var(--color-indigo-500)",
      "var(--color-purple-200)"
    ]
  },
  [AgentStateType.FAILED]: {
    activeSpeed: "slow",
    backgroundColor: "var(--color-red-200)",
    colors: [
      "var(--color-red-100)",
      "var(--color-rose-300)",
      "var(--color-fuchsia-400)",
      "var(--color-indigo-300)"
    ]
  },
  [AgentStateType.COMPLETED]: {
    activeSpeed: "slow",
    backgroundColor: "var(--color-green-400)",
    colors: [
      "var(--color-green-300)",
      "var(--color-teal-400)",
      "var(--color-emerald-500)",
      "var(--color-lime-200)"
    ]
  }
}, agents = [
  {
    id: "claude",
    name: "Claude Code",
    domain: "claude.com",
    logo: ClaudeCodeLogoImg,
    appName: "claude",
    clipboard: !0
  },
  {
    id: "cursor",
    name: "Cursor.com",
    domain: "cursor.com",
    logo: CursorLogoImg,
    appName: "cursor"
  },
  {
    id: "windsurf",
    name: "Windsurf.com",
    domain: "windsurf.com",
    logo: WindsurfLogoImg,
    appName: "windsurf"
  },
  {
    id: "trae",
    name: "Trae",
    domain: "trae.ai",
    logo: TraeLogoImg,
    appName: "trae"
  },
  {
    id: "cline",
    name: "Cline.bot",
    domain: "cline.bot",
    logo: ClineLogoImg,
    appName: "code"
  },
  {
    id: "copilot",
    name: "GitHub Copilot",
    domain: "github.com/features/copilot",
    logo: GithubCopilotLogoImg,
    appName: "code"
  },
  {
    id: "roocode",
    name: "Roo-Code",
    domain: "roocline.dev/",
    logo: RooCodeLogoImg,
    appName: "code"
  },
  {
    id: "kilocode",
    name: "Kilo-Code",
    domain: "kilocode.ai",
    logo: KilocodeLogoImg,
    appName: "code"
  }
];
function getAgentExtensionUrl(agent) {
  switch (agent.id) {
    case "cline":
    case "roocode":
    case "copilot":
    case "kilocode":
      return "vscode:extension/stagewise.stagewise-vscode-extension";
    default:
      return `${agent.id}:extension/stagewise.stagewise-vscode-extension`;
  }
}
function InfoPanel() {
  const { availableAgents, connected } = useAgents(), isInstalled = (appName) => {
    const allAgents = [...availableAgents];
    return connected && allAgents.push(connected), allAgents.some((agent) => {
      const agentNameLower = (agent.name || "").toLowerCase(), agentDescLower = (agent.description || "").toLowerCase(), searchId = appName.toLowerCase();
      return agentNameLower.includes(searchId) || agentDescLower.includes(searchId);
    });
  };
  return /* @__PURE__ */ jsxs(Panel, { children: [
    /* @__PURE__ */ jsx(PanelHeader, { title: "Connect Your Agent" }),
    /* @__PURE__ */ jsxs(PanelContent, { className: "flex flex-col gap-2 px-3", children: [
      /* @__PURE__ */ jsx("p", { className: "mb-2 text-sm text-zinc-600 leading-relaxed", children: "To connect your agent, simply install the stagewise extension." }),
      /* @__PURE__ */ jsx("div", { className: "scrollbar-thin scrollbar-thumb-black/15 scrollbar-track-transparent max-h-48 overflow-hidden overflow-y-auto rounded-2xl border border-zinc-200 bg-white", children: agents.map((agent, index2) => /* @__PURE__ */ jsxs(
        "div",
        {
          className: `flex items-center justify-between p-2 ${index2 !== agents.length - 1 ? "border-zinc-100 border-b" : ""}`,
          children: [
            /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-3", children: [
              /* @__PURE__ */ jsx(
                "img",
                {
                  src: agent.logo,
                  alt: `${agent.name} logo`,
                  className: "size-4 object-contain"
                }
              ),
              /* @__PURE__ */ jsx("span", { className: "font-regular text-sm text-zinc-900", children: agent.name })
            ] }),
            !isInstalled(agent.appName) && !agent.clipboard && /* @__PURE__ */ jsx(
              Button,
              {
                onClick: () => {
                  window.open(
                    getAgentExtensionUrl(agent),
                    "_blank",
                    "noopener,noreferrer"
                  );
                },
                variant: "secondary",
                size: "sm",
                className: "h-8 bg-zinc-100 px-4 text-xs hover:bg-zinc-200",
                glassy: !0,
                children: "Install the extension"
              }
            ),
            " ",
            isInstalled(agent.appName) && !agent.clipboard && /* @__PURE__ */ jsx(
              Button,
              {
                variant: "secondary",
                size: "sm",
                className: "h-8 px-4 text-xs",
                glassy: !0,
                disabled: !0,
                children: "Connected"
              }
            ),
            agent.clipboard && /* @__PURE__ */ jsxs(Tooltip, { children: [
              /* @__PURE__ */ jsx(TooltipTrigger, { children: /* @__PURE__ */ jsx("span", { className: "inline-block", children: /* @__PURE__ */ jsx(
                Button,
                {
                  variant: "secondary",
                  size: "sm",
                  className: "h-8 px-4 text-xs",
                  disabled: !0,
                  glassy: !0,
                  children: "Via Copy Mode"
                }
              ) }) }),
              /* @__PURE__ */ jsx(TooltipContent, { children: /* @__PURE__ */ jsxs("p", { children: [
                "Use the copy mode to copy and paste prompts to",
                " ",
                agent.name,
                "."
              ] }) })
            ] })
          ]
        },
        agent.id
      )) })
    ] }),
    /* @__PURE__ */ jsx(PanelFooter, { children: /* @__PURE__ */ jsxs("div", { className: "flex w-full items-center justify-center gap-2 py-2", children: [
      /* @__PURE__ */ jsx(DiscordLogo, { className: "size-4" }),
      /* @__PURE__ */ jsx(
        "a",
        {
          rel: "noreferrer noopener",
          className: "text-xs text-zinc-600 underline hover:text-zinc-900",
          href: "https://discord.gg/gkdGsDYaKA",
          target: "_blank",
          children: "Join the Discord!"
        }
      ),
      /* @__PURE__ */ jsx("div", { className: "w-2" }),
      /* @__PURE__ */ jsx(
        "img",
        {
          src: StagewiseLogoImg,
          alt: "Stagewise logo",
          className: "size-4 object-contain"
        }
      ),
      /* @__PURE__ */ jsx(
        "a",
        {
          rel: "noreferrer noopener",
          className: "text-xs text-zinc-600 underline hover:text-zinc-900",
          href: "https://stagewise.io/docs",
          target: "_blank",
          children: "Read the docs"
        }
      )
    ] }) })
  ] });
}
const TOOLBAR_POSITION_KEY = "stagewise_toolbar_toolbar_position";
function getStoredToolbarPosition() {
  try {
    const stored = localStorage.getItem(TOOLBAR_POSITION_KEY);
    if (stored)
      return stored;
  } catch (error2) {
    console.warn("Failed to load toolbar position from localStorage:", error2);
  }
  return null;
}
function saveToolbarPosition(position) {
  try {
    position && localStorage.setItem(TOOLBAR_POSITION_KEY, position);
  } catch (error2) {
    console.warn("Failed to save toolbar position to localStorage:", error2);
  }
}
function DefaultLayout() {
  return /* @__PURE__ */ jsx(ContextChipHoverProvider, { children: /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn("pointer-events-none fixed inset-0 h-screen w-screen"),
      children: [
        /* @__PURE__ */ jsx(DOMContextSelector, {}),
        /* @__PURE__ */ jsx(DraggingArea, {})
      ]
    }
  ) });
}
function DraggingArea() {
  const containerRef = useRef(null), [isDragging, setIsDragging] = useState(!1);
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: cn(
        "absolute z-50 size-full transition-all duration-150 ease-out",
        isDragging ? "pointer-events-auto bg-black/10 backdrop-blur-[2px]" : ""
      ),
      children: /* @__PURE__ */ jsx("div", { className: "absolute inset-4", ref: containerRef, children: /* @__PURE__ */ jsx(
        DraggableProvider,
        {
          containerRef,
          snapAreas: {
            topLeft: !0,
            topRight: !0,
            bottomLeft: !0,
            bottomRight: !0,
            topCenter: !1,
            bottomCenter: !1
          },
          onDragStart: () => setIsDragging(!0),
          onDragEnd: () => setIsDragging(!1),
          children: /* @__PURE__ */ jsx(ToolbarAndPanelArea, {})
        }
      ) })
    }
  );
}
function ToolbarAndPanelArea() {
  const onNewSnapArea = useCallback(
    (snapArea) => {
      saveToolbarPosition(snapArea);
    },
    []
  ), initialSnapArea = useMemo(() => getStoredToolbarPosition() || "bottomRight", []), draggable = useDraggable({
    startThreshold: 5,
    initialSnapArea,
    onDragEnd: onNewSnapArea
  }), clickHandleRef = useRef(null);
  return useEffect(() => {
    const listener = (e2) => {
      if (draggable.wasDragged) {
        e2.preventDefault(), e2.stopPropagation();
        return;
      }
    };
    return window.addEventListener("click", listener, { capture: !0 }), () => {
      window.removeEventListener("click", listener, { capture: !0 });
    };
  }, [draggable]), /* @__PURE__ */ jsxs("div", { className: "absolute inset-0 z-50 size-full", children: [
    /* @__PURE__ */ jsx(
      Toolbar,
      {
        draggableHandleRef: (ref) => {
          draggable.handleRef(ref), draggable.draggableRef(ref), clickHandleRef.current = ref;
        },
        isDragged: draggable.isDragging,
        position: draggable.position
      }
    ),
    /* @__PURE__ */ jsx(
      PanelsArea,
      {
        position: draggable.position,
        isToolbarDragged: draggable.isDragging
      }
    )
  ] });
}
function PanelsArea({
  position,
  isToolbarDragged
}) {
  const { isChatOpen, isInfoOpen, openPluginName } = usePanels(), plugins2 = usePlugins(), pluginPanel = useMemo(() => {
    if (!openPluginName)
      return null;
    const plugin = plugins2.plugins.find(
      (plugin2) => plugin2.pluginName === openPluginName
    );
    if (!plugin)
      return null;
    const panelResult = plugin.onActionClick();
    return panelResult || null;
  }, [openPluginName, plugins2]);
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "absolute z-0 flex h-full w-96 max-w-[calc(100%-48px)] transition-all duration-500 ease-spring",
        position.isLeftHalf ? "left-12" : "right-12",
        position.isTopHalf ? "top-0 flex-col" : "bottom-0 flex-col-reverse",
        isToolbarDragged ? "scale-95 opacity-50 blur-md brightness-90" : "opacity-100"
      ),
      children: [
        /* @__PURE__ */ jsx(PanelWrapper, { position, isOpen: isChatOpen, children: /* @__PURE__ */ jsx(ChatPanel, {}) }),
        /* @__PURE__ */ jsx(PanelWrapper, { position, isOpen: isInfoOpen, children: /* @__PURE__ */ jsx(InfoPanel, {}) }),
        /* @__PURE__ */ jsx(PanelWrapper, { position, isOpen: !!pluginPanel, children: pluginPanel })
      ]
    }
  );
}
function PanelWrapper({
  children,
  position,
  isOpen
}) {
  const [shouldRender, setShouldRender] = useState(isOpen), stopRenderTimeoutRef = useRef(null);
  return useEffect(() => {
    isOpen ? (setShouldRender(!0), stopRenderTimeoutRef.current && (clearTimeout(stopRenderTimeoutRef.current), stopRenderTimeoutRef.current = null)) : stopRenderTimeoutRef.current = setTimeout(() => {
      setShouldRender(!1);
    }, 500);
  }, [isOpen]), useEffect(() => () => {
    stopRenderTimeoutRef.current && clearTimeout(stopRenderTimeoutRef.current);
  }, []), /* @__PURE__ */ jsx(
    "div",
    {
      className: cn(
        "h-[calc-size(auto,size)] transition-all duration-150 ease-out",
        position.isTopHalf ? "mb-3" : "mt-3",
        position.isLeftHalf ? "origin-left" : "origin-right",
        isOpen ? "" : "mt-0 mb-0 h-0 scale-0 opacity-0 blur-md"
      ),
      children: shouldRender && children
    }
  );
}
function MainAppBlocker() {
  const { isMainAppBlocked } = useAppState();
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: cn(
        "fixed inset-0 h-screen w-screen",
        isMainAppBlocked ? "pointer-events-auto" : "pointer-events-none"
      ),
      role: "button",
      tabIndex: 0
    }
  );
}
function UrlSynchronizer({
  appPort,
  urlSyncConfig
}) {
  const iframeRef = useRef(null), navigationState = useRef({
    isNavigating: !1,
    source: null,
    navigationId: null,
    timestamp: 0
  }), navigationQueue = useRef(Promise.resolve());
  return useEffect(() => {
    var _a;
    const iframe = document.getElementById(
      "user-app-iframe"
    );
    if (!iframe) return;
    iframeRef.current = iframe;
    const generateNavigationId = () => `nav-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`, lockNavigation = (source) => {
      const navId = generateNavigationId();
      return navigationState.current = {
        isNavigating: !0,
        source,
        navigationId: navId,
        timestamp: Date.now()
      }, navId;
    }, unlockNavigation = (navId) => {
      navigationState.current.navigationId === navId && (navigationState.current = {
        isNavigating: !1,
        source: null,
        navigationId: null,
        timestamp: 0
      });
    }, isNavigationLocked = (source) => {
      const state = navigationState.current;
      if (!state.isNavigating || state.source === source) return !1;
      const timeout = (urlSyncConfig == null ? void 0 : urlSyncConfig.navigationTimeout) || 500;
      return Date.now() - state.timestamp > timeout ? (navigationState.current = {
        isNavigating: !1,
        source: null,
        navigationId: null,
        timestamp: 0
      }, !1) : !0;
    }, syncParentToIframe = async () => {
      if (isNavigationLocked("parent")) return;
      const iframeWindow = iframe.contentWindow;
      if (!iframeWindow) return;
      const parentPath = window.location.pathname, parentSearch = window.location.search, parentHash = window.location.hash, newUrl = parentPath + parentSearch + parentHash;
      try {
        if (iframeWindow.location.href === "about:blank")
          return;
        if (iframeWindow.location.pathname + iframeWindow.location.search + iframeWindow.location.hash !== newUrl) {
          const navId = lockNavigation("parent");
          navigationQueue.current = navigationQueue.current.then(async () => {
            var _a2;
            try {
              (_a2 = iframeWindow.history) != null && _a2.replaceState ? iframeWindow.history.replaceState(null, "", newUrl) : iframeWindow.location.href = newUrl, await new Promise((resolve) => setTimeout(resolve, 150));
            } finally {
              unlockNavigation(navId);
            }
          }), await navigationQueue.current;
        }
      } catch (e2) {
        e2 instanceof DOMException && e2.name === "SecurityError" ? console.warn("Cannot sync to cross-origin iframe:", newUrl) : console.error("Failed to sync URL to iframe:", e2);
      }
    }, syncIframeToParent = async () => {
      if (console.debug("syncIframeToParent called"), isNavigationLocked("iframe")) {
        console.debug("Navigation locked by iframe, skipping sync");
        return;
      }
      const iframeWindow = iframe.contentWindow;
      if (!iframeWindow) {
        console.debug("No iframe contentWindow");
        return;
      }
      try {
        const iframePath = iframeWindow.location.pathname, iframeSearch = iframeWindow.location.search, iframeHash = iframeWindow.location.hash, newUrl = iframePath + iframeSearch + iframeHash, currentParentUrl = window.location.pathname + window.location.search + window.location.hash;
        if (console.debug("Comparing URLs:", { currentParentUrl, newUrl }), currentParentUrl !== newUrl) {
          console.debug("URLs differ, syncing parent to:", newUrl);
          const navId = lockNavigation("iframe");
          navigationQueue.current = navigationQueue.current.then(async () => {
            try {
              window.history.replaceState(null, "", newUrl), console.debug("Parent URL updated to:", newUrl), await new Promise((resolve) => setTimeout(resolve, 50));
            } finally {
              unlockNavigation(navId);
            }
          }), await navigationQueue.current;
        } else
          console.debug("URLs already in sync");
      } catch (e2) {
        e2 instanceof DOMException && e2.name === "SecurityError" ? console.warn("Cannot read cross-origin iframe URL") : console.error("Failed to sync URL from iframe:", e2);
      }
    }, handleIframeLoad = () => {
      syncParentToIframe();
      const shouldPatchLocation = (urlSyncConfig == null ? void 0 : urlSyncConfig.enableLocationPatching) !== !1;
      if (appPort && shouldPatchLocation)
        try {
          monkeyPatchLocation(iframe.contentWindow, appPort);
        } catch (e2) {
          console.warn("Failed to patch iframe location object:", e2);
        }
    }, handlePopState = () => {
      syncParentToIframe();
    }, debounce = (func, wait) => {
      let timeout;
      return (...args) => {
        clearTimeout(timeout), timeout = setTimeout(() => func(...args), wait);
      };
    };
    let lastIframeUrl = ((_a = iframe.contentWindow) == null ? void 0 : _a.location.href) || "";
    const checkIframeNavigation = debounce(() => {
      var _a2;
      try {
        const currentUrl = (_a2 = iframe.contentWindow) == null ? void 0 : _a2.location.href;
        currentUrl && currentUrl !== lastIframeUrl && (console.debug(
          "Iframe navigation detected:",
          lastIframeUrl,
          "->",
          currentUrl
        ), lastIframeUrl = currentUrl, syncIframeToParent());
      } catch (e2) {
        e2 instanceof DOMException && e2.name === "SecurityError" && console.warn(
          "Cross-origin navigation detected, synchronization paused"
        );
      }
    }, (urlSyncConfig == null ? void 0 : urlSyncConfig.debounceDelay) || 50);
    iframe.addEventListener("load", handleIframeLoad), window.addEventListener("popstate", handlePopState);
    const setupIframeNavigationListeners = () => {
      try {
        const iframeWindow = iframe.contentWindow;
        if (!iframeWindow) return;
        iframeWindow.addEventListener("hashchange", () => {
          console.debug("Iframe hashchange detected"), checkIframeNavigation();
        }), iframeWindow.addEventListener("popstate", () => {
          console.debug("Iframe popstate detected"), checkIframeNavigation();
        });
        const originalPushState = iframeWindow.history.pushState, originalReplaceState = iframeWindow.history.replaceState;
        iframeWindow.history.pushState = function(...args) {
          const result = originalPushState.apply(this, args);
          return console.debug("Iframe pushState detected"), checkIframeNavigation(), result;
        }, iframeWindow.history.replaceState = function(...args) {
          const result = originalReplaceState.apply(this, args);
          return console.debug("Iframe replaceState detected"), checkIframeNavigation(), result;
        };
      } catch (e2) {
        console.debug("Failed to setup iframe navigation listeners:", e2);
      }
    };
    iframe.addEventListener("load", setupIframeNavigationListeners);
    let cleanupNavMonitoring = null;
    try {
      if (iframe.contentWindow && iframe.contentDocument) {
        const MutationObserverConstructor = window.MutationObserver || window.WebKitMutationObserver;
        if (MutationObserverConstructor) {
          const observer = new MutationObserverConstructor(() => {
            checkIframeNavigation();
          });
          observer.observe(iframe.contentDocument.documentElement, {
            childList: !0,
            subtree: !0,
            attributes: !0,
            attributeFilter: ["href"]
          }), cleanupNavMonitoring = () => observer.disconnect();
        }
      }
    } catch (e2) {
      console.debug("MutationObserver setup failed, using polling:", e2);
    }
    const intervalId = cleanupNavMonitoring ? null : setInterval(checkIframeNavigation, 100);
    return iframe.contentWindow && (handleIframeLoad(), setupIframeNavigationListeners()), () => {
      iframe.removeEventListener("load", handleIframeLoad), iframe.removeEventListener("load", setupIframeNavigationListeners), window.removeEventListener("popstate", handlePopState), intervalId && clearInterval(intervalId), cleanupNavMonitoring && cleanupNavMonitoring();
    };
  }, [appPort, urlSyncConfig]), null;
}
function monkeyPatchLocation(iframeWindow, appPort) {
  try {
    const originalLocation = iframeWindow.location, descriptor = Object.getOwnPropertyDescriptor(
      iframeWindow,
      "location"
    );
    if (!descriptor || descriptor.configurable === !1) {
      patchLocationProperties(iframeWindow, appPort);
      return;
    }
    const locationProxy = new Proxy(originalLocation, {
      get(target, prop) {
        if (prop === "port")
          return String(appPort);
        if (prop === "host")
          return `${target.hostname}:${appPort}`;
        if (prop === "origin")
          return `${target.protocol}//${target.hostname}:${appPort}`;
        if (prop === "href") {
          const url = new URL(target.href);
          return url.port = String(appPort), url.toString();
        }
        return target[prop];
      }
    });
    Object.defineProperty(iframeWindow, "location", {
      get() {
        return locationProxy;
      },
      configurable: !0
    });
  } catch (e2) {
    console.error("Failed to monkey-patch location:", e2), patchLocationProperties(iframeWindow, appPort);
  }
}
function patchLocationProperties(iframeWindow, appPort) {
  try {
    const originalLocation = iframeWindow.location, createGetter = (originalGetter, modifier) => function() {
      const value = originalGetter.call(this);
      return modifier(value);
    };
    Object.defineProperty(originalLocation, "port", {
      get: () => String(appPort),
      configurable: !0
    });
    const originalHostDescriptor = Object.getOwnPropertyDescriptor(
      originalLocation,
      "host"
    );
    originalHostDescriptor != null && originalHostDescriptor.get && Object.defineProperty(originalLocation, "host", {
      get: createGetter(
        originalHostDescriptor.get,
        () => `${originalLocation.hostname}:${appPort}`
      ),
      configurable: !0
    });
    const originalOriginDescriptor = Object.getOwnPropertyDescriptor(
      originalLocation,
      "origin"
    );
    originalOriginDescriptor != null && originalOriginDescriptor.get && Object.defineProperty(originalLocation, "origin", {
      get: createGetter(
        originalOriginDescriptor.get,
        () => `${originalLocation.protocol}//${originalLocation.hostname}:${appPort}`
      ),
      configurable: !0
    });
    const originalHrefDescriptor = Object.getOwnPropertyDescriptor(
      originalLocation,
      "href"
    );
    originalHrefDescriptor != null && originalHrefDescriptor.get && Object.defineProperty(originalLocation, "href", {
      get: createGetter(originalHrefDescriptor.get, (href) => {
        const url = new URL(href);
        return url.port = String(appPort), url.toString();
      }),
      configurable: !0
    });
  } catch (e2) {
    console.error("Failed to patch location properties:", e2);
  }
}
function useMetaSync() {
  const syncedElementsRef = useRef(/* @__PURE__ */ new Set()), observerRef = useRef(null);
  useEffect(() => {
    var _a;
    const iframe = document.getElementById(
      "user-app-iframe"
    );
    if (!iframe) return;
    const syncMetaElements = () => {
      try {
        const iframeWindow = iframe.contentWindow, iframeDocument = iframe.contentDocument;
        if (!iframeWindow || !iframeDocument) return;
        const metaElements = [], iframeTitle = iframeDocument.title;
        iframeTitle && (document.title = iframeTitle), iframeDocument.querySelectorAll(
          'link[rel="icon"], link[rel="shortcut icon"], link[rel="apple-touch-icon"]'
        ).forEach((link) => {
          var _a2;
          const linkEl = link;
          metaElements.push({
            tag: "link",
            attributes: {
              rel: linkEl.rel,
              href: linkEl.href,
              type: linkEl.type || "",
              sizes: ((_a2 = linkEl.sizes) == null ? void 0 : _a2.toString()) || ""
            }
          });
        }), iframeDocument.querySelectorAll(
          'meta[property^="og:"], meta[property^="article:"], meta[property^="book:"], meta[property^="profile:"], meta[property^="video:"], meta[property^="music:"]'
        ).forEach((meta) => {
          const metaEl = meta;
          metaElements.push({
            tag: "meta",
            attributes: {
              property: metaEl.getAttribute("property") || "",
              content: metaEl.content
            }
          });
        }), iframeDocument.querySelectorAll(
          'meta[name^="twitter:"]'
        ).forEach((meta) => {
          const metaEl = meta;
          metaElements.push({
            tag: "meta",
            attributes: {
              name: metaEl.name,
              content: metaEl.content
            }
          });
        }), iframeDocument.querySelectorAll(
          'meta[name="description"], meta[name="keywords"], meta[name="author"]'
        ).forEach((meta) => {
          const metaEl = meta, attributes = {};
          metaEl.name && (attributes.name = metaEl.name), metaEl.content && (attributes.content = metaEl.content), metaElements.push({
            tag: "meta",
            attributes
          });
        });
        const canonicalLink = iframeDocument.querySelector(
          'link[rel="canonical"]'
        );
        if (canonicalLink) {
          const linkEl = canonicalLink;
          metaElements.push({
            tag: "link",
            attributes: {
              rel: "canonical",
              href: linkEl.href
            }
          });
        }
        syncedElementsRef.current.forEach((element) => {
          element.remove();
        }), syncedElementsRef.current.clear();
        const fragment = document.createDocumentFragment();
        metaElements.forEach((metaInfo) => {
          var _a2;
          if (metaInfo.tag === "meta")
            metaInfo.attributes.property ? document.querySelectorAll(
              `meta[property="${metaInfo.attributes.property}"]`
            ).forEach((el) => {
              syncedElementsRef.current.has(el) || el.remove();
            }) : metaInfo.attributes.name && document.querySelectorAll(
              `meta[name="${metaInfo.attributes.name}"]`
            ).forEach((el) => {
              syncedElementsRef.current.has(el) || el.remove();
            });
          else if (metaInfo.tag === "link") {
            if ((_a2 = metaInfo.attributes.rel) != null && _a2.includes("icon"))
              document.querySelectorAll('link[rel*="icon"]').forEach((el) => {
                syncedElementsRef.current.has(el) || el.remove();
              });
            else if (metaInfo.attributes.rel === "canonical") {
              const existing = document.querySelector('link[rel="canonical"]');
              existing && !syncedElementsRef.current.has(existing) && existing.remove();
            }
          }
          const element = document.createElement(metaInfo.tag);
          Object.entries(metaInfo.attributes).forEach(([key, value]) => {
            value && element.setAttribute(key, value);
          }), fragment.appendChild(element), syncedElementsRef.current.add(element);
        }), document.head.appendChild(fragment);
      } catch (e2) {
        e2 instanceof DOMException && e2.name === "SecurityError" ? console.debug("Cannot access cross-origin iframe head") : console.error("Failed to sync meta tags:", e2);
      }
    }, setupObserver = () => {
      try {
        const iframeDocument = iframe.contentDocument;
        if (!iframeDocument) return;
        observerRef.current && observerRef.current.disconnect(), observerRef.current = new MutationObserver((mutations) => {
          mutations.some((mutation) => {
            if (mutation.target === iframeDocument.head || mutation.target.nodeName === "TITLE" || mutation.target.nodeName === "META" || mutation.target.nodeName === "LINK") return !0;
            if (mutation.type === "characterData") {
              const parentNode = mutation.target.parentNode;
              if (parentNode && parentNode.nodeName === "TITLE")
                return !0;
            }
            for (const node of mutation.addedNodes)
              if (node.nodeName === "META" || node.nodeName === "LINK" || node.nodeName === "TITLE")
                return !0;
            for (const node of mutation.removedNodes)
              if (node.nodeName === "META" || node.nodeName === "LINK" || node.nodeName === "TITLE")
                return !0;
            return !1;
          }) && syncMetaElements();
        }), iframeDocument.head && observerRef.current.observe(iframeDocument.head, {
          childList: !0,
          subtree: !0,
          attributes: !0,
          attributeFilter: [
            "content",
            "href",
            "property",
            "name",
            "rel",
            "sizes",
            "type"
          ],
          characterData: !0
        }), observerRef.current.observe(iframeDocument.documentElement, {
          childList: !0,
          subtree: !1
        }), syncMetaElements();
      } catch (e2) {
        console.debug("Failed to setup meta observer:", e2);
      }
    }, handleIframeLoad = () => {
      setupObserver();
    };
    return iframe.addEventListener("load", handleIframeLoad), ((_a = iframe.contentDocument) == null ? void 0 : _a.readyState) === "complete" && setupObserver(), () => {
      iframe.removeEventListener("load", handleIframeLoad), observerRef.current && observerRef.current.disconnect(), syncedElementsRef.current.forEach((element) => {
        element.remove();
      }), syncedElementsRef.current.clear();
    };
  }, []);
}
function MetaSynchronizer() {
  return useMetaSync(), null;
}
function App(config2) {
  const pathname = window.location.pathname || "/", search = window.location.search || "", hash = window.location.hash || "", initialUrl = pathname + search + hash;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      "iframe",
      {
        src: initialUrl,
        title: "Main user app",
        className: "fixed inset-0 m-0 size-full p-0",
        id: "user-app-iframe"
      }
    ),
    /* @__PURE__ */ jsx(
      UrlSynchronizer,
      {
        appPort: config2 == null ? void 0 : config2.appPort,
        urlSyncConfig: config2 == null ? void 0 : config2.urlSync
      }
    ),
    /* @__PURE__ */ jsx(MetaSynchronizer, {}),
    /* @__PURE__ */ jsxs(AppStateProvider, { children: [
      /* @__PURE__ */ jsx(MainAppBlocker, {}),
      /* @__PURE__ */ jsxs(ContextProviders, { config: config2, children: [
        /* @__PURE__ */ jsx(HotkeyListener, {}),
        /* @__PURE__ */ jsx(DefaultLayout, {})
      ] })
    ] })
  ] });
}
const styleNode = document.createElement("style");
styleNode.textContent = appStyle;
document.head.appendChild(styleNode);
createRoot(document.body).render(
  createElement(StrictMode, null, createElement(App, config))
);
