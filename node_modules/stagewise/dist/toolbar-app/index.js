var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value);
import * as React from "react";
import React__default, { createContext, useState, useCallback, useEffect, useContext, useLayoutEffect, useMemo, useRef, forwardRef, Fragment, isValidElement, cloneElement, createElement, useId as useId$2, useReducer, useSyncExternalStore, createRef, memo, StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import { u as useAppState, a as usePlugins, b as useKartonProcedure, c as useKartonState, d as usePanels, g as generateId, i as isAnthropicSupportedFile, f as fileToDataUrl, e as collectUserMessageMetadata, h as getSelectedElementInfo, C as ConfigProvider, K as KartonProvider, P as PanelsProvider, j as PluginProvider, H as HotkeyActions, k as hotkeyActionDefinitions, l as getIFrameWindow, m as cn, n as getElementAtPoint, o as getXPathForElement, p as useKartonConnected, G as Glassy, q as glassyBoxClassName, r as Panel, s as PanelHeader, t as PanelContent, v as PanelFooter, B as Button, w as openFileUrl, x as useComparingSelector, y as cva, A as AppStateProvider } from "index-BhA2ewxm.js";
import * as ReactDOM from "react-dom";
import { createPortal, flushSync } from "react-dom";
import config from "@stagewise/toolbar/config";
const appStyle = '/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports ((-webkit-hyphens:none) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-divide-y-reverse:0;--tw-border-style:solid;--tw-gradient-position:initial;--tw-gradient-from:#0000;--tw-gradient-via:#0000;--tw-gradient-to:#0000;--tw-gradient-stops:initial;--tw-gradient-via-stops:initial;--tw-gradient-from-position:0%;--tw-gradient-via-position:50%;--tw-gradient-to-position:100%;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-ease:initial;--tw-content:""}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-300:oklch(80.8% .114 19.571);--color-red-500:oklch(63.7% .237 25.331);--color-red-900:oklch(39.6% .141 25.723);--color-orange-50:oklch(98% .016 73.684);--color-orange-100:oklch(95.4% .038 75.164);--color-orange-200:oklch(90.1% .076 70.697);--color-orange-500:oklch(70.5% .213 47.604);--color-orange-600:oklch(64.6% .222 41.116);--color-orange-700:oklch(55.3% .195 38.402);--color-orange-900:oklch(40.8% .123 38.172);--color-yellow-500:oklch(79.5% .184 86.047);--color-green-300:oklch(87.1% .15 154.449);--color-green-500:oklch(72.3% .219 149.579);--color-green-600:oklch(62.7% .194 149.214);--color-green-900:oklch(39.3% .095 152.535);--color-sky-100:oklch(95.1% .026 236.824);--color-sky-500:oklch(68.5% .169 237.323);--color-blue-50:oklch(97% .014 254.604);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-400:oklch(70.7% .165 254.624);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-blue-700:oklch(48.8% .243 264.376);--color-blue-950:oklch(28.2% .091 267.935);--color-purple-500:oklch(62.7% .265 303.9);--color-pink-500:oklch(65.6% .241 354.308);--color-rose-100:oklch(94.1% .03 12.58);--color-rose-600:oklch(58.6% .253 17.585);--color-zinc-50:oklch(98.5% 0 0);--color-zinc-100:oklch(96.7% .001 286.375);--color-zinc-400:oklch(70.5% .015 286.067);--color-zinc-500:oklch(55.2% .016 285.938);--color-zinc-600:oklch(44.2% .017 285.786);--color-zinc-700:oklch(37% .013 285.805);--color-zinc-800:oklch(27.4% .006 286.033);--color-zinc-900:oklch(21% .006 285.885);--color-zinc-950:oklch(14.1% .005 285.823);--color-black:#000;--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--radius-xs:.125rem;--radius-sm:.25rem;--radius-md:.375rem;--radius-lg:.5rem;--radius-xl:.75rem;--radius-2xl:1rem;--radius-3xl:1.5rem;--shadow-lg:0 10px 15px -3px #0000001a,0 4px 6px -4px #0000001a;--drop-shadow-xl:0 9px 7px #0000001a;--ease-in:cubic-bezier(.4,0,1,1);--ease-out:cubic-bezier(0,0,.2,1);--ease-in-out:cubic-bezier(.4,0,.2,1);--animate-spin:spin 1s linear infinite;--animate-pulse:pulse 2s cubic-bezier(.4,0,.6,1)infinite;--blur-sm:8px;--blur-md:12px;--blur-lg:16px;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono);--color-foreground:var(--color-zinc-950);--color-muted-foreground:var(--color-zinc-700);--color-border:var(--color-zinc-500);--ease-spring:linear(0,-.00946,.0219,.0793,.152,.237,.326,.419,.509,.597,.68,.755,.823,.882,.933,.976,1.01,1.04,1.06,1.07,1.08,1.09,1.09,1.09,1.09,1.08,1.07,1.07,1.06,1.05,1.04,1.03,1.03,1.02,1.01,1.01,1,1,.998,.996,.994,.993,.992,.992,.992,.992,.992,.993,.994,.994,.995,.996,.997,.997,.998,.998,.999,.999,1);--ease-spring-soft:linear(0,-.0531,.117,.293,.46,.61,.738,.838,.913,.965,1,1.02,1.03,1.03,1.03,1.03,1.03,1.02,1.01,1.01,1.01,1,1,1,1);--glass-texture:url(data:image/png;base64,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);--gradient:url(data:image/png;base64,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Lkj8yHXZ5TfOBYf9PFMw0sl5YoFYLLSx3MasaKjE08RhRdUo359xWeG8xVktV1nznvyFoZy2kuI6zWHEsIQ4EhAho4oSyrAQoVUjxUSS9qMe/iHHnyCXTK4SGDkWUIEKyfGD/8Hvbs381KSbFIoCnS+2/TEKBHeBRs22v49tu3ECBJ6BK63lr9SB2U/Say0tfAT0bwMX1y1N3gMud4DBJ10yJEcK0PTn88D7GX1TFhi4BbrX3N6a+zh9ANLU1fINcHAIjBUoe93j3V3tvf17ptnfD1oXcp3/D10UAAAN92lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9ImdpbXA6ZG9jaWQ6Z2ltcDozYmQzMGE4My01MzllLTQ4MzYtODM3NC02NDJjZmYwYjMwYTEiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ZDYyMDQ1MTEtZDhhZS00ZWEzLTk4N2QtODcwZmI3ODRlM2ZmIgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZWNmN2VkZGUtY2IyYy00MjY1LWExNTUtOTBlNWJmOTk2MGIxIgogICBkYzpGb3JtYXQ9ImltYWdlL3BuZyIKICAgR0lNUDpBUEk9IjIuMCIKICAgR0lNUDpQbGF0Zm9ybT0iV2luZG93cyIKICAgR0lNUDpUaW1lU3RhbXA9IjE3MTE5MTU5MTA3NTc3NjAiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4yNCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiY2M3MDgxNi1jYjIzLTQxNDItYjg0Yy1lNWMzODhiOGM3ODIiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjQtMDMtMjZUMTA6MTk6MzYiLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZThjNGJjZjEtYmQ4Ni00YjVkLTg5MzktOGJmNzBlY2MyZGZkIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKFdpbmRvd3MpIgogICAgICBzdEV2dDp3aGVuPSIyMDI0LTAzLTMxVDIyOjExOjUwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PlE6FucAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoAx8UCzJJFY2xAAAFJUlEQVRYw3WW0ZbbNgxEL0iQlJymzS/1/5/6JU16dmNbEok+EKJpNZUPjrRaSTMYDAEKf/5lhABNwAx2g+OAxwYfT/h4wI8HPB7AHdiBAzBAPCIQPIR+NH/uAJ4edz8//LyjIB1cxL9p/d1GJ3QYHOeNOn3UHEj8/pWATc+f79pEvD+vtPMdg2ZQDVrroHuDvUKrU+aHX9eJQLjESaBdSFxVayi1MY5mUB14qx4HtGMisE3X53GWIE4AswrtknkcaihbBXEZqgM/dnju/byf4LuDn1H/I+fr49dSMIHyRkS5b73+SK/3dnTwn1uPurlhtksZ5qyaA3BRYCZngF48UVE+7iDB1bJe8/sBP5+wb8Otr9ofk6wziE0ZhktZ5qNNUVH+uTNWghlsrStQ92m5bBfw2c1caps80/McLurYZNCG8v2zK4B0E7Y2ZTuD71PWXOquCIpQMBJGcgJnxHelxKOvgo9fNJDqsf1P41GnED0ygUQgA5lG5qBwDBW0J6kBMhAMooE0FD6mevEmz7vhZBAVhEggoRQSSkLJTqDQyGxkHmTuKKYJbhHWMFXmLAGfTiD+YumcTj+BowMHFiLFCfRfJlAwMpXCRiaTCSnx8bvCl5OAQHqVQeHnRCBMXUqmWgsBQQksBFYiK8oyCGSUjJCdQOZJQUOGr4nn18j+20zAy9AJPFyTOJ15I6VECpGVyG0CX0hDgUgaBA4KmUxcE+1L4vFb5PtJIDsB4SzBfllWMsAjEUVZSawoNyI3v1488kQAEtXNF8nYmthXZV2U7+uFQDhb8Wv0jbUaHLyQWUncPPq1TvJ3+ymJgAKZSmIjETTRSmIriaUoMUdqFijiQo8SyHB4X1JKRlnJI27kQWBxRQqRjJJcJSHRSFS0q6GJPSWKKjkpSw58pmkVRINg6AncP6Oe9RmFlcLNlTgJdPdHsr8VUIRIQ9n9usZIDpEUIzkGlhD4jGHq0E5AvV5lAlwpLBRuLIPMMoEvI/Me4p5p3piMSJZAEiEhJBHKOfCQ1/TF0BuFQmZhfSOwsjiREzy56XRkrgQCASFgRKq35oqwNyGaoAbaILe+9M18x4WBgX5jpfivZ7sMBTp49uV2gqtXuTtGHNQI7IQxmONuxGrEClqNXI3lMO7Rt3rBZ8FXVpf4JFEGpQ6cB3hy6U/wMLXnOu0KAkY4jLgbejTyLpTd+D027sKYA2DoH6xkMmcpCoubLZNHj5vBe94R8exfXaT3T+uamBEfDX0KaROWJ3wVeJrwPfq8MVeguNRl+EEHeBqy944YvS2HAS5Tw27uitaH9IegN6FkWKNxmNAOyNH4pPFsDf3C4pn3pZameqfh9rM14eAyjS0bs7LPyTa2IHGD/AFFjRuGVSEorMH4RmUzJ5Dd5a+s+6TrwPI2K0+Zr4dgXhQh0MbeKP+AKoY1I+xCVthiY7dGbQ3tDjh7el9iycfuuchkVFpoNDff+8A2f+b0R2/MfZtpfxuyNfSLUCLs0ag0jtrQMkmd3eE989dwFocy3xu0aW7YRKaXwFyphgIFQwjop1B+wiZwOIHWGqoOqGNF94/0rBrNBZehRHP7yeQE8Te7AmnSp4+2xo5wGGSDo7VOgIaGUTfxnYB5DjZl+lJCEKqDyyAhw4q9FRvqNLsf+pb1cB0P7EXgZSMbvza23kwUzAFOlcI4y9hPBqB6AZv/7+WL6ATUCVQqei6k5gazIbj53/i9V52jb0q7Uc3rHt72kr1PNBTxHYf5HbxPdMR/Af2SQINNgRTNAAAAAElFTkSuQmCC);--animate-chat-bubble-appear:chat-bubble-appear .3s var(--ease-spring-soft)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::-moz-placeholder{opacity:1}::placeholder{opacity:1}@supports (not (-webkit-appearance:-apple-pay-button)) or (contain-intrinsic-size:1px){::-moz-placeholder{color:currentColor}::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::-moz-placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){-webkit-appearance:button;-moz-appearance:button;appearance:button}::file-selector-button{-webkit-appearance:button;-moz-appearance:button;appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{min-width:0;min-height:0;position:relative}body{all:initial;color:var(--color-zinc-950);letter-spacing:normal!important;font-family:Inter,Noto Color Emoji,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,SF Compact,SF Pro,Helvetica Neue,sans-serif!important;font-weight:400!important;line-height:normal!important}@supports (font-variation-settings:normal){body{font-optical-sizing:auto!important;font-family:InterVariable,Noto Color Emoji,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,SF Compact,SF Pro,Helvetica Neue,sans-serif!important}}*{scrollbar-color:initial;scrollbar-width:initial}}@layer components{.chat-loading-gradient{background:linear-gradient(#f8fafccc,#f8fafccc) padding-box padding-box,linear-gradient(45deg,#8b5cf6,#06b6d4,#8b5cf6) 0 0/400% 400% border-box;border:2px solid #0000;animation:2s infinite gradient-animation}.chat-success-border{animation:2s ease-out blink-green-fade}.chat-error-border{animation:1s ease-out blink-red-fade}@keyframes blink-green-fade{0%,50%{box-shadow:0 0 0 2px #22c55eb3}to{box-shadow:0 0 0 2px #22c55e00}}@keyframes blink-red-fade{0%,50%{box-shadow:0 0 0 2px #ef4444}to{box-shadow:0 0 0 2px #ef444400}}@property --chat-grad-bg-bg-color{syntax: "<color>"; inherits: true; initial-value: #0d253f;}@property --chat-grad-bg-c1{syntax: "<color>"; inherits: true; initial-value: #1e40af;}@property --chat-grad-bg-c2{syntax: "<color>"; inherits: true; initial-value: #2563eb;}@property --chat-grad-bg-c3{syntax: "<color>"; inherits: true; initial-value: #3b82f6;}@property --chat-grad-bg-c4{syntax: "<color>"; inherits: true; initial-value: #60a5fa;}@property --chat-grad-bg-opacity-slow{syntax: "<number>"; inherits: true; initial-value: 1;}@property --chat-grad-bg-opacity-medium{syntax: "<number>"; inherits: true; initial-value: 0;}@property --chat-grad-bg-opacity-fast{syntax: "<number>"; inherits: true; initial-value: 0;}@property --chat-grad-bg-overall-opacity{syntax: "<number>"; inherits: true; initial-value: 1;}@keyframes chat-grad-bg-move{0%{transform:translate(0)}20%{transform:translate(15vw,-10vh)scale(1.1)}40%{transform:translate(-10vw,15vh)scale(.9)}60%{transform:translate(10vw,10vh)scale(1.2)}80%{transform:translate(5vw,-15vh)scale(1)}to{transform:translate(0)}}.shape-anim{transition:fill 1s ease-in-out;animation-name:chat-grad-bg-move;animation-timing-function:ease-in-out;animation-iteration-count:infinite}.g-slow{opacity:var(--chat-grad-bg-opacity-slow);transition:opacity 1s ease-in-out}.g-medium{opacity:var(--chat-grad-bg-opacity-medium);transition:opacity 1s ease-in-out}.g-fast{opacity:var(--chat-grad-bg-opacity-fast);transition:opacity 1s ease-in-out}}@layer utilities{.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.-inset-\\[25\\%\\]{top:-25%;right:-25%;bottom:-25%;left:-25%}.inset-0{inset:calc(var(--spacing)*0)}.inset-4{inset:calc(var(--spacing)*4)}.-top-2{top:calc(var(--spacing)*-2)}.top-0{top:calc(var(--spacing)*0)}.top-0\\.5{top:calc(var(--spacing)*.5)}.top-1\\/2{top:50%}.top-16{top:calc(var(--spacing)*16)}.top-\\[25\\%\\]{top:25%}.top-px{top:1px}.right-0{right:calc(var(--spacing)*0)}.right-1{right:calc(var(--spacing)*1)}.right-2{right:calc(var(--spacing)*2)}.right-4{right:calc(var(--spacing)*4)}.right-12{right:calc(var(--spacing)*12)}.right-px{right:1px}.bottom-0{bottom:calc(var(--spacing)*0)}.bottom-3{bottom:calc(var(--spacing)*3)}.bottom-4{bottom:calc(var(--spacing)*4)}.bottom-px{bottom:1px}.left-0{left:calc(var(--spacing)*0)}.left-0\\.5{left:calc(var(--spacing)*.5)}.left-1{left:calc(var(--spacing)*1)}.left-3{left:calc(var(--spacing)*3)}.left-4{left:calc(var(--spacing)*4)}.left-12{left:calc(var(--spacing)*12)}.left-\\[25\\%\\]{left:25%}.left-px{left:1px}.-z-10{z-index:-10}.z-0{z-index:0}.z-10{z-index:10}.z-20{z-index:20}.z-30{z-index:30}.z-50{z-index:50}.z-\\[9999\\]{z-index:9999}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.m-0{margin:calc(var(--spacing)*0)}.-mx-1{margin-inline:calc(var(--spacing)*-1)}.mt-0{margin-top:calc(var(--spacing)*0)}.mt-0\\.5{margin-top:calc(var(--spacing)*.5)}.mt-1{margin-top:calc(var(--spacing)*1)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-3{margin-top:calc(var(--spacing)*3)}.mt-4{margin-top:calc(var(--spacing)*4)}.mr-1{margin-right:calc(var(--spacing)*1)}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-px{margin-right:1px}.mb-0{margin-bottom:calc(var(--spacing)*0)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.mb-px{margin-bottom:1px}.scrollbar-thin::-webkit-scrollbar-track{background-color:var(--scrollbar-track);border-radius:var(--scrollbar-track-radius)}.scrollbar-thin::-webkit-scrollbar-thumb{background-color:var(--scrollbar-thumb);border-radius:var(--scrollbar-thumb-radius)}.scrollbar-thin::-webkit-scrollbar-corner{background-color:var(--scrollbar-corner);border-radius:var(--scrollbar-corner-radius)}.scrollbar-thin{scrollbar-width:thin;scrollbar-color:var(--scrollbar-thumb,initial)var(--scrollbar-track,initial)}.scrollbar-thin::-webkit-scrollbar{width:8px;height:8px;display:block}.block{display:block}.contents{display:contents}.flex{display:flex}.inline{display:inline}.aspect-\\[1\\/1\\.5\\]{aspect-ratio:1/1.5}.aspect-square{aspect-ratio:1}.size-0{width:calc(var(--spacing)*0);height:calc(var(--spacing)*0)}.size-1\\.5{width:calc(var(--spacing)*1.5);height:calc(var(--spacing)*1.5)}.size-1\\/2{width:50%;height:50%}.size-2\\/3{width:66.6667%;height:66.6667%}.size-3{width:calc(var(--spacing)*3);height:calc(var(--spacing)*3)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.size-6{width:calc(var(--spacing)*6);height:calc(var(--spacing)*6)}.size-8{width:calc(var(--spacing)*8);height:calc(var(--spacing)*8)}.size-10{width:calc(var(--spacing)*10);height:calc(var(--spacing)*10)}.size-12{width:calc(var(--spacing)*12);height:calc(var(--spacing)*12)}.size-auto{width:auto;height:auto}.size-full{width:100%;height:100%}.\\!h-\\[calc-size\\(auto\\,size\\)\\]{height:calc-size(auto,size)!important}.\\!h-auto{height:auto!important}.h-0{height:calc(var(--spacing)*0)}.h-3{height:calc(var(--spacing)*3)}.h-4{height:calc(var(--spacing)*4)}.h-5{height:calc(var(--spacing)*5)}.h-7{height:calc(var(--spacing)*7)}.h-8{height:calc(var(--spacing)*8)}.h-12{height:calc(var(--spacing)*12)}.h-16{height:calc(var(--spacing)*16)}.h-26{height:calc(var(--spacing)*26)}.h-\\[1\\.2em\\]{height:1.2em}.h-\\[35vh\\]{height:35vh}.h-\\[50\\%\\]{height:50%}.h-\\[150\\%\\]{height:150%}.h-\\[calc\\(100\\%-2px\\)\\]{height:calc(100% - 2px)}.h-\\[calc-size\\(auto\\,size\\)\\]{height:calc-size(auto,size)}.h-auto{height:auto}.h-fit{height:-moz-fit-content;height:fit-content}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-96{max-height:calc(var(--spacing)*96)}.max-h-\\[50vh\\]{max-height:50vh}.max-h-full{max-height:100%}.min-h-0{min-height:calc(var(--spacing)*0)}.min-h-8{min-height:calc(var(--spacing)*8)}.min-h-48{min-height:calc(var(--spacing)*48)}.min-h-64{min-height:calc(var(--spacing)*64)}.min-h-\\[20vh\\]{min-height:20vh}.min-h-\\[inherit\\]{min-height:inherit}.w-3\\/4{width:75%}.w-5{width:calc(var(--spacing)*5)}.w-8{width:calc(var(--spacing)*8)}.w-64{width:calc(var(--spacing)*64)}.w-96{width:calc(var(--spacing)*96)}.w-\\[50\\%\\]{width:50%}.w-\\[150\\%\\]{width:150%}.w-auto{width:auto}.w-fit{width:-moz-fit-content;width:fit-content}.w-full{width:100%}.w-max{width:-moz-max-content;width:max-content}.w-screen{width:100vw}.max-w-8{max-width:calc(var(--spacing)*8)}.max-w-24{max-width:calc(var(--spacing)*24)}.max-w-90{max-width:calc(var(--spacing)*90)}.max-w-\\[calc\\(100\\%-48px\\)\\]{max-width:calc(100% - 48px)}.max-w-full{max-width:100%}.min-w-3{min-width:calc(var(--spacing)*3)}.min-w-12{min-width:calc(var(--spacing)*12)}.min-w-24{min-width:calc(var(--spacing)*24)}.min-w-32{min-width:calc(var(--spacing)*32)}.min-w-48{min-width:calc(var(--spacing)*48)}.min-w-fit{min-width:-moz-fit-content;min-width:fit-content}.flex-1{flex:1}.shrink-0{flex-shrink:0}.grow{flex-grow:1}.origin-bottom{transform-origin:bottom}.origin-bottom-left{transform-origin:0 100%}.origin-bottom-right{transform-origin:100% 100%}.origin-center{transform-origin:50%}.origin-left{transform-origin:0}.origin-right{transform-origin:100%}.origin-top{transform-origin:top}.-translate-y-1\\/2{--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-2{--tw-translate-y:calc(var(--spacing)*-2);translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-0{--tw-translate-y:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-1{--tw-translate-y:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-2{--tw-translate-y:calc(var(--spacing)*2);translate:var(--tw-translate-x)var(--tw-translate-y)}.scale-0{--tw-scale-x:0%;--tw-scale-y:0%;--tw-scale-z:0%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-25{--tw-scale-x:25%;--tw-scale-y:25%;--tw-scale-z:25%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-50{--tw-scale-x:50%;--tw-scale-y:50%;--tw-scale-z:50%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-95{--tw-scale-x:95%;--tw-scale-y:95%;--tw-scale-z:95%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-100{--tw-scale-x:100%;--tw-scale-y:100%;--tw-scale-z:100%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-110{--tw-scale-x:110%;--tw-scale-y:110%;--tw-scale-z:110%;scale:var(--tw-scale-x)var(--tw-scale-y)}.rotate-90{rotate:90deg}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.animate-chat-bubble-appear{animation:var(--animate-chat-bubble-appear)}.animate-pulse{animation:var(--animate-pulse)}.animate-spin{animation:var(--animate-spin)}.cursor-copy{cursor:copy}.cursor-default{cursor:default}.cursor-not-allowed{cursor:not-allowed}.cursor-pointer{cursor:pointer}.resize{resize:both}.resize-none{resize:none}.snap-start{scroll-snap-align:start}.list-inside{list-style-position:inside}.list-disc{list-style-type:disc}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-row{flex-direction:row}.flex-row-reverse{flex-direction:row-reverse}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.items-stretch{align-items:stretch}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.justify-start{justify-content:flex-start}.gap-0{gap:calc(var(--spacing)*0)}.gap-0\\.5{gap:calc(var(--spacing)*.5)}.gap-1{gap:calc(var(--spacing)*1)}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}:where(.space-y-1>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*1)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-3>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*3)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-y-reverse)))}:where(.divide-y>:not(:last-child)){--tw-divide-y-reverse:0;border-bottom-style:var(--tw-border-style);border-top-style:var(--tw-border-style);border-top-width:calc(1px*var(--tw-divide-y-reverse));border-bottom-width:calc(1px*calc(1 - var(--tw-divide-y-reverse)))}:where(.divide-y-reverse>:not(:last-child)){--tw-divide-y-reverse:1}:where(.divide-border\\/20>:not(:last-child)){border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){:where(.divide-border\\/20>:not(:last-child)){border-color:color-mix(in oklab,var(--color-border)20%,transparent)}}:where(.divide-zinc-500\\/10>:not(:last-child)){border-color:#71717b1a}@supports (color:color-mix(in lab,red,red)){:where(.divide-zinc-500\\/10>:not(:last-child)){border-color:color-mix(in oklab,var(--color-zinc-500)10%,transparent)}}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.\\!overflow-visible{overflow:visible!important}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.overflow-visible\\!{overflow:visible!important}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.overflow-y-scroll{overflow-y:scroll}.overscroll-contain{overscroll-behavior:contain}.rounded{border-radius:.25rem}.rounded-2xl{border-radius:var(--radius-2xl)}.rounded-3xl{border-radius:var(--radius-3xl)}.rounded-\\[inherit\\]{border-radius:inherit}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius-lg)}.rounded-md{border-radius:var(--radius-md)}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.rounded-t-3xl{border-top-left-radius:var(--radius-3xl);border-top-right-radius:var(--radius-3xl)}.rounded-t-\\[inherit\\]{border-top-left-radius:inherit;border-top-right-radius:inherit}.rounded-t-lg{border-top-left-radius:var(--radius-lg);border-top-right-radius:var(--radius-lg)}.rounded-b-3xl{border-bottom-right-radius:var(--radius-3xl);border-bottom-left-radius:var(--radius-3xl)}.rounded-b-\\[inherit\\]{border-bottom-right-radius:inherit;border-bottom-left-radius:inherit}.rounded-b-lg{border-bottom-right-radius:var(--radius-lg);border-bottom-left-radius:var(--radius-lg)}.rounded-br-xs{border-bottom-right-radius:var(--radius-xs)}.rounded-bl-xs{border-bottom-left-radius:var(--radius-xs)}.border{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-dotted{--tw-border-style:dotted;border-style:dotted}.border-none{--tw-border-style:none;border-style:none}.border-black\\/10{border-color:#0000001a}@supports (color:color-mix(in lab,red,red)){.border-black\\/10{border-color:color-mix(in oklab,var(--color-black)10%,transparent)}}.border-blue-500{border-color:var(--color-blue-500)}.border-blue-600\\/70{border-color:#155dfcb3}@supports (color:color-mix(in lab,red,red)){.border-blue-600\\/70{border-color:color-mix(in oklab,var(--color-blue-600)70%,transparent)}}.border-border\\/20{border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){.border-border\\/20{border-color:color-mix(in oklab,var(--color-border)20%,transparent)}}.border-green-500{border-color:var(--color-green-500)}.border-orange-500{border-color:var(--color-orange-500)}.border-pink-500{border-color:var(--color-pink-500)}.border-purple-500{border-color:var(--color-purple-500)}.border-red-500{border-color:var(--color-red-500)}.border-yellow-500{border-color:var(--color-yellow-500)}.border-zinc-500{border-color:var(--color-zinc-500)}.border-zinc-500\\/15{border-color:#71717b26}@supports (color:color-mix(in lab,red,red)){.border-zinc-500\\/15{border-color:color-mix(in oklab,var(--color-zinc-500)15%,transparent)}}.border-zinc-500\\/20{border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){.border-zinc-500\\/20{border-color:color-mix(in oklab,var(--color-zinc-500)20%,transparent)}}.border-zinc-600\\/70{border-color:#52525cb3}@supports (color:color-mix(in lab,red,red)){.border-zinc-600\\/70{border-color:color-mix(in oklab,var(--color-zinc-600)70%,transparent)}}.bg-black\\/5{background-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.bg-black\\/5{background-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.bg-black\\/10{background-color:#0000001a}@supports (color:color-mix(in lab,red,red)){.bg-black\\/10{background-color:color-mix(in oklab,var(--color-black)10%,transparent)}}.bg-blue-500{background-color:var(--color-blue-500)}.bg-blue-500\\/10{background-color:#3080ff1a}@supports (color:color-mix(in lab,red,red)){.bg-blue-500\\/10{background-color:color-mix(in oklab,var(--color-blue-500)10%,transparent)}}.bg-blue-600{background-color:var(--color-blue-600)}.bg-blue-600\\/5{background-color:#155dfc0d}@supports (color:color-mix(in lab,red,red)){.bg-blue-600\\/5{background-color:color-mix(in oklab,var(--color-blue-600)5%,transparent)}}.bg-blue-600\\/10{background-color:#155dfc1a}@supports (color:color-mix(in lab,red,red)){.bg-blue-600\\/10{background-color:color-mix(in oklab,var(--color-blue-600)10%,transparent)}}.bg-blue-600\\/90{background-color:#155dfce6}@supports (color:color-mix(in lab,red,red)){.bg-blue-600\\/90{background-color:color-mix(in oklab,var(--color-blue-600)90%,transparent)}}.bg-blue-950\\/80{background-color:#162456cc}@supports (color:color-mix(in lab,red,red)){.bg-blue-950\\/80{background-color:color-mix(in oklab,var(--color-blue-950)80%,transparent)}}.bg-green-500{background-color:var(--color-green-500)}.bg-green-900\\/30{background-color:#0d542b4d}@supports (color:color-mix(in lab,red,red)){.bg-green-900\\/30{background-color:color-mix(in oklab,var(--color-green-900)30%,transparent)}}.bg-orange-200\\/50{background-color:#ffd7a880}@supports (color:color-mix(in lab,red,red)){.bg-orange-200\\/50{background-color:color-mix(in oklab,var(--color-orange-200)50%,transparent)}}.bg-orange-500{background-color:var(--color-orange-500)}.bg-pink-500{background-color:var(--color-pink-500)}.bg-purple-500{background-color:var(--color-purple-500)}.bg-red-500{background-color:var(--color-red-500)}.bg-red-900\\/30{background-color:#82181a4d}@supports (color:color-mix(in lab,red,red)){.bg-red-900\\/30{background-color:color-mix(in oklab,var(--color-red-900)30%,transparent)}}.bg-rose-600{background-color:var(--color-rose-600)}.bg-rose-600\\/90{background-color:#e70044e6}@supports (color:color-mix(in lab,red,red)){.bg-rose-600\\/90{background-color:color-mix(in oklab,var(--color-rose-600)90%,transparent)}}.bg-sky-100\\/60{background-color:#dff2fe99}@supports (color:color-mix(in lab,red,red)){.bg-sky-100\\/60{background-color:color-mix(in oklab,var(--color-sky-100)60%,transparent)}}.bg-transparent{background-color:#0000}.bg-white{background-color:var(--color-white)}.bg-white\\/5{background-color:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.bg-white\\/5{background-color:color-mix(in oklab,var(--color-white)5%,transparent)}}.bg-white\\/30{background-color:#ffffff4d}@supports (color:color-mix(in lab,red,red)){.bg-white\\/30{background-color:color-mix(in oklab,var(--color-white)30%,transparent)}}.bg-white\\/60{background-color:#fff9}@supports (color:color-mix(in lab,red,red)){.bg-white\\/60{background-color:color-mix(in oklab,var(--color-white)60%,transparent)}}.bg-white\\/90{background-color:#ffffffe6}@supports (color:color-mix(in lab,red,red)){.bg-white\\/90{background-color:color-mix(in oklab,var(--color-white)90%,transparent)}}.bg-white\\/95{background-color:#fffffff2}@supports (color:color-mix(in lab,red,red)){.bg-white\\/95{background-color:color-mix(in oklab,var(--color-white)95%,transparent)}}.bg-yellow-500{background-color:var(--color-yellow-500)}.bg-zinc-100\\/50{background-color:#f4f4f580}@supports (color:color-mix(in lab,red,red)){.bg-zinc-100\\/50{background-color:color-mix(in oklab,var(--color-zinc-100)50%,transparent)}}.bg-zinc-100\\/60{background-color:#f4f4f599}@supports (color:color-mix(in lab,red,red)){.bg-zinc-100\\/60{background-color:color-mix(in oklab,var(--color-zinc-100)60%,transparent)}}.bg-zinc-500{background-color:var(--color-zinc-500)}.bg-zinc-500\\/5{background-color:#71717b0d}@supports (color:color-mix(in lab,red,red)){.bg-zinc-500\\/5{background-color:color-mix(in oklab,var(--color-zinc-500)5%,transparent)}}.bg-zinc-700\\/80{background-color:#3f3f46cc}@supports (color:color-mix(in lab,red,red)){.bg-zinc-700\\/80{background-color:color-mix(in oklab,var(--color-zinc-700)80%,transparent)}}.bg-zinc-900{background-color:var(--color-zinc-900)}.bg-gradient-to-b{--tw-gradient-position:to bottom in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-gradient-to-r{--tw-gradient-position:to right in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-radial{--tw-gradient-position:in oklab;background-image:radial-gradient(var(--tw-gradient-stops))}.bg-\\[image\\:var\\(--glass-texture\\)\\]{background-image:var(--glass-texture)}.bg-\\[image\\:var\\(--gradient\\)\\]{background-image:var(--gradient)}.from-transparent{--tw-gradient-from:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-white\\/10{--tw-gradient-from:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.from-white\\/10{--tw-gradient-from:color-mix(in oklab,var(--color-white)10%,transparent)}}.from-white\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-white\\/40{--tw-gradient-from:#fff6}@supports (color:color-mix(in lab,red,red)){.from-white\\/40{--tw-gradient-from:color-mix(in oklab,var(--color-white)40%,transparent)}}.from-white\\/40{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-zinc-100\\/10{--tw-gradient-from:#f4f4f51a}@supports (color:color-mix(in lab,red,red)){.from-zinc-100\\/10{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)10%,transparent)}}.from-zinc-100\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-zinc-100\\/60{--tw-gradient-from:#f4f4f599}@supports (color:color-mix(in lab,red,red)){.from-zinc-100\\/60{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)60%,transparent)}}.from-zinc-100\\/60{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-30\\%{--tw-gradient-from-position:30%}.via-transparent{--tw-gradient-via:transparent;--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-white\\/30{--tw-gradient-via:#ffffff4d}@supports (color:color-mix(in lab,red,red)){.via-white\\/30{--tw-gradient-via:color-mix(in oklab,var(--color-white)30%,transparent)}}.via-white\\/30{--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-zinc-100\\/30{--tw-gradient-via:#f4f4f54d}@supports (color:color-mix(in lab,red,red)){.via-zinc-100\\/30{--tw-gradient-via:color-mix(in oklab,var(--color-zinc-100)30%,transparent)}}.via-zinc-100\\/30{--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.to-transparent{--tw-gradient-to:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-white\\/5{--tw-gradient-to:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.to-white\\/5{--tw-gradient-to:color-mix(in oklab,var(--color-white)5%,transparent)}}.to-white\\/5{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-white\\/10{--tw-gradient-to:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.to-white\\/10{--tw-gradient-to:color-mix(in oklab,var(--color-white)10%,transparent)}}.to-white\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-zinc-50\\/60{--tw-gradient-to:#fafafa99}@supports (color:color-mix(in lab,red,red)){.to-zinc-50\\/60{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-50)60%,transparent)}}.to-zinc-50\\/60{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-zinc-100\\/0{--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.to-zinc-100\\/0{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)0%,transparent)}}.to-zinc-100\\/0{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-zinc-100\\/10{--tw-gradient-to:#f4f4f51a}@supports (color:color-mix(in lab,red,red)){.to-zinc-100\\/10{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)10%,transparent)}}.to-zinc-100\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-75\\%{--tw-gradient-to-position:75%}.mask-\\[linear-gradient\\(to_bottom\\,transparent_0px\\,black_16px\\,black_calc\\(100\\%-16px\\)\\,transparent_100\\%\\)\\]{-webkit-mask-image:linear-gradient(#0000 0,#000 16px calc(100% - 16px),#0000 100%);mask-image:linear-gradient(#0000 0,#000 16px,#000 calc(100% - 16px),#0000)}.mask-\\[linear-gradient\\(to_bottom\\,transparent_0px\\,black_48px\\,black_calc\\(95\\%_-_16px\\)\\,transparent_calc\\(100\\%_-_16px\\)\\)\\]{-webkit-mask-image:linear-gradient(#0000 0,#000 48px calc(95% - 16px),#0000 calc(100% - 16px));mask-image:linear-gradient(#0000 0,#000 48px,#000 calc(95% - 16px),#0000 calc(100% - 16px))}.bg-cover{background-size:cover}.bg-center{background-position:50%}.bg-no-repeat{background-repeat:no-repeat}.mask-alpha{-webkit-mask-source-type:alpha;mask-mode:alpha}.fill-\\[var\\(--active\\)\\]{fill:var(--active)}.fill-current{fill:currentColor}.fill-white{fill:var(--color-white)}.fill-zinc-500{fill:var(--color-zinc-500)}.fill-zinc-500\\/50{fill:#71717b80}@supports (color:color-mix(in lab,red,red)){.fill-zinc-500\\/50{fill:color-mix(in oklab,var(--color-zinc-500)50%,transparent)}}.fill-zinc-950{fill:var(--color-zinc-950)}.stroke-\\[var\\(--active\\)\\]{stroke:var(--active)}.stroke-\\[var\\(--primary\\)\\]{stroke:var(--primary)}.stroke-black{stroke:var(--color-black)}.stroke-black\\/30{stroke:#0000004d}@supports (color:color-mix(in lab,red,red)){.stroke-black\\/30{stroke:color-mix(in oklab,var(--color-black)30%,transparent)}}.stroke-black\\/60{stroke:#0009}@supports (color:color-mix(in lab,red,red)){.stroke-black\\/60{stroke:color-mix(in oklab,var(--color-black)60%,transparent)}}.stroke-blue-600{stroke:var(--color-blue-600)}.stroke-none{stroke:none}.stroke-white{stroke:var(--color-white)}.stroke-zinc-500{stroke:var(--color-zinc-500)}.stroke-1{stroke-width:1px}.stroke-2{stroke-width:2px}.stroke-3{stroke-width:3px}.object-cover{-o-object-fit:cover;object-fit:cover}.p-0{padding:calc(var(--spacing)*0)}.p-0\\.5{padding:calc(var(--spacing)*.5)}.p-1{padding:calc(var(--spacing)*1)}.p-2{padding:calc(var(--spacing)*2)}.p-3{padding:calc(var(--spacing)*3)}.px-0\\.5{padding-inline:calc(var(--spacing)*.5)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-2\\.5{padding-inline:calc(var(--spacing)*2.5)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-\\[9px\\]{padding-inline:9px}.py-0{padding-block:calc(var(--spacing)*0)}.py-0\\.5{padding-block:calc(var(--spacing)*.5)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-3{padding-block:calc(var(--spacing)*3)}.py-4{padding-block:calc(var(--spacing)*4)}.py-\\[5px\\]{padding-block:5px}.pt-1\\.5{padding-top:calc(var(--spacing)*1.5)}.pt-2{padding-top:calc(var(--spacing)*2)}.pt-3{padding-top:calc(var(--spacing)*3)}.pt-16{padding-top:calc(var(--spacing)*16)}.pr-0{padding-right:calc(var(--spacing)*0)}.pr-1{padding-right:calc(var(--spacing)*1)}.pr-3{padding-right:calc(var(--spacing)*3)}.pr-6{padding-right:calc(var(--spacing)*6)}.pr-8{padding-right:calc(var(--spacing)*8)}.pb-0\\.5{padding-bottom:calc(var(--spacing)*.5)}.pb-1{padding-bottom:calc(var(--spacing)*1)}.pb-2{padding-bottom:calc(var(--spacing)*2)}.pb-3{padding-bottom:calc(var(--spacing)*3)}.pb-14{padding-bottom:calc(var(--spacing)*14)}.pl-1{padding-left:calc(var(--spacing)*1)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-3{padding-left:calc(var(--spacing)*3)}.pl-4{padding-left:calc(var(--spacing)*4)}.pl-4\\.5{padding-left:calc(var(--spacing)*4.5)}.text-start{text-align:start}.font-mono{font-family:var(--font-mono)}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[0\\.5em\\]{font-size:.5em}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.break-words{overflow-wrap:break-word}.whitespace-pre{white-space:pre}.text-\\[var\\(--active\\)\\]{color:var(--active)}.text-\\[var\\(--primary\\)\\]{color:var(--primary)}.text-black\\/30{color:#0000004d}@supports (color:color-mix(in lab,red,red)){.text-black\\/30{color:color-mix(in oklab,var(--color-black)30%,transparent)}}.text-black\\/50{color:#00000080}@supports (color:color-mix(in lab,red,red)){.text-black\\/50{color:color-mix(in oklab,var(--color-black)50%,transparent)}}.text-black\\/60{color:#0009}@supports (color:color-mix(in lab,red,red)){.text-black\\/60{color:color-mix(in oklab,var(--color-black)60%,transparent)}}.text-black\\/80{color:#000c}@supports (color:color-mix(in lab,red,red)){.text-black\\/80{color:color-mix(in oklab,var(--color-black)80%,transparent)}}.text-blue-500{color:var(--color-blue-500)}.text-blue-600{color:var(--color-blue-600)}.text-current{color:currentColor}.text-foreground{color:var(--color-foreground)}.text-foreground\\/40{color:#09090b66}@supports (color:color-mix(in lab,red,red)){.text-foreground\\/40{color:color-mix(in oklab,var(--color-foreground)40%,transparent)}}.text-foreground\\/60{color:#09090b99}@supports (color:color-mix(in lab,red,red)){.text-foreground\\/60{color:color-mix(in oklab,var(--color-foreground)60%,transparent)}}.text-foreground\\/70{color:#09090bb3}@supports (color:color-mix(in lab,red,red)){.text-foreground\\/70{color:color-mix(in oklab,var(--color-foreground)70%,transparent)}}.text-foreground\\/80{color:#09090bcc}@supports (color:color-mix(in lab,red,red)){.text-foreground\\/80{color:color-mix(in oklab,var(--color-foreground)80%,transparent)}}.text-green-300{color:var(--color-green-300)}.text-green-600{color:var(--color-green-600)}.text-muted-foreground{color:var(--color-muted-foreground)}.text-red-300{color:var(--color-red-300)}.text-rose-600{color:var(--color-rose-600)}.text-white{color:var(--color-white)}.text-zinc-400{color:var(--color-zinc-400)}.text-zinc-500{color:var(--color-zinc-500)}.text-zinc-600{color:var(--color-zinc-600)}.text-zinc-950{color:var(--color-zinc-950)}.text-zinc-950\\/70{color:#09090bb3}@supports (color:color-mix(in lab,red,red)){.text-zinc-950\\/70{color:color-mix(in oklab,var(--color-zinc-950)70%,transparent)}}.text-zinc-950\\/80{color:#09090bcc}@supports (color:color-mix(in lab,red,red)){.text-zinc-950\\/80{color:color-mix(in oklab,var(--color-zinc-950)80%,transparent)}}.italic{font-style:italic}.\\!opacity-100{opacity:1!important}.opacity-0{opacity:0}.opacity-10{opacity:.1}.opacity-30{opacity:.3}.opacity-50{opacity:.5}.opacity-70{opacity:.7}.opacity-80{opacity:.8}.opacity-100{opacity:1}.shadow-2xs{--tw-shadow:0 1px var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px var(--tw-shadow-color,#0000001a),0 8px 10px -6px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-1{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-2{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-black\\/50{--tw-shadow-color:#00000080}@supports (color:color-mix(in lab,red,red)){.shadow-black\\/50{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-black)50%,transparent)var(--tw-shadow-alpha),transparent)}}.shadow-sky-500\\/10{--tw-shadow-color:#00a5ef1a}@supports (color:color-mix(in lab,red,red)){.shadow-sky-500\\/10{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-sky-500)10%,transparent)var(--tw-shadow-alpha),transparent)}}.shadow-zinc-950\\/10{--tw-shadow-color:#09090b1a}@supports (color:color-mix(in lab,red,red)){.shadow-zinc-950\\/10{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-zinc-950)10%,transparent)var(--tw-shadow-alpha),transparent)}}.ring-black{--tw-ring-color:var(--color-black)}.ring-blue-500\\/50{--tw-ring-color:#3080ff80}@supports (color:color-mix(in lab,red,red)){.ring-blue-500\\/50{--tw-ring-color:color-mix(in oklab,var(--color-blue-500)50%,transparent)}}.ring-rose-100\\/5{--tw-ring-color:#ffe4e60d}@supports (color:color-mix(in lab,red,red)){.ring-rose-100\\/5{--tw-ring-color:color-mix(in oklab,var(--color-rose-100)5%,transparent)}}.ring-white\\/5{--tw-ring-color:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.ring-white\\/5{--tw-ring-color:color-mix(in oklab,var(--color-white)5%,transparent)}}.ring-white\\/20{--tw-ring-color:#fff3}@supports (color:color-mix(in lab,red,red)){.ring-white\\/20{--tw-ring-color:color-mix(in oklab,var(--color-white)20%,transparent)}}.ring-zinc-500\\/10{--tw-ring-color:#71717b1a}@supports (color:color-mix(in lab,red,red)){.ring-zinc-500\\/10{--tw-ring-color:color-mix(in oklab,var(--color-zinc-500)10%,transparent)}}.ring-zinc-950\\/5{--tw-ring-color:#09090b0d}@supports (color:color-mix(in lab,red,red)){.ring-zinc-950\\/5{--tw-ring-color:color-mix(in oklab,var(--color-zinc-950)5%,transparent)}}.ring-zinc-950\\/10{--tw-ring-color:#09090b1a}@supports (color:color-mix(in lab,red,red)){.ring-zinc-950\\/10{--tw-ring-color:color-mix(in oklab,var(--color-zinc-950)10%,transparent)}}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-\\[0\\.2px\\]{--tw-blur:blur(.2px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-md{--tw-blur:blur(var(--blur-md));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-none{--tw-blur: ;filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-sm{--tw-blur:blur(var(--blur-sm));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.brightness-90{--tw-brightness:brightness(90%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-xl{--tw-drop-shadow-size:drop-shadow(0 9px 7px var(--tw-drop-shadow-color,#0000001a));--tw-drop-shadow:drop-shadow(var(--drop-shadow-xl));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.backdrop-blur-\\[1px\\]{--tw-backdrop-blur:blur(1px);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-blur-\\[2px\\]{--tw-backdrop-blur:blur(2px);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-blur-lg{--tw-backdrop-blur:blur(var(--blur-lg));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-saturate-150{--tw-backdrop-saturate:saturate(150%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-100{--tw-duration:.1s;transition-duration:.1s}.duration-150{--tw-duration:.15s;transition-duration:.15s}.duration-200{--tw-duration:.2s;transition-duration:.2s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.duration-500{--tw-duration:.5s;transition-duration:.5s}.duration-1000{--tw-duration:1s;transition-duration:1s}.ease-in{--tw-ease:var(--ease-in);transition-timing-function:var(--ease-in)}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.ease-spring{--tw-ease:var(--ease-spring);transition-timing-function:var(--ease-spring)}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.\\[--active-secondary\\:var\\(--color-blue-100\\)\\]{--active-secondary:var(--color-blue-100)}.\\[--active-secondary\\:var\\(--color-orange-100\\)\\]{--active-secondary:var(--color-orange-100)}.\\[--active\\:var\\(--color-blue-600\\)\\]{--active:var(--color-blue-600)}.\\[--active\\:var\\(--color-orange-600\\)\\]{--active:var(--color-orange-600)}.\\[--anchor-gap\\:8px\\]{--anchor-gap:8px}.\\[--color-foreground\\:var\\(--color-orange-700\\)\\]{--color-foreground:var(--color-orange-700)}.\\[--color-muted-foreground\\:var\\(--color-orange-700\\)\\]{--color-muted-foreground:var(--color-orange-700)}.\\[--primary\\:var\\(--color-orange-900\\)\\]{--primary:var(--color-orange-900)}.\\[--primary\\:var\\(--color-zinc-950\\)\\]{--primary:var(--color-zinc-950)}.\\[--secondary\\:var\\(--color-orange-100\\)\\]{--secondary:var(--color-orange-100)}.\\[--secondary\\:var\\(--color-zinc-400\\)\\]{--secondary:var(--color-zinc-400)}.ring-inset{--tw-ring-inset:inset}.scrollbar-thumb-black\\/10{--scrollbar-thumb:oklab(0% none none/.1)}.scrollbar-thumb-black\\/15{--scrollbar-thumb:oklab(0% none none/.15)}.scrollbar-thumb-black\\/20{--scrollbar-thumb:oklab(0% none none/.2)}.scrollbar-track-transparent{--scrollbar-track:transparent}:is(.\\*\\:pointer-events-auto>*){pointer-events:auto}:is(.\\*\\:size-full>*){width:100%;height:100%}@media (hover:hover){.group-hover\\:-top-3:is(:where(.group):hover *){top:calc(var(--spacing)*-3)}.group-hover\\:fill-zinc-800:is(:where(.group):hover *){fill:var(--color-zinc-800)}.group-hover\\:stroke-black:is(:where(.group):hover *){stroke:var(--color-black)}.group-hover\\:stroke-zinc-800:is(:where(.group):hover *){stroke:var(--color-zinc-800)}.group-hover\\:opacity-100:is(:where(.group):hover *){opacity:1}}.group-data-open\\:rotate-180:is(:where(.group)[data-open] *){rotate:180deg}.placeholder\\:text-foreground\\/40::-moz-placeholder{color:#09090b66}.placeholder\\:text-foreground\\/40::placeholder{color:#09090b66}@supports (color:color-mix(in lab,red,red)){.placeholder\\:text-foreground\\/40::-moz-placeholder{color:color-mix(in oklab,var(--color-foreground)40%,transparent)}.placeholder\\:text-foreground\\/40::placeholder{color:color-mix(in oklab,var(--color-foreground)40%,transparent)}}.before\\:absolute:before{content:var(--tw-content);position:absolute}.before\\:inset-0:before{content:var(--tw-content);inset:calc(var(--spacing)*0)}.before\\:-z-20:before{content:var(--tw-content);z-index:-20}.before\\:size-full:before{content:var(--tw-content);width:100%;height:100%}.before\\:content-normal:before{content:var(--tw-content);align-content:normal}.before\\:rounded-\\[inherit\\]:before{content:var(--tw-content);border-radius:inherit}.before\\:border:before{content:var(--tw-content);border-style:var(--tw-border-style);border-width:1px}.before\\:border-zinc-950\\/20:before{content:var(--tw-content);border-color:#09090b33}@supports (color:color-mix(in lab,red,red)){.before\\:border-zinc-950\\/20:before{border-color:color-mix(in oklab,var(--color-zinc-950)20%,transparent)}}.before\\:bg-orange-50\\/80:before{content:var(--tw-content);background-color:#fff7edcc}@supports (color:color-mix(in lab,red,red)){.before\\:bg-orange-50\\/80:before{background-color:color-mix(in oklab,var(--color-orange-50)80%,transparent)}}.before\\:bg-white\\/85:before{content:var(--tw-content);background-color:#ffffffd9}@supports (color:color-mix(in lab,red,red)){.before\\:bg-white\\/85:before{background-color:color-mix(in oklab,var(--color-white)85%,transparent)}}.before\\:ring-\\[1\\.5px\\]:before{content:var(--tw-content);--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1.5px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.before\\:ring-white\\/30:before{content:var(--tw-content);--tw-ring-color:#ffffff4d}@supports (color:color-mix(in lab,red,red)){.before\\:ring-white\\/30:before{--tw-ring-color:color-mix(in oklab,var(--color-white)30%,transparent)}}.before\\:backdrop-blur-sm:before{content:var(--tw-content);--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.before\\:ring-inset:before{content:var(--tw-content);--tw-ring-inset:inset}.after\\:pointer-events-none:after{content:var(--tw-content);pointer-events:none}.after\\:absolute:after{content:var(--tw-content);position:absolute}.after\\:inset-0:after{content:var(--tw-content);inset:calc(var(--spacing)*0)}.after\\:block:after{content:var(--tw-content);display:block}.after\\:size-full:after{content:var(--tw-content);width:100%;height:100%}.after\\:content-normal:after{content:var(--tw-content);align-content:normal}.after\\:rounded-\\[inherit\\]:after{content:var(--tw-content);border-radius:inherit}.after\\:bg-gradient-to-b:after{content:var(--tw-content);--tw-gradient-position:to bottom in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.after\\:from-white\\/5:after{content:var(--tw-content);--tw-gradient-from:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.after\\:from-white\\/5:after{--tw-gradient-from:color-mix(in oklab,var(--color-white)5%,transparent)}}.after\\:from-white\\/5:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.after\\:to-white\\/0:after{content:var(--tw-content);--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.after\\:to-white\\/0:after{--tw-gradient-to:color-mix(in oklab,var(--color-white)0%,transparent)}}.after\\:to-white\\/0:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.after\\:shadow-glass:after{content:var(--tw-content);--tw-shadow:var(--shadow-lg),0px -48px 48px -48px var(--tw-shadow-color,#0000000d)inset,0 5px 42px -5px var(--tw-shadow-color,#ffffff40)inset;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.after\\:transition-colors:after{content:var(--tw-content);transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.after\\:duration-150:after{content:var(--tw-content);--tw-duration:.15s;transition-duration:.15s}.after\\:ease-out:after{content:var(--tw-content);--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.last\\:mb-0\\.5:last-child{margin-bottom:calc(var(--spacing)*.5)}.focus-within\\:outline-none:focus-within{--tw-outline-style:none;outline-style:none}@media (hover:hover){.hover\\:border-black\\/5:hover{border-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.hover\\:border-black\\/5:hover{border-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.hover\\:border-border\\/40:hover{border-color:#71717b66}@supports (color:color-mix(in lab,red,red)){.hover\\:border-border\\/40:hover{border-color:color-mix(in oklab,var(--color-border)40%,transparent)}}.hover\\:border-rose-600\\/70:hover{border-color:#e70044b3}@supports (color:color-mix(in lab,red,red)){.hover\\:border-rose-600\\/70:hover{border-color:color-mix(in oklab,var(--color-rose-600)70%,transparent)}}.hover\\:bg-black\\/10:hover{background-color:#0000001a}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-black\\/10:hover{background-color:color-mix(in oklab,var(--color-black)10%,transparent)}}.hover\\:bg-rose-600\\/5:hover{background-color:#e700440d}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-rose-600\\/5:hover{background-color:color-mix(in oklab,var(--color-rose-600)5%,transparent)}}.hover\\:bg-rose-600\\/10:hover{background-color:#e700441a}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-rose-600\\/10:hover{background-color:color-mix(in oklab,var(--color-rose-600)10%,transparent)}}.hover\\:bg-rose-600\\/20:hover{background-color:#e7004433}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-rose-600\\/20:hover{background-color:color-mix(in oklab,var(--color-rose-600)20%,transparent)}}.hover\\:bg-white\\/0:hover{background-color:#0000}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-white\\/0:hover{background-color:color-mix(in oklab,var(--color-white)0%,transparent)}}.hover\\:bg-white\\/60:hover{background-color:#fff9}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-white\\/60:hover{background-color:color-mix(in oklab,var(--color-white)60%,transparent)}}.hover\\:bg-white\\/80:hover{background-color:#fffc}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-white\\/80:hover{background-color:color-mix(in oklab,var(--color-white)80%,transparent)}}.hover\\:bg-zinc-500\\/5:hover{background-color:#71717b0d}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-zinc-500\\/5:hover{background-color:color-mix(in oklab,var(--color-zinc-500)5%,transparent)}}.hover\\:bg-zinc-950\\/10:hover{background-color:#09090b1a}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-zinc-950\\/10:hover{background-color:color-mix(in oklab,var(--color-zinc-950)10%,transparent)}}.hover\\:from-zinc-100\\/40:hover{--tw-gradient-from:#f4f4f566}@supports (color:color-mix(in lab,red,red)){.hover\\:from-zinc-100\\/40:hover{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)40%,transparent)}}.hover\\:from-zinc-100\\/40:hover{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\:from-20\\%:hover{--tw-gradient-from-position:20%}.hover\\:to-zinc-100\\/0:hover{--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.hover\\:to-zinc-100\\/0:hover{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)0%,transparent)}}.hover\\:to-zinc-100\\/0:hover{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\:to-75\\%:hover{--tw-gradient-to-position:75%}.hover\\:text-black\\/90:hover{color:#000000e6}@supports (color:color-mix(in lab,red,red)){.hover\\:text-black\\/90:hover{color:color-mix(in oklab,var(--color-black)90%,transparent)}}.hover\\:text-red-500:hover{color:var(--color-red-500)}.hover\\:text-rose-600:hover{color:var(--color-rose-600)}.hover\\:text-zinc-900:hover{color:var(--color-zinc-900)}.hover\\:opacity-70:hover{opacity:.7}.hover\\:opacity-90:hover{opacity:.9}.hover\\:opacity-100:hover{opacity:1}.hover\\:shadow-lg:hover{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\:shadow-xs:hover{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\:after\\:from-blue-50\\/20:hover:after{content:var(--tw-content);--tw-gradient-from:#eff6ff33}@supports (color:color-mix(in lab,red,red)){.hover\\:after\\:from-blue-50\\/20:hover:after{--tw-gradient-from:color-mix(in oklab,var(--color-blue-50)20%,transparent)}}.hover\\:after\\:from-blue-50\\/20:hover:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\:after\\:to-blue-50\\/15:hover:after{content:var(--tw-content);--tw-gradient-to:#eff6ff26}@supports (color:color-mix(in lab,red,red)){.hover\\:after\\:to-blue-50\\/15:hover:after{--tw-gradient-to:color-mix(in oklab,var(--color-blue-50)15%,transparent)}}.hover\\:after\\:to-blue-50\\/15:hover:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}}.focus\\:bg-blue-200\\/20:focus{background-color:#bedbff33}@supports (color:color-mix(in lab,red,red)){.focus\\:bg-blue-200\\/20:focus{background-color:color-mix(in oklab,var(--color-blue-200)20%,transparent)}}.focus\\:text-zinc-900:focus{color:var(--color-zinc-900)}.focus\\:shadow-lg:focus{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:shadow-blue-400\\/10:focus{--tw-shadow-color:#54a2ff1a}@supports (color:color-mix(in lab,red,red)){.focus\\:shadow-blue-400\\/10:focus{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-blue-400)10%,transparent)var(--tw-shadow-alpha),transparent)}}.focus\\:ring-blue-500:focus{--tw-ring-color:var(--color-blue-500)}.focus\\:outline-none:focus{--tw-outline-style:none;outline-style:none}.active\\:scale-\\[98\\%\\]:active{scale:98%}.active\\:border-black\\/15:active{border-color:#00000026}@supports (color:color-mix(in lab,red,red)){.active\\:border-black\\/15:active{border-color:color-mix(in oklab,var(--color-black)15%,transparent)}}.active\\:bg-zinc-50\\/60:active{background-color:#fafafa99}@supports (color:color-mix(in lab,red,red)){.active\\:bg-zinc-50\\/60:active{background-color:color-mix(in oklab,var(--color-zinc-50)60%,transparent)}}.active\\:after\\:from-transparent:active:after{content:var(--tw-content);--tw-gradient-from:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.active\\:after\\:to-transparent:active:after{content:var(--tw-content);--tw-gradient-to:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:bg-black\\/5:disabled{background-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.disabled\\:bg-black\\/5:disabled{background-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.disabled\\:bg-transparent:disabled{background-color:#0000}.disabled\\:text-foreground\\/60:disabled{color:#09090b99}@supports (color:color-mix(in lab,red,red)){.disabled\\:text-foreground\\/60:disabled{color:color-mix(in oklab,var(--color-foreground)60%,transparent)}}.disabled\\:opacity-30:disabled{opacity:.3}.disabled\\:shadow-none:disabled{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}:is(.disabled\\:\\*\\:stroke-zinc-500\\/50:disabled>*){stroke:#71717b80}@supports (color:color-mix(in lab,red,red)){:is(.disabled\\:\\*\\:stroke-zinc-500\\/50:disabled>*){stroke:color-mix(in oklab,var(--color-zinc-500)50%,transparent)}}.data-focus\\:outline-none[data-focus]{--tw-outline-style:none;outline-style:none}.animate-shake{animation:.5s ease-in-out 2 shake}}:root{color-scheme:normal;font-feature-settings:"liga" 1,"calt" 1;background-color:#0000}body{background-color:#0000}.root{isolation:isolate}.markdown a{color:var(--color-blue-600)}@media (hover:hover){.markdown a:hover{color:var(--color-blue-700)}}.markdown ul{margin-left:calc(var(--spacing)*4);list-style-type:disc}.markdown ol{margin-left:calc(var(--spacing)*4);list-style-type:decimal}@keyframes shake{0%,to{transform:translate(0)}10%,30%,50%,70%,90%{transform:translate(-2px)}20%,40%,60%,80%{transform:translate(2px)}}@keyframes gradient-animation{0%{background-position:0%}50%{background-position:100%}to{background-position:0%}}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-scale-x{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-y{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-z{syntax:"*";inherits:false;initial-value:1}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-divide-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-gradient-position{syntax:"*";inherits:false}@property --tw-gradient-from{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-via{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-to{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-stops{syntax:"*";inherits:false}@property --tw-gradient-via-stops{syntax:"*";inherits:false}@property --tw-gradient-from-position{syntax:"<length-percentage>";inherits:false;initial-value:0%}@property --tw-gradient-via-position{syntax:"<length-percentage>";inherits:false;initial-value:50%}@property --tw-gradient-to-position{syntax:"<length-percentage>";inherits:false;initial-value:100%}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}@property --tw-content{syntax:"*";inherits:false;initial-value:""}@keyframes spin{to{transform:rotate(360deg)}}@keyframes pulse{50%{opacity:.5}}@keyframes chat-bubble-appear{0%{filter:blur(4px);opacity:0;transform:scale(.5)translateY(16px)}to{filter:blur();opacity:1;transform:scale(1)translate(0)}}', ChatHistoryContext = createContext({
  chatInput: "",
  setChatInput: () => {
  },
  domContextElements: [],
  addChatDomContext: () => {
  },
  removeChatDomContext: () => {
  },
  sendMessage: () => {
  },
  fileAttachments: [],
  addFileAttachment: () => {
  },
  removeFileAttachment: () => {
  },
  clearFileAttachments: () => {
  },
  isPromptCreationActive: !1,
  startPromptCreation: () => {
  },
  stopPromptCreation: () => {
  },
  isContextSelectorActive: !1,
  startContextSelector: () => {
  },
  stopContextSelector: () => {
  },
  isSending: !1
}), ChatStateProvider = ({ children }) => {
  const [chatInput, setChatInput] = useState(""), [isPromptCreationMode, setIsPromptCreationMode] = useState(!1), [isContextSelectorMode, setIsContextSelectorMode] = useState(!1), [isSending, setIsSending] = useState(!1), [domContextElements, setDomContextElements] = useState([]), [fileAttachments, setFileAttachments] = useState([]), { minimized } = useAppState(), { plugins } = usePlugins(), sendChatMessage = useKartonProcedure((p2) => p2.sendUserMessage), isWorking = useKartonState((s2) => s2.isWorking), { isChatOpen, openChat } = usePanels(), startPromptCreation = useCallback(() => {
    setIsPromptCreationMode(!0), isChatOpen || openChat(), plugins.forEach((plugin) => {
      var _a;
      (_a = plugin.onPromptingStart) == null || _a.call(plugin);
    });
  }, [plugins, isChatOpen, openChat]), addFileAttachment = useCallback((file) => {
    const id = generateId(), url = URL.createObjectURL(file);
    setFileAttachments((prev) => [...prev, { id, file, url }]);
  }, []), removeFileAttachment = useCallback((id) => {
    setFileAttachments((prev) => {
      const attachment = prev.find((a3) => a3.id === id);
      return attachment && URL.revokeObjectURL(attachment.url), prev.filter((a3) => a3.id !== id);
    });
  }, []), clearFileAttachments = useCallback(() => {
    setFileAttachments((prev) => (prev.forEach((attachment) => {
      URL.revokeObjectURL(attachment.url);
    }), []));
  }, []), stopPromptCreation = useCallback(() => {
    setIsPromptCreationMode(!1), setIsContextSelectorMode(!1), setDomContextElements([]), plugins.forEach((plugin) => {
      var _a;
      (_a = plugin.onPromptingAbort) == null || _a.call(plugin);
    });
  }, [plugins]), startContextSelector = useCallback(() => {
    setIsContextSelectorMode(!0);
  }, []), stopContextSelector = useCallback(() => {
    setIsContextSelectorMode(!1);
  }, []);
  useEffect(() => {
    isChatOpen || stopPromptCreation();
  }, [isChatOpen, stopPromptCreation]), useEffect(() => {
    minimized && stopPromptCreation();
  }, [minimized, stopPromptCreation]), useEffect(() => {
    isWorking && isPromptCreationMode && stopPromptCreation();
  }, [isWorking, isPromptCreationMode, stopPromptCreation]);
  const addChatDomContext = useCallback(
    (element2) => {
      const pluginsWithContextGetters = plugins.filter(
        (plugin) => plugin.onContextElementSelect
      );
      setDomContextElements((prev) => [
        ...prev,
        {
          element: element2,
          pluginContext: pluginsWithContextGetters.map((plugin) => {
            var _a;
            return {
              pluginName: plugin.pluginName,
              context: (_a = plugin.onContextElementSelect) == null ? void 0 : _a.call(plugin, element2)
            };
          })
        }
      ]);
    },
    [plugins]
  ), removeChatDomContext = useCallback((element2) => {
    setDomContextElements(
      (prev) => prev.filter((item) => item.element !== element2)
    );
  }, []), sendMessage = useCallback(async () => {
    if (chatInput.trim()) {
      setIsSending(!0);
      try {
        const supportedAttachments = fileAttachments.filter(
          (attachment) => isAnthropicSupportedFile(attachment.file).supported
        ), fileParts = await Promise.all(
          supportedAttachments.map(async (attachment) => ({
            type: "file",
            mediaType: attachment.file.type,
            filename: attachment.file.name,
            url: await fileToDataUrl(attachment.file)
          }))
        ), metadata = collectUserMessageMetadata(
          domContextElements.map((item) => getSelectedElementInfo(item.element)),
          !1
        ), message = {
          id: generateId(),
          parts: [...fileParts, { type: "text", text: chatInput }],
          role: "user",
          metadata: {
            ...metadata,
            createdAt: /* @__PURE__ */ new Date()
          }
        }, pluginProcessingPromises = plugins.map(async (plugin) => {
          var _a;
          const handlerResult = await ((_a = plugin.onPromptSend) == null ? void 0 : _a.call(plugin, message));
          if (!handlerResult || !handlerResult.contextSnippets || handlerResult.contextSnippets.length === 0)
            return null;
          const snippetPromises = handlerResult.contextSnippets.map(
            async (snippet) => {
              const resolvedContent = typeof snippet.content == "string" ? snippet.content : await snippet.content();
              return {
                promptContextName: snippet.promptContextName,
                content: resolvedContent
              };
            }
          ), resolvedSnippets = await Promise.all(snippetPromises);
          return resolvedSnippets.length > 0 ? {
            pluginName: plugin.pluginName,
            contextSnippets: resolvedSnippets
          } : null;
        });
        (await Promise.all(pluginProcessingPromises)).forEach((context) => {
          context && (message.metadata.pluginContentItems[context.pluginName] = {}, context.contextSnippets.forEach((snippet) => {
            const contentItem = {
              type: "text",
              text: snippet.content
            };
            message.metadata.pluginContentItems[context.pluginName][snippet.promptContextName] = contentItem;
          }));
        }), setChatInput(""), setDomContextElements([]), clearFileAttachments(), stopPromptCreation(), await sendChatMessage(message);
      } finally {
        setIsSending(!1);
      }
    }
  }, [
    chatInput,
    domContextElements,
    fileAttachments,
    plugins,
    sendChatMessage,
    clearFileAttachments,
    stopPromptCreation
  ]), value = {
    chatInput,
    setChatInput,
    domContextElements,
    addChatDomContext,
    removeChatDomContext,
    sendMessage,
    fileAttachments,
    addFileAttachment,
    removeFileAttachment,
    clearFileAttachments,
    isPromptCreationActive: isPromptCreationMode,
    startPromptCreation,
    stopPromptCreation,
    isContextSelectorActive: isContextSelectorMode,
    startContextSelector,
    stopContextSelector,
    isSending
  };
  return /* @__PURE__ */ jsx(ChatHistoryContext.Provider, { value, children });
};
function useChatState() {
  const context = useContext(ChatHistoryContext);
  if (!context)
    throw new Error("useChatState must be used within a ChatStateProvider");
  return context;
}
var define_process_env_default$k = {};
function useControlled({
  controlled,
  default: defaultProp,
  name: name2,
  state = "value"
}) {
  const {
    current: isControlled
  } = React.useRef(controlled !== void 0), [valueState, setValue] = React.useState(defaultProp), value = isControlled ? controlled : valueState;
  if (define_process_env_default$k.NODE_ENV !== "production") {
    React.useEffect(() => {
      isControlled !== (controlled !== void 0) && console.error([`Base UI: A component is changing the ${isControlled ? "" : "un"}controlled ${state} state of ${name2} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${name2} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [state, name2, controlled]);
    const {
      current: defaultValue
    } = React.useRef(defaultProp);
    React.useEffect(() => {
      !isControlled && !Object.is(defaultValue, defaultProp) && console.error([`Base UI: A component is changing the default ${state} state of an uncontrolled ${name2} after being initialized. To suppress this warning opt to use a controlled ${name2}.`].join(`
`));
    }, [JSON.stringify(defaultProp)]);
  }
  const setValueIfUncontrolled = React.useCallback((newValue) => {
    isControlled || setValue(newValue);
  }, []);
  return [value, setValueIfUncontrolled];
}
const UNINITIALIZED = {};
function useRefWithInit(init, initArg) {
  const ref = React.useRef(UNINITIALIZED);
  return ref.current === UNINITIALIZED && (ref.current = init(initArg)), ref;
}
var define_process_env_default$j = {};
const useInsertionEffect$1 = React[`useInsertionEffect${Math.random().toFixed(1)}`.slice(0, -3)], useSafeInsertionEffect$1 = (
  // React 17 doesn't have useInsertionEffect.
  useInsertionEffect$1 && // Preact replaces useInsertionEffect with useLayoutEffect and fires too late.
  useInsertionEffect$1 !== React.useLayoutEffect ? useInsertionEffect$1 : (fn) => fn()
);
function useEventCallback(callback) {
  const stable = useRefWithInit(createStableCallback).current;
  return stable.next = callback, useSafeInsertionEffect$1(stable.effect), stable.trampoline;
}
function createStableCallback() {
  const stable = {
    next: void 0,
    callback: assertNotCalled,
    trampoline: (...args) => {
      var _a;
      return (_a = stable.callback) == null ? void 0 : _a.call(stable, ...args);
    },
    effect: () => {
      stable.callback = stable.next;
    }
  };
  return stable;
}
function assertNotCalled() {
  if (define_process_env_default$j.NODE_ENV !== "production")
    throw new Error("Base UI: Cannot call an event handler while rendering.");
}
var define_process_env_default$i = {};
const TooltipRootContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$i.NODE_ENV !== "production" && (TooltipRootContext.displayName = "TooltipRootContext");
function useTooltipRootContext() {
  const context = React.useContext(TooltipRootContext);
  if (context === void 0)
    throw new Error("Base UI: TooltipRootContext is missing. Tooltip parts must be placed within <Tooltip.Root>.");
  return context;
}
const EMPTY$3 = [];
function useOnMount(fn) {
  React.useEffect(fn, EMPTY$3);
}
const EMPTY$2 = 0;
class Timeout {
  constructor() {
    __publicField(this, "currentId", EMPTY$2);
    __publicField(this, "clear", () => {
      this.currentId !== EMPTY$2 && (clearTimeout(this.currentId), this.currentId = EMPTY$2);
    });
    __publicField(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = EMPTY$2, fn();
    }, delay);
  }
  isStarted() {
    return this.currentId !== EMPTY$2;
  }
}
function useTimeout() {
  const timeout = useRefWithInit(Timeout.create).current;
  return useOnMount(timeout.disposeEffect), timeout;
}
const noop$1 = () => {
}, useIsoLayoutEffect = typeof document < "u" ? React.useLayoutEffect : noop$1;
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(node2) {
  return isNode(node2) ? (node2.nodeName || "").toLowerCase() : "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return hasWindow() ? value instanceof Node || value instanceof getWindow(value).Node : !1;
}
function isElement(value) {
  return hasWindow() ? value instanceof Element || value instanceof getWindow(value).Element : !1;
}
function isHTMLElement(value) {
  return hasWindow() ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : !1;
}
function isShadowRoot(value) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements$1 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element2) {
  return tableElements$1.has(getNodeName(element2));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element2) {
  return topLayerSelectors.some((selector) => {
    try {
      return element2.matches(selector);
    } catch {
      return !1;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"], willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"], containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit(), css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : !1) || (css.containerType ? css.containerType !== "normal" : !1) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : !1) || !webkit && (css.filter ? css.filter !== "none" : !1) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  for (; isHTMLElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    if (isContainingBlock(currentNode))
      return currentNode;
    if (isTopLayer(currentNode))
      return null;
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node2) {
  return lastTraversableNodeNames.has(getNodeName(node2));
}
function getComputedStyle$1(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  return isElement(element2) ? {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  } : {
    scrollLeft: element2.scrollX,
    scrollTop: element2.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html")
    return node2;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  return isLastTraversableNode(parentNode) ? node2.ownerDocument ? node2.ownerDocument.body : node2.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  list2 === void 0 && (list2 = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node2), isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function useLatestRef$1(value) {
  const latest = useRefWithInit(createLatestRef, value).current;
  return latest.next = value, useIsoLayoutEffect(latest.effect), latest;
}
function createLatestRef(value) {
  const latest = {
    current: value,
    next: value,
    effect: () => {
      latest.current = latest.next;
    }
  };
  return latest;
}
const hasNavigator = typeof navigator < "u", nav = getNavigatorData(), platform$1 = getPlatform(), userAgent = getUserAgent$1();
typeof CSS > "u" || !CSS.supports || CSS.supports("-webkit-backdrop-filter:none");
nav.platform === "MacIntel" && nav.maxTouchPoints > 1 || /iP(hone|ad|od)|iOS/.test(nav.platform);
const isSafari = hasNavigator && /apple/i.test(navigator.vendor), isMac = hasNavigator && platform$1.toLowerCase().startsWith("mac") && !navigator.maxTouchPoints, isJSDOM = userAgent.includes("jsdom/");
function getNavigatorData() {
  if (!hasNavigator)
    return {
      platform: "",
      maxTouchPoints: -1
    };
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? {
    platform: uaData.platform,
    maxTouchPoints: navigator.maxTouchPoints
  } : {
    platform: navigator.platform ?? "",
    maxTouchPoints: navigator.maxTouchPoints ?? -1
  };
}
function getUserAgent$1() {
  if (!hasNavigator)
    return "";
  const uaData = navigator.userAgentData;
  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map(({
    brand,
    version
  }) => `${brand}/${version}`).join(" ") : navigator.userAgent;
}
function getPlatform() {
  if (!hasNavigator)
    return "";
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? uaData.platform : navigator.platform ?? "";
}
const FOCUSABLE_ATTRIBUTE$1 = "data-base-ui-focusable", ACTIVE_KEY$1 = "active", SELECTED_KEY$1 = "selected", TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function activeElement(doc) {
  var _a;
  let element2 = doc.activeElement;
  for (; ((_a = element2 == null ? void 0 : element2.shadowRoot) == null ? void 0 : _a.activeElement) != null; )
    element2 = element2.shadowRoot.activeElement;
  return element2;
}
function contains(parent, child) {
  var _a;
  if (!parent || !child)
    return !1;
  const rootNode = (_a = child.getRootNode) == null ? void 0 : _a.call(child);
  if (parent.contains(child))
    return !0;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    for (; next; ) {
      if (parent === next)
        return !0;
      next = next.parentNode || next.host;
    }
  }
  return !1;
}
function getTarget(event) {
  return "composedPath" in event ? event.composedPath()[0] : event.target;
}
function isEventTargetWithin(event, node2) {
  if (node2 == null)
    return !1;
  if ("composedPath" in event)
    return event.composedPath().includes(node2);
  const eventAgain = event;
  return eventAgain.target != null && node2.contains(eventAgain.target);
}
function isRootElement(element2) {
  return element2.matches("html,body");
}
function getDocument(node2) {
  return (node2 == null ? void 0 : node2.ownerDocument) || document;
}
function isTypeableElement(element2) {
  return isHTMLElement(element2) && element2.matches(TYPEABLE_SELECTOR);
}
function matchesFocusVisible(element2) {
  if (!element2 || isJSDOM)
    return !0;
  try {
    return element2.matches(":focus-visible");
  } catch {
    return !0;
  }
}
function getNodeChildren(nodes, id, onlyOpenChildren = !0) {
  return nodes.filter((node2) => {
    var _a;
    return node2.parentId === id && (!onlyOpenChildren || ((_a = node2.context) == null ? void 0 : _a.open));
  }).flatMap((child) => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  return values.push("", void 0), values.includes(pointerType);
}
const sides = ["top", "right", "bottom", "left"], min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (v2) => ({
  x: v2,
  y: v2
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value == "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1);
  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  return rects.reference[length] > rects.floating[length] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      return rtl ? isStart ? rlPlacement : lrPlacement : isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  return alignment && (list2 = list2.map((side) => side + "-" + alignment), flipAlignment && (list2 = list2.concat(list2.map(getOppositeAlignmentPlacement)))), list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding != "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
const SafeReact$1 = {
  ...React
};
let globalId = 0;
function useGlobalId(idOverride, prefix = "mui") {
  const [defaultId, setDefaultId] = React.useState(idOverride), id = idOverride || defaultId;
  return React.useEffect(() => {
    defaultId == null && (globalId += 1, setDefaultId(`${prefix}-${globalId}`));
  }, [defaultId, prefix]), id;
}
const maybeReactUseId = SafeReact$1.useId;
function useId$1(idOverride, prefix) {
  return maybeReactUseId !== void 0 ? maybeReactUseId() : useGlobalId(idOverride, prefix);
}
function createEventEmitter() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _a;
      (_a = map.get(event)) == null || _a.forEach((listener) => listener(data));
    },
    on(event, listener) {
      map.has(event) || map.set(event, /* @__PURE__ */ new Set()), map.get(event).add(listener);
    },
    off(event, listener) {
      var _a;
      (_a = map.get(event)) == null || _a.delete(listener);
    }
  };
}
var define_process_env_default$h = {};
const FloatingNodeContext$1 = /* @__PURE__ */ React.createContext(null);
define_process_env_default$h.NODE_ENV !== "production" && (FloatingNodeContext$1.displayName = "FloatingNodeContext");
const FloatingTreeContext$1 = /* @__PURE__ */ React.createContext(null);
define_process_env_default$h.NODE_ENV !== "production" && (FloatingTreeContext$1.displayName = "FloatingTreeContext");
const useFloatingParentNodeId$1 = () => {
  var _a;
  return ((_a = React.useContext(FloatingNodeContext$1)) == null ? void 0 : _a.id) || null;
}, useFloatingTree$1 = () => React.useContext(FloatingTreeContext$1);
function createAttribute(name2) {
  return `data-base-ui-${name2}`;
}
const safePolygonIdentifier = createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType))
    return 0;
  if (typeof value == "number")
    return value;
  if (typeof value == "function") {
    const result = value();
    return typeof result == "number" ? result : result == null ? void 0 : result[prop];
  }
  return value == null ? void 0 : value[prop];
}
function getRestMs(value) {
  return typeof value == "function" ? value() : value;
}
function useHover(context, props = {}) {
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context, {
    enabled = !0,
    delay = 0,
    handleClose = null,
    mouseOnly = !1,
    restMs = 0,
    move = !0
  } = props, tree = useFloatingTree$1(), parentId = useFloatingParentNodeId$1(), handleCloseRef = useLatestRef$1(handleClose), delayRef = useLatestRef$1(delay), openRef = useLatestRef$1(open), restMsRef = useLatestRef$1(restMs), pointerTypeRef = React.useRef(void 0), timeout = useTimeout(), handlerRef = React.useRef(void 0), restTimeout = useTimeout(), blockMouseMoveRef = React.useRef(!0), performedPointerEventsMutationRef = React.useRef(!1), unbindMouseMoveRef = React.useRef(() => {
  }), restTimeoutPendingRef = React.useRef(!1), isHoverOpen = useEventCallback(() => {
    var _a;
    const type = (_a = dataRef.current.openEvent) == null ? void 0 : _a.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  });
  React.useEffect(() => {
    if (!enabled)
      return;
    function onOpenChangeLocal({
      open: newOpen
    }) {
      newOpen || (timeout.clear(), restTimeout.clear(), blockMouseMoveRef.current = !0, restTimeoutPendingRef.current = !1);
    }
    return events.on("openchange", onOpenChangeLocal), () => {
      events.off("openchange", onOpenChangeLocal);
    };
  }, [enabled, events, timeout, restTimeout]), React.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open)
      return;
    function onLeave(event) {
      isHoverOpen() && onOpenChange(!1, event, "hover");
    }
    const html2 = getDocument(elements.floating).documentElement;
    return html2.addEventListener("mouseleave", onLeave), () => {
      html2.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React.useCallback((event, runElseBranch = !0, reason = "hover") => {
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    closeDelay && !handlerRef.current ? timeout.start(closeDelay, () => onOpenChange(!1, event, reason)) : runElseBranch && (timeout.clear(), onOpenChange(!1, event, reason));
  }, [delayRef, onOpenChange, timeout]), cleanupMouseMoveHandler = useEventCallback(() => {
    unbindMouseMoveRef.current(), handlerRef.current = void 0;
  }), clearPointerEvents = useEventCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "", body.removeAttribute(safePolygonIdentifier), performedPointerEventsMutationRef.current = !1;
    }
  }), isClickLikeOpenEvent = useEventCallback(() => dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : !1);
  React.useEffect(() => {
    if (!enabled)
      return;
    function onReferenceMouseEnter(event) {
      if (timeout.clear(), blockMouseMoveRef.current = !1, mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open"))
        return;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      openDelay ? timeout.start(openDelay, () => {
        openRef.current || onOpenChange(!0, event, "hover");
      }) : open || onOpenChange(!0, event, "hover");
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      if (restTimeout.clear(), restTimeoutPendingRef.current = !1, handleCloseRef.current && dataRef.current.floatingContext) {
        open || timeout.clear(), handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event, !0, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler), unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      (pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : !0) && closeWithDelay(event);
    }
    function onScrollMouseLeave(event) {
      var _a;
      isClickLikeOpenEvent() || dataRef.current.floatingContext && ((_a = handleCloseRef.current) == null || _a.call(handleCloseRef, {
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event);
        }
      })(event));
    }
    function onFloatingMouseEnter() {
      timeout.clear();
    }
    function onFloatingMouseLeave(event) {
      isClickLikeOpenEvent() || closeWithDelay(event, !1);
    }
    if (isElement(elements.domReference)) {
      const reference2 = elements.domReference, floating = elements.floating;
      return open && reference2.addEventListener("mouseleave", onScrollMouseLeave), move && reference2.addEventListener("mousemove", onReferenceMouseEnter, {
        once: !0
      }), reference2.addEventListener("mouseenter", onReferenceMouseEnter), reference2.addEventListener("mouseleave", onReferenceMouseLeave), floating && (floating.addEventListener("mouseleave", onScrollMouseLeave), floating.addEventListener("mouseenter", onFloatingMouseEnter), floating.addEventListener("mouseleave", onFloatingMouseLeave)), () => {
        open && reference2.removeEventListener("mouseleave", onScrollMouseLeave), move && reference2.removeEventListener("mousemove", onReferenceMouseEnter), reference2.removeEventListener("mouseenter", onReferenceMouseEnter), reference2.removeEventListener("mouseleave", onReferenceMouseLeave), floating && (floating.removeEventListener("mouseleave", onScrollMouseLeave), floating.removeEventListener("mouseenter", onFloatingMouseEnter), floating.removeEventListener("mouseleave", onFloatingMouseLeave));
      };
    }
  }, [elements, enabled, context, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef, timeout, restTimeout]), useIsoLayoutEffect(() => {
    var _a, _b, _c, _d;
    if (enabled && open && (_b = (_a = handleCloseRef.current) == null ? void 0 : _a.__options) != null && _b.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = !0;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference, parentFloating = (_d = (_c = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === parentId)) == null ? void 0 : _c.context) == null ? void 0 : _d.elements.floating;
        return parentFloating && (parentFloating.style.pointerEvents = ""), body.style.pointerEvents = "none", ref.style.pointerEvents = "auto", floatingEl.style.pointerEvents = "auto", () => {
          body.style.pointerEvents = "", ref.style.pointerEvents = "", floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]), useIsoLayoutEffect(() => {
    open || (pointerTypeRef.current = void 0, restTimeoutPendingRef.current = !1, cleanupMouseMoveHandler(), clearPointerEvents());
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]), React.useEffect(() => () => {
    cleanupMouseMoveHandler(), timeout.clear(), restTimeout.clear(), clearPointerEvents();
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents, timeout, restTimeout]);
  const reference = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          !blockMouseMoveRef.current && !openRef.current && onOpenChange(!0, nativeEvent, "hover");
        }
        mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || open || getRestMs(restMsRef.current) === 0 || restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2 || (restTimeout.clear(), pointerTypeRef.current === "touch" ? handleMouseMove() : (restTimeoutPendingRef.current = !0, restTimeout.start(getRestMs(restMsRef.current), handleMouseMove)));
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMsRef, restTimeout]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
var define_process_env_default$g = {};
const FloatingDelayGroupContext = /* @__PURE__ */ React.createContext({
  hasProvider: !1,
  timeoutMs: 0,
  delayRef: {
    current: 0
  },
  initialDelayRef: {
    current: 0
  },
  timeout: new Timeout(),
  currentIdRef: {
    current: null
  },
  currentContextRef: {
    current: null
  }
});
define_process_env_default$g.NODE_ENV !== "production" && (FloatingDelayGroupContext.displayName = "FloatingDelayGroupContext");
function FloatingDelayGroup(props) {
  const {
    children,
    delay,
    timeoutMs = 0
  } = props, delayRef = React.useRef(delay), initialDelayRef = React.useRef(delay), currentIdRef = React.useRef(null), currentContextRef = React.useRef(null), timeout = useTimeout();
  return /* @__PURE__ */ jsx(FloatingDelayGroupContext.Provider, {
    value: React.useMemo(() => ({
      hasProvider: !0,
      delayRef,
      initialDelayRef,
      currentIdRef,
      timeoutMs,
      currentContextRef,
      timeout
    }), [timeoutMs, timeout]),
    children
  });
}
function useDelayGroup(context, options = {}) {
  const {
    open,
    onOpenChange,
    floatingId
  } = context, {
    enabled = !0
  } = options, groupContext = React.useContext(FloatingDelayGroupContext), {
    currentIdRef,
    delayRef,
    timeoutMs,
    initialDelayRef,
    currentContextRef,
    hasProvider,
    timeout
  } = groupContext, [isInstantPhase, setIsInstantPhase] = React.useState(!1);
  return useIsoLayoutEffect(() => {
    function unset() {
      var _a;
      setIsInstantPhase(!1), (_a = currentContextRef.current) == null || _a.setIsInstantPhase(!1), currentIdRef.current = null, currentContextRef.current = null, delayRef.current = initialDelayRef.current;
    }
    if (enabled && currentIdRef.current && !open && currentIdRef.current === floatingId) {
      if (setIsInstantPhase(!1), timeoutMs)
        return timeout.start(timeoutMs, unset), () => {
          timeout.clear();
        };
      unset();
    }
  }, [enabled, open, floatingId, currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, timeout]), useIsoLayoutEffect(() => {
    if (!enabled || !open)
      return;
    const prevContext = currentContextRef.current, prevId = currentIdRef.current;
    currentContextRef.current = {
      onOpenChange,
      setIsInstantPhase
    }, currentIdRef.current = floatingId, delayRef.current = {
      open: 0,
      close: getDelay(initialDelayRef.current, "close")
    }, prevId !== null && prevId !== floatingId ? (timeout.clear(), setIsInstantPhase(!0), prevContext == null || prevContext.setIsInstantPhase(!0), prevContext == null || prevContext.onOpenChange(!1)) : (setIsInstantPhase(!1), prevContext == null || prevContext.setIsInstantPhase(!1));
  }, [enabled, open, floatingId, onOpenChange, currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, timeout]), useIsoLayoutEffect(() => () => {
    currentContextRef.current = null;
  }, [currentContextRef]), React.useMemo(() => ({
    hasProvider,
    delayRef,
    isInstantPhase
  }), [hasProvider, delayRef, isInstantPhase]);
}
function useMergedRefs(a3, b2, c2, d2) {
  const forkRef = useRefWithInit(createForkRef).current;
  return didChange(forkRef, a3, b2, c2, d2) && update(forkRef, [a3, b2, c2, d2]), forkRef.callback;
}
function useMergedRefsN(refs) {
  const forkRef = useRefWithInit(createForkRef).current;
  return didChangeN(forkRef, refs) && update(forkRef, refs), forkRef.callback;
}
function createForkRef() {
  return {
    callback: null,
    cleanup: null,
    refs: []
  };
}
function didChange(forkRef, a3, b2, c2, d2) {
  return forkRef.refs[0] !== a3 || forkRef.refs[1] !== b2 || forkRef.refs[2] !== c2 || forkRef.refs[3] !== d2;
}
function didChangeN(forkRef, newRefs) {
  return forkRef.refs.length !== newRefs.length || forkRef.refs.some((ref, index2) => ref !== newRefs[index2]);
}
function update(forkRef, refs) {
  if (forkRef.refs = refs, refs.every((ref) => ref == null)) {
    forkRef.callback = null;
    return;
  }
  forkRef.callback = (instance) => {
    if (forkRef.cleanup && (forkRef.cleanup(), forkRef.cleanup = null), instance != null) {
      const cleanupCallbacks = Array(refs.length).fill(null);
      for (let i2 = 0; i2 < refs.length; i2 += 1) {
        const ref = refs[i2];
        if (ref != null)
          switch (typeof ref) {
            case "function": {
              const refCleanup = ref(instance);
              typeof refCleanup == "function" && (cleanupCallbacks[i2] = refCleanup);
              break;
            }
            case "object": {
              ref.current = instance;
              break;
            }
          }
      }
      forkRef.cleanup = () => {
        for (let i2 = 0; i2 < refs.length; i2 += 1) {
          const ref = refs[i2];
          if (ref != null)
            switch (typeof ref) {
              case "function": {
                const cleanupCallback = cleanupCallbacks[i2];
                typeof cleanupCallback == "function" ? cleanupCallback() : ref(null);
                break;
              }
              case "object": {
                ref.current = null;
                break;
              }
            }
        }
      };
    }
  };
}
var define_process_env_default$f = {};
const PortalContext = /* @__PURE__ */ React.createContext(null);
define_process_env_default$f.NODE_ENV !== "production" && (PortalContext.displayName = "PortalContext");
const usePortalContext = () => React.useContext(PortalContext), attr = createAttribute("portal");
function useFloatingPortalNode(props = {}) {
  const {
    id,
    root: root2
  } = props, uniqueId = useId$1(), portalContext = usePortalContext(), [portalNode, setPortalNode] = React.useState(null), portalNodeRef = React.useRef(null);
  return useIsoLayoutEffect(() => () => {
    portalNode == null || portalNode.remove(), queueMicrotask(() => {
      portalNodeRef.current = null;
    });
  }, [portalNode]), useIsoLayoutEffect(() => {
    if (!uniqueId || portalNodeRef.current)
      return;
    const existingIdRoot = id ? document.getElementById(id) : null;
    if (!existingIdRoot)
      return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId, subRoot.setAttribute(attr, ""), existingIdRoot.appendChild(subRoot), portalNodeRef.current = subRoot, setPortalNode(subRoot);
  }, [id, uniqueId]), useIsoLayoutEffect(() => {
    if (root2 === null || !uniqueId || portalNodeRef.current)
      return;
    let container = root2 || (portalContext == null ? void 0 : portalContext.portalNode);
    container && !isNode(container) && (container = container.current), container = container || document.body;
    let idWrapper = null;
    id && (idWrapper = document.createElement("div"), idWrapper.id = id, container.appendChild(idWrapper));
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId, subRoot.setAttribute(attr, ""), container = idWrapper || container, container.appendChild(subRoot), portalNodeRef.current = subRoot, setPortalNode(subRoot);
  }, [id, root2, uniqueId, portalContext]), portalNode;
}
const DISABLED_TRANSITIONS_STYLE = {
  style: {
    transition: "none"
  }
}, EMPTY_OBJECT = {}, POPUP_COLLISION_AVOIDANCE = {
  fallbackAxisSide: "end"
};
var define_process_env_default$e = {};
const EMPTY$1 = null;
let LAST_RAF = globalThis.requestAnimationFrame;
class Scheduler {
  constructor() {
    /* This implementation uses an array as a backing data-structure for frame callbacks.
     * It allows `O(1)` callback cancelling by inserting a `null` in the array, though it
     * never calls the native `cancelAnimationFrame` if there are no frames left. This can
     * be much more efficient if there is a call pattern that alterns as
     * "request-cancel-request-cancel-".
     * But in the case of "request-request--cancel-cancel-", it leaves the final animation
     * frame to run anyway. We turn that frame into a `O(1)` no-op via `callbacksCount`. */
    __publicField(this, "callbacks", []);
    __publicField(this, "callbacksCount", 0);
    __publicField(this, "nextId", 1);
    __publicField(this, "startId", 1);
    __publicField(this, "isScheduled", !1);
    __publicField(this, "tick", (timestamp) => {
      var _a;
      this.isScheduled = !1;
      const currentCallbacks = this.callbacks, currentCallbacksCount = this.callbacksCount;
      if (this.callbacks = [], this.callbacksCount = 0, this.startId = this.nextId, currentCallbacksCount > 0)
        for (let i2 = 0; i2 < currentCallbacks.length; i2 += 1)
          (_a = currentCallbacks[i2]) == null || _a.call(currentCallbacks, timestamp);
    });
  }
  request(fn) {
    const id = this.nextId;
    this.nextId += 1, this.callbacks.push(fn), this.callbacksCount += 1;
    const didRAFChange = define_process_env_default$e.NODE_ENV === "test" && LAST_RAF !== requestAnimationFrame && (LAST_RAF = requestAnimationFrame, !0);
    return (!this.isScheduled || didRAFChange) && (requestAnimationFrame(this.tick), this.isScheduled = !0), id;
  }
  cancel(id) {
    const index2 = id - this.startId;
    index2 < 0 || index2 >= this.callbacks.length || (this.callbacks[index2] = null, this.callbacksCount -= 1);
  }
}
const scheduler = new Scheduler();
class AnimationFrame {
  constructor() {
    __publicField(this, "currentId", EMPTY$1);
    __publicField(this, "cancel", () => {
      this.currentId !== EMPTY$1 && (scheduler.cancel(this.currentId), this.currentId = EMPTY$1);
    });
    __publicField(this, "disposeEffect", () => this.cancel);
  }
  static create() {
    return new AnimationFrame();
  }
  static request(fn) {
    return scheduler.request(fn);
  }
  static cancel(id) {
    return scheduler.cancel(id);
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  request(fn) {
    this.cancel(), this.currentId = scheduler.request(() => {
      this.currentId = EMPTY$1, fn();
    });
  }
}
function useAnimationFrame() {
  const timeout = useRefWithInit(AnimationFrame.create).current;
  return useOnMount(timeout.disposeEffect), timeout;
}
function createVirtualElement(domElement, data) {
  let offsetX = null, offsetY = null, isAutoUpdateEvent = !1;
  return {
    contextElement: domElement || void 0,
    getBoundingClientRect() {
      var _a;
      const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      }, isXAxis = data.axis === "x" || data.axis === "both", isYAxis = data.axis === "y" || data.axis === "both", canTrackCursorOnAutoUpdate = ["mouseenter", "mousemove"].includes(((_a = data.dataRef.current.openEvent) == null ? void 0 : _a.type) || "") && data.pointerType !== "touch";
      let width = domRect.width, height = domRect.height, x2 = domRect.x, y2 = domRect.y;
      return offsetX == null && data.x && isXAxis && (offsetX = domRect.x - data.x), offsetY == null && data.y && isYAxis && (offsetY = domRect.y - data.y), x2 -= offsetX || 0, y2 -= offsetY || 0, width = 0, height = 0, !isAutoUpdateEvent || canTrackCursorOnAutoUpdate ? (width = data.axis === "y" ? domRect.width : 0, height = data.axis === "x" ? domRect.height : 0, x2 = isXAxis && data.x != null ? data.x : x2, y2 = isYAxis && data.y != null ? data.y : y2) : isAutoUpdateEvent && !canTrackCursorOnAutoUpdate && (height = data.axis === "x" ? domRect.height : height, width = data.axis === "y" ? domRect.width : width), isAutoUpdateEvent = !0, {
        width,
        height,
        x: x2,
        y: y2,
        top: y2,
        right: x2 + width,
        bottom: y2 + height,
        left: x2
      };
    }
  };
}
function isMouseBasedEvent(event) {
  return event != null && event.clientX != null;
}
function useClientPoint(context, props = {}) {
  const {
    open,
    dataRef,
    elements: {
      floating,
      domReference
    },
    refs
  } = context, {
    enabled = !0,
    axis = "both",
    x: x2 = null,
    y: y2 = null
  } = props, initialRef = React.useRef(!1), cleanupListenerRef = React.useRef(null), [pointerType, setPointerType] = React.useState(), [reactive, setReactive] = React.useState([]), setReference = useEventCallback((newX, newY) => {
    initialRef.current || dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent) || refs.setPositionReference(createVirtualElement(domReference, {
      x: newX,
      y: newY,
      axis,
      dataRef,
      pointerType
    }));
  }), handleReferenceEnterOrMove = useEventCallback((event) => {
    x2 != null || y2 != null || (open ? cleanupListenerRef.current || setReactive([]) : setReference(event.clientX, event.clientY));
  }), openCheck = isMouseLikePointerType(pointerType) ? floating : open, addListener = React.useCallback(() => {
    if (!openCheck || !enabled || x2 != null || y2 != null)
      return;
    const win = getWindow(floating);
    function handleMouseMove(event) {
      const target = getTarget(event);
      contains(floating, target) ? (win.removeEventListener("mousemove", handleMouseMove), cleanupListenerRef.current = null) : setReference(event.clientX, event.clientY);
    }
    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {
      win.addEventListener("mousemove", handleMouseMove);
      const cleanup = () => {
        win.removeEventListener("mousemove", handleMouseMove), cleanupListenerRef.current = null;
      };
      return cleanupListenerRef.current = cleanup, cleanup;
    }
    refs.setPositionReference(domReference);
  }, [openCheck, enabled, x2, y2, floating, dataRef, refs, domReference, setReference]);
  React.useEffect(() => addListener(), [addListener, reactive]), React.useEffect(() => {
    enabled && !floating && (initialRef.current = !1);
  }, [enabled, floating]), React.useEffect(() => {
    !enabled && open && (initialRef.current = !0);
  }, [enabled, open]), useIsoLayoutEffect(() => {
    enabled && (x2 != null || y2 != null) && (initialRef.current = !1, setReference(x2, y2));
  }, [enabled, x2, y2, setReference]);
  const reference = React.useMemo(() => {
    function setPointerTypeRef(event) {
      setPointerType(event.pointerType);
    }
    return {
      onPointerDown: setPointerTypeRef,
      onPointerEnter: setPointerTypeRef,
      onMouseMove: handleReferenceEnterOrMove,
      onMouseEnter: handleReferenceEnterOrMove
    };
  }, [handleReferenceEnterOrMove]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === "y", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2, validMiddleware = middleware.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  }), {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i2], {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX ?? x2, y2 = nextY ?? y2, middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    }, reset && resetCount <= 50 && (resetCount++, typeof reset == "object" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({
      reference,
      floating,
      strategy
    }) : reset.rects), {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i2 = -1);
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  options === void 0 && (options = {});
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state, {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = !1,
    padding = 0
  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element2 = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) == null || _await$platform$isEle ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  })), rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const flip$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)
        return {};
      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      const placements = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow$1(state, detectOverflowOptions), overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      if (overflowsData = [...overflowsData, {
        placement,
        overflows
      }], !overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements[nextIndex];
        if (nextPlacement && (!(checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        overflowsData.every((d2) => getSideAxis(d2.placement) === initialSideAxis ? d2.overflows[0] > 0 : !0)))
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a3, b2) => a3.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement)
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return !0;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              placement2 && (resetPlacement = placement2);
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        if (placement !== resetPlacement)
          return {
            reset: {
              placement: resetPlacement
            }
          };
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state, {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          }), offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            altBoundary: !0
          }), offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === "y", mainAxisMulti = originSides.has(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue == "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  return alignment && typeof alignmentAxis == "number" && (crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  return options === void 0 && (options = 0), {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state, diffCoords = await convertValueToCoords(state, options);
      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, shift$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !1,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, overflow = await detectOverflow$1(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left", maxSide = mainAxis === "y" ? "bottom" : "right", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left", maxSide = crossAxis === "y" ? "bottom" : "right", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
}, limitShift$2 = function(options) {
  return options === void 0 && (options = {}), {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state, {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state), computedOffset = typeof rawOffset == "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width", limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis, limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > limitMax && (mainAxisCoord = limitMax);
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height", isOriginSide = originSides.has(getSide(placement)), limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide && ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0) + (isOriginSide ? 0 : computedOffset.crossAxis), limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        crossAxisCoord < limitMin ? crossAxisCoord = limitMin : crossAxisCoord > limitMax && (crossAxisCoord = limitMax);
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
}, size$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state, {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state), overflow = await detectOverflow$1(state, detectOverflowOptions), side = getSide(placement), alignment = getAlignment(placement), isYAxis = getSideAxis(placement) === "y", {
        width,
        height
      } = rects.floating;
      let heightSide, widthSide;
      side === "top" || side === "bottom" ? (heightSide = side, widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right") : (widthSide = side, heightSide = alignment === "end" ? "top" : "bottom");
      const maximumClippingHeight = height - overflow.top - overflow.bottom, maximumClippingWidth = width - overflow.left - overflow.right, overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight), overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth), noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight, availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x && (availableWidth = maximumClippingWidth), (_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y && (availableHeight = maximumClippingHeight), noShift && !alignment) {
        const xMin = max(overflow.left, 0), xMax = max(overflow.right, 0), yMin = max(overflow.top, 0), yMax = max(overflow.bottom, 0);
        isYAxis ? availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      return width !== nextDimensions.width || height !== nextDimensions.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(element2) {
  const css = getComputedStyle$1(element2);
  let width = parseFloat(css.width) || 0, height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element2), offsetWidth = hasOffset ? element2.offsetWidth : width, offsetHeight = hasOffset ? element2.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return isElement(element2) ? element2 : element2.contextElement;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width, y2 = ($2 ? round(rect.height) : rect.height) / height;
  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  return !isWebKit() || !win.visualViewport ? noOffsets : {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2) ? !1 : isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element2.getBoundingClientRect(), domElement = unwrapElement(element2);
  let scale = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element2));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x, y2 = (clientRect.top + visualOffsets.y) / scale.y, width = clientRect.width / scale.x, height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win, currentIFrame = getFrameElement(currentWin);
    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css = getComputedStyle$1(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x2 += left, y2 += top, currentWin = getWindow(currentIFrame), currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element2, rect) {
  const leftScroll = getNodeScroll(element2).scrollLeft;
  return rect ? rect.left + leftScroll : getBoundingClientRect(getDocumentElement(element2)).left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  ignoreScrollbarX === void 0 && (ignoreScrollbarX = !1);
  const htmlRect = documentElement.getBoundingClientRect(), x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  )), y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;
  if (offsetParent === documentElement || topLayer && isFixed)
    return rect;
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  }, scale = createCoords(1);
  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement(offsetParent);
  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent))) {
    const offsetRect = getBoundingClientRect(offsetParent);
    scale = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, !0) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getDocumentRect(element2) {
  const html2 = getDocumentElement(element2), scroll = getNodeScroll(element2), body = element2.ownerDocument.body, width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth), height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y2 = -scroll.scrollTop;
  return getComputedStyle$1(body).direction === "rtl" && (x2 += max(html2.clientWidth, body.clientWidth) - width), {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow(element2), html2 = getDocumentElement(element2), visualViewport = win.visualViewport;
  let width = html2.clientWidth, height = html2.clientHeight, x2 = 0, y2 = 0;
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height;
    const visualViewportBased = isWebKit();
    (!visualViewportBased || visualViewportBased && strategy === "fixed") && (x2 = visualViewport.offsetLeft, y2 = visualViewport.offsetTop);
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, !0, strategy === "fixed"), top = clientRect.top + element2.clientTop, left = clientRect.left + element2.clientLeft, scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1), width = element2.clientWidth * scale.x, height = element2.clientHeight * scale.y, x2 = left * scale.x, y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport")
    rect = getViewportRect(element2, strategy);
  else if (clippingAncestor === "document")
    rect = getDocumentRect(getDocumentElement(element2));
  else if (isElement(clippingAncestor))
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache) {
  const cachedResult = cache.get(element2);
  if (cachedResult)
    return cachedResult;
  let result = getOverflowAncestors(element2, [], !1).filter((el) => isElement(el) && getNodeName(el) !== "body"), currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  for (; isElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    const computedStyle = getComputedStyle$1(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
    !currentNodeIsContaining && computedStyle.position === "fixed" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);
  }
  return cache.set(element2, result), result;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element2) ? [] : getClippingElementAncestors(element2, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    return accRect.top = max(rect.top, accRect.top), accRect.right = min(rect.right, accRect.right), accRect.bottom = min(rect.bottom, accRect.bottom), accRect.left = max(rect.left, accRect.left), accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  const {
    width,
    height
  } = getCssDimensions(element2);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === "fixed", rect = getBoundingClientRect(element2, !0, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    if ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
    } else documentElement && setLeftRTLScrollbarOffset();
  isFixed && !isOffsetParentAnElement && documentElement && setLeftRTLScrollbarOffset();
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0), x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x, y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element2) {
  return getComputedStyle$1(element2).position === "static";
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement(element2) || getComputedStyle$1(element2).position === "fixed")
    return null;
  if (polyfill)
    return polyfill(element2);
  let rawOffsetParent = element2.offsetParent;
  return getDocumentElement(element2) === rawOffsetParent && (rawOffsetParent = rawOffsetParent.ownerDocument.body), rawOffsetParent;
}
function getOffsetParent(element2, polyfill) {
  const win = getWindow(element2);
  if (isTopLayer(element2))
    return win;
  if (!isHTMLElement(element2)) {
    let svgOffsetParent = getParentNode(element2);
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))
        return svgOffsetParent;
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win : offsetParent || getContainingBlock(element2) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element2) {
  return getComputedStyle$1(element2).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a3, b2) {
  return a3.x === b2.x && a3.y === b2.y && a3.width === b2.width && a3.height === b2.height;
}
function observeMove(element2, onMove) {
  let io = null, timeoutId;
  const root2 = getDocumentElement(element2);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const elementRectForRootMargin = element2.getBoundingClientRect(), {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root2.clientWidth - (left + width)), insetBottom = floor(root2.clientHeight - (top + height)), insetLeft = floor(left), options = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 1e3);
      }
      ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element2.getBoundingClientRect()) && refresh(), isFirstUpdate = !1;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element2);
  }
  return refresh(!0), cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  options === void 0 && (options = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref) => {
    let [firstEntry] = _ref;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
    })), update2();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect) && update2(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return update2(), () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2), ancestorResize && ancestor.removeEventListener("resize", update2);
    }), cleanupIo == null || cleanupIo(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
const detectOverflow = detectOverflow$1, offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, hide$1 = hide$2, limitShift$1 = limitShift$2, computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map(), mergedOptions = {
    platform,
    ...options
  }, platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document < "u", noop = function() {
}, index$2 = isClient ? useLayoutEffect : noop;
function deepEqual(a3, b2) {
  if (a3 === b2)
    return !0;
  if (typeof a3 != typeof b2)
    return !1;
  if (typeof a3 == "function" && a3.toString() === b2.toString())
    return !0;
  let length, i2, keys2;
  if (a3 && b2 && typeof a3 == "object") {
    if (Array.isArray(a3)) {
      if (length = a3.length, length !== b2.length) return !1;
      for (i2 = length; i2-- !== 0; )
        if (!deepEqual(a3[i2], b2[i2]))
          return !1;
      return !0;
    }
    if (keys2 = Object.keys(a3), length = keys2.length, length !== Object.keys(b2).length)
      return !1;
    for (i2 = length; i2-- !== 0; )
      if (!{}.hasOwnProperty.call(b2, keys2[i2]))
        return !1;
    for (i2 = length; i2-- !== 0; ) {
      const key = keys2[i2];
      if (!(key === "_owner" && a3.$$typeof) && !deepEqual(a3[key], b2[key]))
        return !1;
    }
    return !0;
  }
  return a3 !== a3 && b2 !== b2;
}
function getDPR(element2) {
  return typeof window > "u" ? 1 : (element2.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element2, value) {
  const dpr = getDPR(element2);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  return index$2(() => {
    ref.current = value;
  }), ref;
}
function useFloating$2(options) {
  options === void 0 && (options = {});
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = !0,
    whileElementsMounted,
    open
  } = options, [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: !1
  }), [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  deepEqual(latestMiddleware, middleware) || setLatestMiddleware(middleware);
  const [_reference, _setReference] = React.useState(null), [_floating, _setFloating] = React.useState(null), setReference = React.useCallback((node2) => {
    node2 !== referenceRef.current && (referenceRef.current = node2, _setReference(node2));
  }, []), setFloating = React.useCallback((node2) => {
    node2 !== floatingRef.current && (floatingRef.current = node2, _setFloating(node2));
  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React.useRef(null), floatingRef = React.useRef(null), dataRef = React.useRef(data), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef(whileElementsMounted), platformRef = useLatestRef(platform2), openRef = useLatestRef(open), update2 = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current)
      return;
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    platformRef.current && (config2.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== !1
      };
      isMountedRef.current && !deepEqual(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {
        setData(fullData);
      }));
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$2(() => {
    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData((data2) => ({
      ...data2,
      isPositioned: !1
    })));
  }, [open]);
  const isMountedRef = React.useRef(!1);
  index$2(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), index$2(() => {
    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {
      if (whileElementsMountedRef.current)
        return whileElementsMountedRef.current(referenceEl, floatingEl, update2);
      update2();
    }
  }, [referenceEl, floatingEl, update2, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]), elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]), floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating)
      return initialStyles;
    const x2 = roundByDPR(elements.floating, data.x), y2 = roundByDPR(elements.floating, data.y);
    return transform ? {
      ...initialStyles,
      transform: "translate(" + x2 + "px, " + y2 + "px)",
      ...getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update: update2,
    refs,
    elements,
    floatingStyles
  }), [data, update2, refs, elements, floatingStyles]);
}
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
}), shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
}), flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
}), hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
}), bubbleHandlerKeys = {
  intentional: "onClick",
  sloppy: "onPointerDown"
};
function normalizeProp(normalizable) {
  return {
    escapeKey: typeof normalizable == "boolean" ? normalizable : (normalizable == null ? void 0 : normalizable.escapeKey) ?? !1,
    outsidePress: typeof normalizable == "boolean" ? normalizable : (normalizable == null ? void 0 : normalizable.outsidePress) ?? !0
  };
}
function useDismiss(context, props = {}) {
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context, {
    enabled = !0,
    escapeKey = !0,
    outsidePress: outsidePressProp = !0,
    outsidePressEvent = "sloppy",
    referencePress = !1,
    referencePressEvent = "sloppy",
    ancestorScroll = !1,
    bubbles,
    capture
  } = props, tree = useFloatingTree$1(), outsidePressFn = useEventCallback(typeof outsidePressProp == "function" ? outsidePressProp : () => !1), outsidePress = typeof outsidePressProp == "function" ? outsidePressFn : outsidePressProp, endedOrStartedInsideRef = React.useRef(!1), {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles), {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture), touchStateRef = React.useRef(null), cancelDismissOnEndTimeout = useTimeout(), insideReactTreeTimeout = useTimeout(), isComposingRef = React.useRef(!1), currentPointerTypeRef = React.useRef(""), trackPointerType = useEventCallback((event) => {
    currentPointerTypeRef.current = event.pointerType;
  }), getOutsidePressEvent = useEventCallback(() => {
    const type = currentPointerTypeRef.current, computedType = type === "pen" || !type ? "mouse" : type;
    return typeof outsidePressEvent == "string" ? outsidePressEvent : outsidePressEvent[computedType];
  }), closeOnEscapeKeyDown = useEventCallback((event) => {
    var _a;
    if (!open || !enabled || !escapeKey || event.key !== "Escape" || isComposingRef.current)
      return;
    const nodeId = (_a = dataRef.current.floatingContext) == null ? void 0 : _a.nodeId, children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles && (event.stopPropagation(), children.length > 0)) {
      let shouldDismiss = !0;
      if (children.forEach((child) => {
        var _a2;
        (_a2 = child.context) != null && _a2.open && !child.context.dataRef.current.__escapeKeyBubbles && (shouldDismiss = !1);
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  }), shouldIgnoreEvent = useEventCallback((event) => {
    const computedOutsidePressEvent = getOutsidePressEvent();
    return computedOutsidePressEvent === "intentional" && event.type !== "click" || computedOutsidePressEvent === "sloppy" && event.type === "click";
  }), closeOnEscapeKeyDownCapture = useEventCallback((event) => {
    var _a;
    const callback = () => {
      var _a2;
      closeOnEscapeKeyDown(event), (_a2 = getTarget(event)) == null || _a2.removeEventListener("keydown", callback);
    };
    (_a = getTarget(event)) == null || _a.addEventListener("keydown", callback);
  }), closeOnPressOutside = useEventCallback((event) => {
    var _a;
    if (shouldIgnoreEvent(event))
      return;
    const insideReactTree = dataRef.current.insideReactTree;
    dataRef.current.insideReactTree = !1;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    if (endedOrStartedInsideRef.current = !1, getOutsidePressEvent() === "intentional" && endedOrStartedInside || insideReactTree || typeof outsidePress == "function" && !outsidePress(event))
      return;
    const target = getTarget(event), inertSelector = `[${createAttribute("inert")}]`, markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    for (; targetRootAncestor && !isLastTraversableNode(targetRootAncestor); ) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent))
        break;
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker)))
      return;
    if (isHTMLElement(target)) {
      const lastTraversableNode = isLastTraversableNode(target), style = getComputedStyle$1(target), scrollRe = /auto|scroll/, isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX), isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY), canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth, canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight, isRTL2 = style.direction === "rtl", pressedVerticalScrollbar = canScrollY && (isRTL2 ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth), pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
      if (pressedVerticalScrollbar || pressedHorizontalScrollbar)
        return;
    }
    const nodeId = (_a = dataRef.current.floatingContext) == null ? void 0 : _a.nodeId, targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some((node2) => {
      var _a2;
      return isEventTargetWithin(event, (_a2 = node2.context) == null ? void 0 : _a2.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren)
      return;
    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = !0;
      if (children.forEach((child) => {
        var _a2;
        (_a2 = child.context) != null && _a2.open && !child.context.dataRef.current.__outsidePressBubbles && (shouldDismiss = !1);
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, event, "outside-press");
  }), handlePointerDown = useEventCallback((event) => {
    if (!(getOutsidePressEvent() !== "sloppy" || !open || !enabled || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference))) {
      if (event.pointerType === "touch") {
        touchStateRef.current = {
          startTime: Date.now(),
          startX: event.clientX,
          startY: event.clientY,
          dismissOnPointerUp: !1,
          dismissOnMouseDown: !0
        }, cancelDismissOnEndTimeout.start(1e3, () => {
          touchStateRef.current && (touchStateRef.current.dismissOnPointerUp = !1, touchStateRef.current.dismissOnMouseDown = !1);
        });
        return;
      }
      closeOnPressOutside(event);
    }
  }), closeOnPressOutsideCapture = useEventCallback((event) => {
    var _a;
    if (shouldIgnoreEvent(event) || (cancelDismissOnEndTimeout.clear(), event.type === "mousedown" && touchStateRef.current && !touchStateRef.current.dismissOnMouseDown))
      return;
    const callback = () => {
      var _a2;
      event.type === "pointerdown" ? handlePointerDown(event) : closeOnPressOutside(event), (_a2 = getTarget(event)) == null || _a2.removeEventListener(event.type, callback);
    };
    (_a = getTarget(event)) == null || _a.addEventListener(event.type, callback);
  }), handlePointerMove = useEventCallback((event) => {
    if (getOutsidePressEvent() !== "sloppy" || event.pointerType !== "touch" || !touchStateRef.current || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference))
      return;
    const deltaX = Math.abs(event.clientX - touchStateRef.current.startX), deltaY = Math.abs(event.clientY - touchStateRef.current.startY), distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    distance > 5 && (touchStateRef.current.dismissOnPointerUp = !0), distance > 10 && (closeOnPressOutside(event), cancelDismissOnEndTimeout.clear(), touchStateRef.current = null);
  }), handlePointerUp = useEventCallback((event) => {
    getOutsidePressEvent() !== "sloppy" || event.pointerType !== "touch" || !touchStateRef.current || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || (touchStateRef.current.dismissOnPointerUp && closeOnPressOutside(event), cancelDismissOnEndTimeout.clear(), touchStateRef.current = null);
  });
  React.useEffect(() => {
    if (!open || !enabled)
      return;
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles, dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    const compositionTimeout = new Timeout();
    function onScroll(event) {
      onOpenChange(!1, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      compositionTimeout.clear(), isComposingRef.current = !0;
    }
    function handleCompositionEnd() {
      compositionTimeout.start(
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0,
        () => {
          isComposingRef.current = !1;
        }
      );
    }
    const doc = getDocument(elements.floating);
    doc.addEventListener("pointerdown", trackPointerType, !0), escapeKey && (doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.addEventListener("compositionstart", handleCompositionStart), doc.addEventListener("compositionend", handleCompositionEnd)), outsidePress && (doc.addEventListener("click", outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), doc.addEventListener("pointerdown", outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), doc.addEventListener("pointermove", handlePointerMove, outsidePressCapture), doc.addEventListener("pointerup", handlePointerUp, outsidePressCapture), doc.addEventListener("mousedown", closeOnPressOutsideCapture, outsidePressCapture));
    let ancestors = [];
    return ancestorScroll && (isElement(elements.domReference) && (ancestors = getOverflowAncestors(elements.domReference)), isElement(elements.floating) && (ancestors = ancestors.concat(getOverflowAncestors(elements.floating))), !isElement(elements.reference) && elements.reference && elements.reference.contextElement && (ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement)))), ancestors = ancestors.filter((ancestor) => {
      var _a;
      return ancestor !== ((_a = doc.defaultView) == null ? void 0 : _a.visualViewport);
    }), ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: !0
      });
    }), () => {
      doc.removeEventListener("pointerdown", trackPointerType, !0), escapeKey && (doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.removeEventListener("compositionstart", handleCompositionStart), doc.removeEventListener("compositionend", handleCompositionEnd)), outsidePress && (doc.removeEventListener("click", outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), doc.removeEventListener("pointerdown", outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), doc.removeEventListener("pointermove", handlePointerMove, outsidePressCapture), doc.removeEventListener("pointerup", handlePointerUp, outsidePressCapture), doc.removeEventListener("mousedown", closeOnPressOutsideCapture, outsidePressCapture)), ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      }), compositionTimeout.clear();
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture, handlePointerDown, handlePointerMove, handlePointerUp, trackPointerType]), React.useEffect(() => {
    dataRef.current.insideReactTree = !1;
  }, [dataRef, outsidePress]);
  const reference = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    ...referencePress && {
      [bubbleHandlerKeys[referencePressEvent]]: (event) => {
        onOpenChange(!1, event.nativeEvent, "reference-press");
      },
      ...referencePressEvent !== "intentional" && {
        onClick(event) {
          onOpenChange(!1, event.nativeEvent, "reference-press");
        }
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]), handlePressedInside = useEventCallback((event) => {
    const target = getTarget(event.nativeEvent);
    contains(elements.floating, target) && (endedOrStartedInsideRef.current = !0);
  }), handleCaptureInside = useEventCallback(() => {
    dataRef.current.insideReactTree = !0, insideReactTreeTimeout.start(0, () => {
      dataRef.current.insideReactTree = !1;
    });
  }), floating = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown: handlePressedInside,
    onMouseUp: handlePressedInside,
    onPointerDownCapture: handleCaptureInside,
    onMouseDownCapture: handleCaptureInside,
    onClickCapture: handleCaptureInside
  }), [closeOnEscapeKeyDown, handlePressedInside, handleCaptureInside]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
var define_process_env_default$d = {};
function useFloatingRootContext$1(options) {
  const {
    open = !1,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options, floatingId = useId$1(), dataRef = React.useRef({}), [events] = React.useState(() => createEventEmitter()), nested = useFloatingParentNodeId$1() != null;
  if (define_process_env_default$d.NODE_ENV !== "production") {
    const optionDomReference = elementsProp.reference;
    optionDomReference && !isElement(optionDomReference) && console.error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEventCallback((newOpen, event, reason) => {
    dataRef.current.openEvent = newOpen ? event : void 0, events.emit("openchange", {
      open: newOpen,
      event,
      reason,
      nested
    }), onOpenChangeProp == null || onOpenChangeProp(newOpen, event, reason);
  }), refs = React.useMemo(() => ({
    setPositionReference
  }), []), elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating$1(options = {}) {
  const {
    nodeId
  } = options, internalRootContext = useFloatingRootContext$1({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [domReferenceState, setDomReference] = React.useState(null), [positionReference, setPositionReferenceRaw] = React.useState(null), domReference = (computedElements == null ? void 0 : computedElements.domReference) || domReferenceState, domReferenceRef = React.useRef(null), tree = useFloatingTree$1();
  useIsoLayoutEffect(() => {
    domReference && (domReferenceRef.current = domReference);
  }, [domReference]);
  const position2 = useFloating$2({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  }), setPositionReference = React.useCallback((node2) => {
    const computedPositionReference = isElement(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      getClientRects: () => node2.getClientRects(),
      contextElement: node2
    } : node2;
    setPositionReferenceRaw(computedPositionReference), position2.refs.setReference(computedPositionReference);
  }, [position2.refs]), setReference = React.useCallback((node2) => {
    (isElement(node2) || node2 === null) && (domReferenceRef.current = node2, setDomReference(node2)), (isElement(position2.refs.reference.current) || position2.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node2 !== null && !isElement(node2)) && position2.refs.setReference(node2);
  }, [position2.refs]), refs = React.useMemo(() => ({
    ...position2.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position2.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({
    ...position2.elements,
    domReference
  }), [position2.elements, domReference]), context = React.useMemo(() => ({
    ...position2,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position2, refs, elements, nodeId, rootContext]);
  return useIsoLayoutEffect(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node2 = tree == null ? void 0 : tree.nodesRef.current.find((n2) => n2.id === nodeId);
    node2 && (node2.context = context);
  }), React.useMemo(() => ({
    ...position2,
    context,
    refs,
    elements
  }), [position2, refs, elements, context]);
}
const isMacSafari = isMac && isSafari;
function useFocus(context, props = {}) {
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context, {
    enabled = !0,
    visibleOnly = !0
  } = props, blockFocusRef = React.useRef(!1), timeout = useTimeout(), keyboardModalityRef = React.useRef(!0);
  React.useEffect(() => {
    if (!enabled)
      return;
    const win = getWindow(elements.domReference);
    function onBlur() {
      !open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference)) && (blockFocusRef.current = !0);
    }
    function onKeyDown() {
      keyboardModalityRef.current = !0;
    }
    function onPointerDown() {
      keyboardModalityRef.current = !1;
    }
    return win.addEventListener("blur", onBlur), isMacSafari && (win.addEventListener("keydown", onKeyDown, !0), win.addEventListener("pointerdown", onPointerDown, !0)), () => {
      win.removeEventListener("blur", onBlur), isMacSafari && (win.removeEventListener("keydown", onKeyDown, !0), win.removeEventListener("pointerdown", onPointerDown, !0));
    };
  }, [elements.domReference, open, enabled]), React.useEffect(() => {
    if (!enabled)
      return;
    function onOpenChangeLocal({
      reason
    }) {
      (reason === "reference-press" || reason === "escape-key") && (blockFocusRef.current = !0);
    }
    return events.on("openchange", onOpenChangeLocal), () => {
      events.off("openchange", onOpenChangeLocal);
    };
  }, [events, enabled]);
  const reference = React.useMemo(() => ({
    onMouseLeave() {
      blockFocusRef.current = !1;
    },
    onFocus(event) {
      if (blockFocusRef.current)
        return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target)) {
        if (isMacSafari && !event.relatedTarget) {
          if (!keyboardModalityRef.current && !isTypeableElement(target))
            return;
        } else if (!matchesFocusVisible(target))
          return;
      }
      onOpenChange(!0, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = !1;
      const relatedTarget = event.relatedTarget, nativeEvent = event.nativeEvent, movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeout.start(0, () => {
        var _a;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        !relatedTarget && activeEl === elements.domReference || contains((_a = dataRef.current.floatingContext) == null ? void 0 : _a.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard || onOpenChange(!1, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly, timeout]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function useInteractions$1(propsList = []) {
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference), floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating), itemDeps = propsList.map((key) => key == null ? void 0 : key.item), getReferenceProps = React.useCallback(
    (userProps) => mergeProps$2(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  ), getFloatingProps = React.useCallback(
    (userProps) => mergeProps$2(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  ), getItemProps = React.useCallback(
    (userProps) => mergeProps$2(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function mergeProps$2(userProps, propsList, elementKey) {
  var _a;
  const eventHandlers = /* @__PURE__ */ new Map(), isItem = elementKey === "item", outputProps = {};
  elementKey === "floating" && (outputProps.tabIndex = -1, outputProps[FOCUSABLE_ATTRIBUTE$1] = "");
  for (const key in userProps)
    isItem && userProps && (key === ACTIVE_KEY$1 || key === SELECTED_KEY$1) || (outputProps[key] = userProps[key]);
  for (let i2 = 0; i2 < propsList.length; i2 += 1) {
    let props;
    const propsOrGetProps = (_a = propsList[i2]) == null ? void 0 : _a[elementKey];
    typeof propsOrGetProps == "function" ? props = userProps ? propsOrGetProps(userProps) : null : props = propsOrGetProps, props && mutablyMergeProps(outputProps, props, isItem, eventHandlers);
  }
  return mutablyMergeProps(outputProps, userProps, isItem, eventHandlers), outputProps;
}
function mutablyMergeProps(outputProps, props, isItem, eventHandlers) {
  var _a;
  for (const key in props) {
    const value = props[key];
    isItem && (key === ACTIVE_KEY$1 || key === SELECTED_KEY$1) || (key.startsWith("on") ? (eventHandlers.has(key) || eventHandlers.set(key, []), typeof value == "function" && ((_a = eventHandlers.get(key)) == null || _a.push(value), outputProps[key] = (...args) => {
      var _a2;
      return (_a2 = eventHandlers.get(key)) == null ? void 0 : _a2.map((fn) => fn(...args)).find((val) => val !== void 0);
    })) : outputProps[key] = value);
  }
}
function isPointInPolygon(point2, polygon) {
  const [x2, y2] = point2;
  let isInsideValue = !1;
  const length = polygon.length;
  for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
    const [xi, yi] = polygon[i2] || [0, 0], [xj, yj] = polygon[j2] || [0, 0];
    yi >= y2 != yj >= y2 && x2 <= (xj - xi) * (y2 - yi) / (yj - yi) + xi && (isInsideValue = !isInsideValue);
  }
  return isInsideValue;
}
function isInside(point2, rect) {
  return point2[0] >= rect.x && point2[0] <= rect.x + rect.width && point2[1] >= rect.y && point2[1] <= rect.y + rect.height;
}
function safePolygon(options = {}) {
  const {
    buffer = 0.5,
    blockPointerEvents = !1,
    requireIntent = !0
  } = options, timeout = new Timeout();
  let hasLanded = !1, lastX = null, lastY = null, lastCursorTime = typeof performance < "u" ? performance.now() : 0;
  function getCursorSpeed(x2, y2) {
    const currentTime = performance.now(), elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0)
      return lastX = x2, lastY = y2, lastCursorTime = currentTime, null;
    const deltaX = x2 - lastX, deltaY = y2 - lastY, speed = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / elapsedTime;
    return lastX = x2, lastY = y2, lastCursorTime = currentTime, speed;
  }
  const fn = ({
    x: x2,
    y: y2,
    placement,
    elements,
    onClose,
    nodeId,
    tree
  }) => function(event) {
    function close() {
      timeout.clear(), onClose();
    }
    if (timeout.clear(), !elements.domReference || !elements.floating || placement == null || x2 == null || y2 == null)
      return;
    const {
      clientX,
      clientY
    } = event, clientPoint = [clientX, clientY], target = getTarget(event), isLeave = event.type === "mouseleave", isOverFloatingEl = contains(elements.floating, target), isOverReferenceEl = contains(elements.domReference, target), refRect = elements.domReference.getBoundingClientRect(), rect = elements.floating.getBoundingClientRect(), side = placement.split("-")[0], cursorLeaveFromRight = x2 > rect.right - rect.width / 2, cursorLeaveFromBottom = y2 > rect.bottom - rect.height / 2, isOverReferenceRect = isInside(clientPoint, refRect), isFloatingWider = rect.width > refRect.width, isFloatingTaller = rect.height > refRect.height, left = (isFloatingWider ? refRect : rect).left, right = (isFloatingWider ? refRect : rect).right, top = (isFloatingTaller ? refRect : rect).top, bottom = (isFloatingTaller ? refRect : rect).bottom;
    if (isOverFloatingEl && (hasLanded = !0, !isLeave))
      return;
    if (isOverReferenceEl && (hasLanded = !1), isOverReferenceEl && !isLeave) {
      hasLanded = !0;
      return;
    }
    if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget) || tree && getNodeChildren(tree.nodesRef.current, nodeId).some(({
      context
    }) => context == null ? void 0 : context.open))
      return;
    if (side === "top" && y2 >= refRect.bottom - 1 || side === "bottom" && y2 <= refRect.top + 1 || side === "left" && x2 >= refRect.right - 1 || side === "right" && x2 <= refRect.left + 1)
      return close();
    let rectPoly = [];
    switch (side) {
      case "top":
        rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];
        break;
      case "bottom":
        rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];
        break;
      case "left":
        rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];
        break;
      case "right":
        rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];
        break;
    }
    function getPolygon([px, py]) {
      switch (side) {
        case "top": {
          const cursorPointOne = [isFloatingWider ? px + buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py + buffer + 1], cursorPointTwo = [isFloatingWider ? px - buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py + buffer + 1], commonPoints = [[rect.left, cursorLeaveFromRight || isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
          return [cursorPointOne, cursorPointTwo, ...commonPoints];
        }
        case "bottom": {
          const cursorPointOne = [isFloatingWider ? px + buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py - buffer], cursorPointTwo = [isFloatingWider ? px - buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py - buffer], commonPoints = [[rect.left, cursorLeaveFromRight || isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
          return [cursorPointOne, cursorPointTwo, ...commonPoints];
        }
        case "left": {
          const cursorPointOne = [px + buffer + 1, isFloatingTaller ? py + buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4], cursorPointTwo = [px + buffer + 1, isFloatingTaller ? py - buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];
          return [...[[cursorLeaveFromBottom || isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]], cursorPointOne, cursorPointTwo];
        }
        case "right": {
          const cursorPointOne = [px - buffer, isFloatingTaller ? py + buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4], cursorPointTwo = [px - buffer, isFloatingTaller ? py - buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4], commonPoints = [[cursorLeaveFromBottom || isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
          return [cursorPointOne, cursorPointTwo, ...commonPoints];
        }
        default:
          return [];
      }
    }
    if (!isPointInPolygon([clientX, clientY], rectPoly)) {
      if (hasLanded && !isOverReferenceRect)
        return close();
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        if (cursorSpeed !== null && cursorSpeed < 0.1)
          return close();
      }
      isPointInPolygon([clientX, clientY], getPolygon([x2, y2])) ? !hasLanded && requireIntent && timeout.start(40, close) : close();
    }
  };
  return fn.__options = {
    blockPointerEvents
  }, fn;
}
function useTransitionStatus(open, enableIdleState = !1, deferEndingState = !1) {
  const [transitionStatus, setTransitionStatus] = React.useState(open && enableIdleState ? "idle" : void 0), [mounted, setMounted] = React.useState(open);
  return open && !mounted && (setMounted(!0), setTransitionStatus("starting")), !open && mounted && transitionStatus !== "ending" && !deferEndingState && setTransitionStatus("ending"), !open && !mounted && transitionStatus === "ending" && setTransitionStatus(void 0), useIsoLayoutEffect(() => {
    if (!open && mounted && transitionStatus !== "ending" && deferEndingState) {
      const frame = AnimationFrame.request(() => {
        setTransitionStatus("ending");
      });
      return () => {
        AnimationFrame.cancel(frame);
      };
    }
  }, [open, mounted, transitionStatus, deferEndingState]), useIsoLayoutEffect(() => {
    if (!open || enableIdleState)
      return;
    const frame = AnimationFrame.request(() => {
      ReactDOM.flushSync(() => {
        setTransitionStatus(void 0);
      });
    });
    return () => {
      AnimationFrame.cancel(frame);
    };
  }, [enableIdleState, open]), useIsoLayoutEffect(() => {
    if (!open || !enableIdleState)
      return;
    open && mounted && transitionStatus !== "idle" && setTransitionStatus("starting");
    const frame = AnimationFrame.request(() => {
      setTransitionStatus("idle");
    });
    return () => {
      AnimationFrame.cancel(frame);
    };
  }, [enableIdleState, open, mounted, setTransitionStatus, transitionStatus]), React.useMemo(() => ({
    mounted,
    setMounted,
    transitionStatus
  }), [mounted, transitionStatus]);
}
const OPEN_DELAY = 600;
function translateOpenChangeReason(nativeReason) {
  if (nativeReason)
    return {
      // Identical mappings
      "focus-out": "focus-out",
      "escape-key": "escape-key",
      "outside-press": "outside-press",
      "list-navigation": "list-navigation",
      // New mappings
      click: "trigger-press",
      hover: "trigger-hover",
      focus: "trigger-focus",
      "reference-press": "trigger-press",
      "safe-polygon": "trigger-hover",
      "ancestor-scroll": void 0
      // Not supported
    }[nativeReason];
}
function useAnimationsFinished(elementOrRef, waitForNextTick = !1) {
  const frame = useAnimationFrame();
  return useEventCallback((fnToExecute, signal = null) => {
    if (frame.cancel(), elementOrRef == null)
      return;
    let element2;
    if ("current" in elementOrRef) {
      if (elementOrRef.current == null)
        return;
      element2 = elementOrRef.current;
    } else
      element2 = elementOrRef;
    typeof element2.getAnimations != "function" || globalThis.BASE_UI_ANIMATIONS_DISABLED ? fnToExecute() : frame.request(() => {
      function exec() {
        element2 && Promise.allSettled(element2.getAnimations().map((anim) => anim.finished)).then(() => {
          signal != null && signal.aborted || ReactDOM.flushSync(fnToExecute);
        });
      }
      waitForNextTick ? frame.request(exec) : exec();
    });
  });
}
function useOpenChangeComplete(parameters) {
  const {
    enabled = !0,
    open,
    ref,
    onComplete: onCompleteParam
  } = parameters, openRef = useLatestRef$1(open), onComplete = useEventCallback(onCompleteParam), runOnceAnimationsFinish = useAnimationsFinished(ref, open);
  React.useEffect(() => {
    enabled && runOnceAnimationsFinish(() => {
      open === openRef.current && onComplete();
    });
  }, [enabled, open, onComplete, runOnceAnimationsFinish, openRef]);
}
var define_process_env_default$c = {};
const TooltipProviderContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$c.NODE_ENV !== "production" && (TooltipProviderContext.displayName = "TooltipProviderContext");
function useTooltipProviderContext() {
  return React.useContext(TooltipProviderContext);
}
function TooltipRoot(props) {
  const {
    disabled = !1,
    defaultOpen = !1,
    onOpenChange,
    open: openProp,
    delay,
    closeDelay,
    hoverable = !0,
    trackCursorAxis = "none",
    actionsRef,
    onOpenChangeComplete
  } = props, delayWithDefault = delay ?? OPEN_DELAY, closeDelayWithDefault = closeDelay ?? 0, [triggerElement, setTriggerElement] = React.useState(null), [positionerElement, setPositionerElement] = React.useState(null), [instantTypeState, setInstantTypeState] = React.useState(), popupRef = React.useRef(null), [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Tooltip",
    state: "open"
  }), open = !disabled && openState;
  function setOpenUnwrapped(nextOpen, event, reason) {
    const isHover = reason === "trigger-hover", isFocusOpen = nextOpen && reason === "trigger-focus", isDismissClose = !nextOpen && (reason === "trigger-press" || reason === "escape-key");
    function changeState() {
      onOpenChange == null || onOpenChange(nextOpen, event, reason), setOpenState(nextOpen);
    }
    isHover ? ReactDOM.flushSync(changeState) : changeState(), isFocusOpen || isDismissClose ? setInstantTypeState(isFocusOpen ? "focus" : "dismiss") : reason === "trigger-hover" && setInstantTypeState(void 0);
  }
  const setOpen = useEventCallback(setOpenUnwrapped);
  openState && disabled && setOpenUnwrapped(!1, void 0, "disabled");
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open), handleUnmount = useEventCallback(() => {
    setMounted(!1), onOpenChangeComplete == null || onOpenChangeComplete(!1);
  });
  useOpenChangeComplete({
    enabled: !actionsRef,
    open,
    ref: popupRef,
    onComplete() {
      open || handleUnmount();
    }
  }), React.useImperativeHandle(actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  const floatingRootContext = useFloatingRootContext$1({
    elements: {
      reference: triggerElement,
      floating: positionerElement
    },
    open,
    onOpenChange(openValue, eventValue, reasonValue) {
      setOpen(openValue, eventValue, translateOpenChangeReason(reasonValue));
    }
  }), providerContext = useTooltipProviderContext(), {
    delayRef,
    isInstantPhase,
    hasProvider
  } = useDelayGroup(floatingRootContext), instantType = isInstantPhase ? "delay" : instantTypeState, hover = useHover(floatingRootContext, {
    enabled: !disabled,
    mouseOnly: !0,
    move: !1,
    handleClose: hoverable && trackCursorAxis !== "both" ? safePolygon() : null,
    restMs() {
      const providerDelay = providerContext == null ? void 0 : providerContext.delay, groupOpenValue = typeof delayRef.current == "object" ? delayRef.current.open : void 0;
      let computedRestMs = delayWithDefault;
      return hasProvider && (groupOpenValue !== 0 ? computedRestMs = delay ?? providerDelay ?? delayWithDefault : computedRestMs = 0), computedRestMs;
    },
    delay() {
      const closeValue = typeof delayRef.current == "object" ? delayRef.current.close : void 0;
      let computedCloseDelay = closeDelayWithDefault;
      return closeDelay == null && hasProvider && (computedCloseDelay = closeValue), {
        close: computedCloseDelay
      };
    }
  }), focus = useFocus(floatingRootContext, {
    enabled: !disabled
  }), dismiss = useDismiss(floatingRootContext, {
    enabled: !disabled,
    referencePress: !0
  }), clientPoint = useClientPoint(floatingRootContext, {
    enabled: !disabled && trackCursorAxis !== "none",
    axis: trackCursorAxis === "none" ? void 0 : trackCursorAxis
  }), {
    getReferenceProps,
    getFloatingProps
  } = useInteractions$1([hover, focus, dismiss, clientPoint]), tooltipRoot = React.useMemo(() => ({
    open,
    setOpen,
    mounted,
    setMounted,
    setTriggerElement,
    positionerElement,
    setPositionerElement,
    popupRef,
    triggerProps: getReferenceProps(),
    popupProps: getFloatingProps(),
    floatingRootContext,
    instantType,
    transitionStatus,
    onOpenChangeComplete
  }), [open, setOpen, mounted, setMounted, setTriggerElement, positionerElement, setPositionerElement, popupRef, getReferenceProps, getFloatingProps, floatingRootContext, instantType, transitionStatus, onOpenChangeComplete]), contextValue = React.useMemo(() => ({
    ...tooltipRoot,
    delay: delayWithDefault,
    closeDelay: closeDelayWithDefault,
    trackCursorAxis,
    hoverable
  }), [tooltipRoot, delayWithDefault, closeDelayWithDefault, trackCursorAxis, hoverable]);
  return /* @__PURE__ */ jsx(TooltipRootContext.Provider, {
    value: contextValue,
    children: props.children
  });
}
let TransitionStatusDataAttributes = /* @__PURE__ */ (function(TransitionStatusDataAttributes2) {
  return TransitionStatusDataAttributes2.startingStyle = "data-starting-style", TransitionStatusDataAttributes2.endingStyle = "data-ending-style", TransitionStatusDataAttributes2;
})({});
const STARTING_HOOK = {
  [TransitionStatusDataAttributes.startingStyle]: ""
}, ENDING_HOOK = {
  [TransitionStatusDataAttributes.endingStyle]: ""
}, transitionStatusMapping = {
  transitionStatus(value) {
    return value === "starting" ? STARTING_HOOK : value === "ending" ? ENDING_HOOK : null;
  }
};
let CommonPopupDataAttributes = (function(CommonPopupDataAttributes2) {
  return CommonPopupDataAttributes2.open = "data-open", CommonPopupDataAttributes2.closed = "data-closed", CommonPopupDataAttributes2[CommonPopupDataAttributes2.startingStyle = TransitionStatusDataAttributes.startingStyle] = "startingStyle", CommonPopupDataAttributes2[CommonPopupDataAttributes2.endingStyle = TransitionStatusDataAttributes.endingStyle] = "endingStyle", CommonPopupDataAttributes2.anchorHidden = "data-anchor-hidden", CommonPopupDataAttributes2;
})({}), CommonTriggerDataAttributes = /* @__PURE__ */ (function(CommonTriggerDataAttributes2) {
  return CommonTriggerDataAttributes2.popupOpen = "data-popup-open", CommonTriggerDataAttributes2.pressed = "data-pressed", CommonTriggerDataAttributes2;
})({});
const TRIGGER_HOOK = {
  [CommonTriggerDataAttributes.popupOpen]: ""
}, POPUP_OPEN_HOOK = {
  [CommonPopupDataAttributes.open]: ""
}, POPUP_CLOSED_HOOK = {
  [CommonPopupDataAttributes.closed]: ""
}, ANCHOR_HIDDEN_HOOK = {
  [CommonPopupDataAttributes.anchorHidden]: ""
}, triggerOpenStateMapping = {
  open(value) {
    return value ? TRIGGER_HOOK : null;
  }
}, popupStateMapping = {
  open(value) {
    return value ? POPUP_OPEN_HOOK : POPUP_CLOSED_HOOK;
  },
  anchorHidden(value) {
    return value ? ANCHOR_HIDDEN_HOOK : null;
  }
}, majorVersion = parseInt(React.version, 10);
function isReactVersionAtLeast(reactVersionToCheck) {
  return majorVersion >= reactVersionToCheck;
}
function mergeObjects(a3, b2) {
  if (a3 && !b2)
    return a3;
  if (!a3 && b2)
    return b2;
  if (a3 || b2)
    return {
      ...a3,
      ...b2
    };
}
function getStyleHookProps(state, customMapping) {
  const props = {};
  for (const key in state) {
    const value = state[key];
    if (customMapping != null && customMapping.hasOwnProperty(key)) {
      const customProps = customMapping[key](value);
      customProps != null && Object.assign(props, customProps);
      continue;
    }
    value === !0 ? props[`data-${key.toLowerCase()}`] = "" : value && (props[`data-${key.toLowerCase()}`] = value.toString());
  }
  return props;
}
function resolveClassName(className, state) {
  return typeof className == "function" ? className(state) : className;
}
const EMPTY_PROPS = {};
function mergeProps$1(a3, b2, c2, d2, e2) {
  let merged = {
    ...resolvePropsGetter(a3, EMPTY_PROPS)
  };
  return b2 && (merged = mergeOne(merged, b2)), merged;
}
function mergePropsN(props) {
  if (props.length === 0)
    return EMPTY_PROPS;
  if (props.length === 1)
    return resolvePropsGetter(props[0], EMPTY_PROPS);
  let merged = {
    ...resolvePropsGetter(props[0], EMPTY_PROPS)
  };
  for (let i2 = 1; i2 < props.length; i2 += 1)
    merged = mergeOne(merged, props[i2]);
  return merged;
}
function mergeOne(merged, inputProps) {
  return isPropsGetter(inputProps) ? inputProps(merged) : mutablyMergeInto(merged, inputProps);
}
function mutablyMergeInto(mergedProps, externalProps) {
  if (!externalProps)
    return mergedProps;
  for (const propName in externalProps) {
    const externalPropValue = externalProps[propName];
    switch (propName) {
      case "style": {
        mergedProps[propName] = mergeObjects(mergedProps.style, externalPropValue);
        break;
      }
      case "className": {
        mergedProps[propName] = mergeClassNames(mergedProps.className, externalPropValue);
        break;
      }
      default:
        isEventHandler(propName, externalPropValue) ? mergedProps[propName] = mergeEventHandlers(mergedProps[propName], externalPropValue) : mergedProps[propName] = externalPropValue;
    }
  }
  return mergedProps;
}
function isEventHandler(key, value) {
  const code0 = key.charCodeAt(0), code1 = key.charCodeAt(1), code2 = key.charCodeAt(2);
  return code0 === 111 && code1 === 110 && code2 >= 65 && code2 <= 90 && (typeof value == "function" || typeof value > "u");
}
function isPropsGetter(inputProps) {
  return typeof inputProps == "function";
}
function resolvePropsGetter(inputProps, previousProps) {
  return isPropsGetter(inputProps) ? inputProps(previousProps) : inputProps ?? EMPTY_PROPS;
}
function mergeEventHandlers(ourHandler, theirHandler) {
  return theirHandler ? ourHandler ? (event) => {
    if (isSyntheticEvent(event)) {
      const baseUIEvent = event;
      makeEventPreventable(baseUIEvent);
      const result2 = theirHandler(baseUIEvent);
      return baseUIEvent.baseUIHandlerPrevented || ourHandler == null || ourHandler(baseUIEvent), result2;
    }
    const result = theirHandler(event);
    return ourHandler == null || ourHandler(event), result;
  } : theirHandler : ourHandler;
}
function makeEventPreventable(event) {
  return event.preventBaseUIHandler = () => {
    event.baseUIHandlerPrevented = !0;
  }, event;
}
function mergeClassNames(ourClassName, theirClassName) {
  return theirClassName ? ourClassName ? theirClassName + " " + ourClassName : theirClassName : ourClassName;
}
function isSyntheticEvent(event) {
  return event != null && typeof event == "object" && "nativeEvent" in event;
}
function useRenderElement(element2, componentProps, params = {}) {
  const renderProp = componentProps.render, outProps = useRenderElementProps(componentProps, params);
  if (params.enabled === !1)
    return null;
  const state = params.state ?? EMPTY_OBJECT;
  return evaluateRenderProp(element2, renderProp, outProps, state);
}
function useRenderElementProps(componentProps, params = {}) {
  const {
    className: classNameProp,
    render: renderProp
  } = componentProps, {
    state = EMPTY_OBJECT,
    ref,
    props,
    disableStyleHooks,
    customStyleHookMapping: customStyleHookMapping2,
    enabled = !0
  } = params, className = enabled ? resolveClassName(classNameProp, state) : void 0;
  let styleHooks;
  disableStyleHooks !== !0 && (styleHooks = React.useMemo(() => enabled ? getStyleHookProps(state, customStyleHookMapping2) : EMPTY_OBJECT, [state, customStyleHookMapping2, enabled]));
  const outProps = enabled ? mergeObjects(styleHooks, Array.isArray(props) ? mergePropsN(props) : props) ?? EMPTY_OBJECT : EMPTY_OBJECT;
  return typeof document < "u" && (enabled ? Array.isArray(ref) ? outProps.ref = useMergedRefsN([outProps.ref, getChildRef(renderProp), ...ref]) : outProps.ref = useMergedRefs(outProps.ref, getChildRef(renderProp), ref) : useMergedRefs(null, null)), enabled ? (className !== void 0 && (outProps.className = mergeClassNames(outProps.className, className)), outProps) : EMPTY_OBJECT;
}
function evaluateRenderProp(element2, render, props, state) {
  if (render) {
    if (typeof render == "function")
      return render(props, state);
    const mergedProps = mergeProps$1(props, render.props);
    return mergedProps.ref = props.ref, /* @__PURE__ */ React.cloneElement(render, mergedProps);
  }
  if (element2 && typeof element2 == "string")
    return renderTag(element2, props);
  throw new Error("Base UI: Render element or function are not defined.");
}
function renderTag(Tag, props) {
  return Tag === "button" ? /* @__PURE__ */ jsx("button", {
    type: "button",
    ...props
  }) : Tag === "img" ? /* @__PURE__ */ jsx("img", {
    alt: "",
    ...props
  }) : /* @__PURE__ */ React.createElement(Tag, props);
}
function getChildRef(render) {
  return render && typeof render != "function" ? isReactVersionAtLeast(19) ? render.props.ref : render.ref : null;
}
var define_process_env_default$b = {};
const TooltipTrigger$1 = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps, {
    open,
    setTriggerElement,
    triggerProps
  } = useTooltipRootContext(), state = React.useMemo(() => ({
    open
  }), [open]);
  return useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, setTriggerElement],
    props: [triggerProps, elementProps],
    customStyleHookMapping: triggerOpenStateMapping
  });
});
define_process_env_default$b.NODE_ENV !== "production" && (TooltipTrigger$1.displayName = "TooltipTrigger");
var define_process_env_default$a = {};
const TooltipPortalContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$a.NODE_ENV !== "production" && (TooltipPortalContext.displayName = "TooltipPortalContext");
function useTooltipPortalContext() {
  const value = React.useContext(TooltipPortalContext);
  if (value === void 0)
    throw new Error("Base UI: <Tooltip.Portal> is missing.");
  return value;
}
function FloatingPortalLite(props) {
  const node2 = useFloatingPortalNode({
    root: props.root
  });
  return node2 && /* @__PURE__ */ ReactDOM.createPortal(props.children, node2);
}
function TooltipPortal(props) {
  const {
    children,
    keepMounted = !1,
    container
  } = props, {
    mounted
  } = useTooltipRootContext();
  return mounted || keepMounted ? /* @__PURE__ */ jsx(TooltipPortalContext.Provider, {
    value: keepMounted,
    children: /* @__PURE__ */ jsx(FloatingPortalLite, {
      root: container,
      children
    })
  }) : null;
}
var define_process_env_default$9 = {};
const TooltipPositionerContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$9.NODE_ENV !== "production" && (TooltipPositionerContext.displayName = "TooltipPositionerContext");
function useTooltipPositionerContext() {
  const context = React.useContext(TooltipPositionerContext);
  if (context === void 0)
    throw new Error("Base UI: TooltipPositionerContext is missing. TooltipPositioner parts must be placed within <Tooltip.Positioner>.");
  return context;
}
function ownerDocument(node2) {
  return (node2 == null ? void 0 : node2.ownerDocument) || document;
}
var define_process_env_default$8 = {};
const DirectionContext = /* @__PURE__ */ React.createContext(void 0);
define_process_env_default$8.NODE_ENV !== "production" && (DirectionContext.displayName = "DirectionContext");
function useDirection(optional = !0) {
  const context = React.useContext(DirectionContext);
  if (context === void 0 && !optional)
    throw new Error("Base UI: DirectionContext is missing.");
  return (context == null ? void 0 : context.direction) ?? "ltr";
}
const baseArrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    var _a, _b;
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state, {
      element: element2,
      padding = 0,
      offsetParent = "real"
    } = evaluate(options, state) || {};
    if (element2 == null)
      return {};
    const paddingObject = getPaddingObject(padding), coords = {
      x: x2,
      y: y2
    }, axis = getAlignmentAxis(placement), length = getAxisLength(axis), arrowDimensions = await platform2.getDimensions(element2), isYAxis = axis === "y", minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length], startDiff = coords[axis] - rects.reference[axis], arrowOffsetParent = offsetParent === "real" ? await ((_a = platform2.getOffsetParent) == null ? void 0 : _a.call(platform2, element2)) : elements.floating;
    let clientSize = elements.floating[clientProp] || rects.floating[length];
    (!clientSize || !await ((_b = platform2.isElement) == null ? void 0 : _b.call(platform2, arrowOffsetParent))) && (clientSize = elements.floating[clientProp] || rects.floating[length]);
    const centerToReference = endDiff / 2 - startDiff / 2, largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1, minPadding = Math.min(paddingObject[minProp], largestPossiblePadding), maxPadding = Math.min(paddingObject[maxProp], largestPossiblePadding), min2 = minPadding, max2 = clientSize - arrowDimensions[length] - maxPadding, center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference, offset2 = clamp(min2, center, max2), shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min2 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0, alignmentOffset = shouldAddOffset ? center < min2 ? center - min2 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
}), arrow = (options, deps) => ({
  ...baseArrow(options),
  options: [options, deps]
});
function getLogicalSide(sideParam, renderedSide, isRtl) {
  const isLogicalSideParam = sideParam === "inline-start" || sideParam === "inline-end";
  return {
    top: "top",
    right: isLogicalSideParam ? isRtl ? "inline-start" : "inline-end" : "right",
    bottom: "bottom",
    left: isLogicalSideParam ? isRtl ? "inline-end" : "inline-start" : "left"
  }[renderedSide];
}
function getOffsetData(state, sideParam, isRtl) {
  const {
    rects,
    placement
  } = state;
  return {
    side: getLogicalSide(sideParam, getSide(placement), isRtl),
    align: getAlignment(placement) || "center",
    anchor: {
      width: rects.reference.width,
      height: rects.reference.height
    },
    positioner: {
      width: rects.floating.width,
      height: rects.floating.height
    }
  };
}
function useAnchorPositioning(params) {
  var _a, _b;
  const {
    // Public parameters
    anchor,
    positionMethod = "absolute",
    side: sideParam = "bottom",
    sideOffset = 0,
    align = "center",
    alignOffset = 0,
    collisionBoundary,
    collisionPadding = 5,
    sticky = !1,
    arrowPadding = 5,
    trackAnchor = !0,
    // Private parameters
    keepMounted = !1,
    floatingRootContext,
    mounted,
    collisionAvoidance,
    shiftCrossAxis = !1,
    nodeId,
    adaptiveOrigin
  } = params, collisionAvoidanceSide = collisionAvoidance.side || "flip", collisionAvoidanceAlign = collisionAvoidance.align || "flip", collisionAvoidanceFallbackAxisSide = collisionAvoidance.fallbackAxisSide || "end", anchorFn = typeof anchor == "function" ? anchor : void 0, anchorFnCallback = useEventCallback(anchorFn), anchorDep = anchorFn ? anchorFnCallback : anchor, anchorValueRef = useLatestRef$1(anchor), isRtl = useDirection() === "rtl", side = {
    top: "top",
    right: "right",
    bottom: "bottom",
    left: "left",
    "inline-end": isRtl ? "left" : "right",
    "inline-start": isRtl ? "right" : "left"
  }[sideParam], placement = align === "center" ? side : `${side}-${align}`, commonCollisionProps = {
    boundary: collisionBoundary === "clipping-ancestors" ? "clippingAncestors" : collisionBoundary,
    padding: collisionPadding
  }, arrowRef = React.useRef(null), sideOffsetRef = useLatestRef$1(sideOffset), alignOffsetRef = useLatestRef$1(alignOffset), middleware = [offset((state) => {
    const data = getOffsetData(state, sideParam, isRtl), sideAxis = typeof sideOffsetRef.current == "function" ? sideOffsetRef.current(data) : sideOffsetRef.current, alignAxis = typeof alignOffsetRef.current == "function" ? alignOffsetRef.current(data) : alignOffsetRef.current;
    return {
      mainAxis: sideAxis,
      crossAxis: alignAxis,
      alignmentAxis: alignAxis
    };
  }, [typeof sideOffset != "function" ? sideOffset : 0, typeof alignOffset != "function" ? alignOffset : 0, isRtl, sideParam])], shiftDisabled = collisionAvoidanceAlign === "none" && collisionAvoidanceSide !== "shift", crossAxisShiftEnabled = !shiftDisabled && (sticky || shiftCrossAxis || collisionAvoidanceSide === "shift"), flipMiddleware = collisionAvoidanceSide === "none" ? null : flip({
    ...commonCollisionProps,
    mainAxis: !shiftCrossAxis && collisionAvoidanceSide === "flip",
    crossAxis: collisionAvoidanceAlign === "flip" ? "alignment" : !1,
    fallbackAxisSideDirection: collisionAvoidanceFallbackAxisSide
  }), shiftMiddleware = shiftDisabled ? null : shift((data) => {
    const html2 = ownerDocument(data.elements.floating).documentElement;
    return {
      ...commonCollisionProps,
      // Use the Layout Viewport to avoid shifting around when pinch-zooming
      // for context menus.
      rootBoundary: shiftCrossAxis ? {
        x: 0,
        y: 0,
        width: html2.clientWidth,
        height: html2.clientHeight
      } : void 0,
      mainAxis: collisionAvoidanceAlign !== "none",
      crossAxis: crossAxisShiftEnabled,
      limiter: sticky || shiftCrossAxis ? void 0 : limitShift(() => {
        if (!arrowRef.current)
          return {};
        const {
          height
        } = arrowRef.current.getBoundingClientRect();
        return {
          offset: height / 2 + (typeof collisionPadding == "number" ? collisionPadding : 0)
        };
      })
    };
  }, [commonCollisionProps, sticky, shiftCrossAxis, collisionPadding, collisionAvoidanceAlign]);
  collisionAvoidanceSide === "shift" || collisionAvoidanceAlign === "shift" || align === "center" ? middleware.push(shiftMiddleware, flipMiddleware) : middleware.push(flipMiddleware, shiftMiddleware), middleware.push(size({
    ...commonCollisionProps,
    apply({
      elements: {
        floating
      },
      rects: {
        reference
      },
      availableWidth,
      availableHeight
    }) {
      Object.entries({
        "--available-width": `${availableWidth}px`,
        "--available-height": `${availableHeight}px`,
        "--anchor-width": `${reference.width}px`,
        "--anchor-height": `${reference.height}px`
      }).forEach(([key, value]) => {
        floating.style.setProperty(key, value);
      });
    }
  }), arrow(() => ({
    // `transform-origin` calculations rely on an element existing. If the arrow hasn't been set,
    // we'll create a fake element.
    element: arrowRef.current || document.createElement("div"),
    padding: arrowPadding,
    offsetParent: "floating"
  }), [arrowPadding]), hide(), {
    name: "transformOrigin",
    fn(state) {
      var _a2, _b2, _c;
      const {
        elements: elements2,
        middlewareData: middlewareData2,
        placement: renderedPlacement2,
        rects,
        y: y3
      } = state, currentRenderedSide = getSide(renderedPlacement2), currentRenderedAxis = getSideAxis(currentRenderedSide), arrowEl = arrowRef.current, arrowX = ((_a2 = middlewareData2.arrow) == null ? void 0 : _a2.x) || 0, arrowY = ((_b2 = middlewareData2.arrow) == null ? void 0 : _b2.y) || 0, arrowWidth = (arrowEl == null ? void 0 : arrowEl.clientWidth) || 0, arrowHeight = (arrowEl == null ? void 0 : arrowEl.clientHeight) || 0, transformX = arrowX + arrowWidth / 2, transformY = arrowY + arrowHeight / 2, shiftY = Math.abs(((_c = middlewareData2.shift) == null ? void 0 : _c.y) || 0), halfAnchorHeight = rects.reference.height / 2, isOverlappingAnchor = shiftY > (typeof sideOffset == "function" ? sideOffset(getOffsetData(state, sideParam, isRtl)) : sideOffset), adjacentTransformOrigin = {
        top: `${transformX}px calc(100% + ${sideOffset}px)`,
        bottom: `${transformX}px ${-sideOffset}px`,
        left: `calc(100% + ${sideOffset}px) ${transformY}px`,
        right: `${-sideOffset}px ${transformY}px`
      }[currentRenderedSide], overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y3}px`;
      return elements2.floating.style.setProperty("--transform-origin", crossAxisShiftEnabled && currentRenderedAxis === "y" && isOverlappingAnchor ? overlapTransformOrigin : adjacentTransformOrigin), {};
    }
  }, adaptiveOrigin);
  let rootContext = floatingRootContext;
  !mounted && floatingRootContext && (rootContext = {
    ...floatingRootContext,
    elements: {
      reference: null,
      floating: null,
      domReference: null
    }
  });
  const autoUpdateOptions = React.useMemo(() => ({
    elementResize: trackAnchor && typeof ResizeObserver < "u",
    layoutShift: trackAnchor && typeof IntersectionObserver < "u"
  }), [trackAnchor]), {
    refs,
    elements,
    x: x2,
    y: y2,
    middlewareData,
    update: update2,
    placement: renderedPlacement,
    context,
    isPositioned,
    floatingStyles: originalFloatingStyles
  } = useFloating$1({
    rootContext,
    placement,
    middleware,
    strategy: positionMethod,
    whileElementsMounted: keepMounted ? void 0 : (...args) => autoUpdate(...args, autoUpdateOptions),
    nodeId
  }), {
    sideX,
    sideY
  } = middlewareData.adaptiveOrigin || {}, floatingStyles = React.useMemo(() => adaptiveOrigin ? {
    position: positionMethod,
    [sideX]: `${x2}px`,
    [sideY]: `${y2}px`
  } : originalFloatingStyles, [adaptiveOrigin, sideX, sideY, positionMethod, x2, y2, originalFloatingStyles]), registeredPositionReferenceRef = React.useRef(null);
  useIsoLayoutEffect(() => {
    if (!mounted)
      return;
    const anchorValue = anchorValueRef.current, resolvedAnchor = typeof anchorValue == "function" ? anchorValue() : anchorValue, finalAnchor = (isRef(resolvedAnchor) ? resolvedAnchor.current : resolvedAnchor) || null || null;
    finalAnchor !== registeredPositionReferenceRef.current && (refs.setPositionReference(finalAnchor), registeredPositionReferenceRef.current = finalAnchor);
  }, [mounted, refs, anchorDep, anchorValueRef]), React.useEffect(() => {
    if (!mounted)
      return;
    const anchorValue = anchorValueRef.current;
    typeof anchorValue != "function" && isRef(anchorValue) && anchorValue.current !== registeredPositionReferenceRef.current && (refs.setPositionReference(anchorValue.current), registeredPositionReferenceRef.current = anchorValue.current);
  }, [mounted, refs, anchorDep, anchorValueRef]), React.useEffect(() => {
    if (keepMounted && mounted && elements.domReference && elements.floating)
      return autoUpdate(elements.domReference, elements.floating, update2, autoUpdateOptions);
  }, [keepMounted, mounted, elements, update2, autoUpdateOptions]);
  const renderedSide = getSide(renderedPlacement), logicalRenderedSide = getLogicalSide(sideParam, renderedSide, isRtl), renderedAlign = getAlignment(renderedPlacement) || "center", anchorHidden = !!((_a = middlewareData.hide) != null && _a.referenceHidden), arrowStyles = React.useMemo(() => {
    var _a2, _b2;
    return {
      position: "absolute",
      top: (_a2 = middlewareData.arrow) == null ? void 0 : _a2.y,
      left: (_b2 = middlewareData.arrow) == null ? void 0 : _b2.x
    };
  }, [middlewareData.arrow]), arrowUncentered = ((_b = middlewareData.arrow) == null ? void 0 : _b.centerOffset) !== 0;
  return React.useMemo(() => ({
    positionerStyles: floatingStyles,
    arrowStyles,
    arrowRef,
    arrowUncentered,
    side: logicalRenderedSide,
    align: renderedAlign,
    anchorHidden,
    refs,
    context,
    isPositioned,
    update: update2
  }), [floatingStyles, arrowStyles, arrowRef, arrowUncentered, logicalRenderedSide, renderedAlign, anchorHidden, refs, context, isPositioned, update2]);
}
function isRef(param) {
  return param != null && "current" in param;
}
var define_process_env_default$7 = {};
const TooltipPositioner = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    render,
    className,
    anchor,
    positionMethod = "absolute",
    side = "top",
    align = "center",
    sideOffset = 0,
    alignOffset = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    arrowPadding = 5,
    sticky = !1,
    trackAnchor = !0,
    collisionAvoidance = POPUP_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps, {
    open,
    setPositionerElement,
    mounted,
    floatingRootContext,
    trackCursorAxis,
    hoverable
  } = useTooltipRootContext(), keepMounted = useTooltipPortalContext(), positioning = useAnchorPositioning({
    anchor,
    positionMethod,
    floatingRootContext,
    mounted,
    side,
    sideOffset,
    align,
    alignOffset,
    collisionBoundary,
    collisionPadding,
    sticky,
    arrowPadding,
    trackAnchor,
    keepMounted,
    collisionAvoidance
  }), defaultProps = React.useMemo(() => {
    const hiddenStyles = {};
    return (!open || trackCursorAxis === "both" || !hoverable) && (hiddenStyles.pointerEvents = "none"), {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positioning.positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, trackCursorAxis, hoverable, mounted, positioning.positionerStyles]), positioner = React.useMemo(() => ({
    props: defaultProps,
    ...positioning
  }), [defaultProps, positioning]), state = React.useMemo(() => ({
    open,
    side: positioner.side,
    align: positioner.align,
    anchorHidden: positioner.anchorHidden
  }), [open, positioner.side, positioner.align, positioner.anchorHidden]), contextValue = React.useMemo(() => ({
    ...state,
    arrowRef: positioner.arrowRef,
    arrowStyles: positioner.arrowStyles,
    arrowUncentered: positioner.arrowUncentered
  }), [state, positioner.arrowRef, positioner.arrowStyles, positioner.arrowUncentered]), element2 = useRenderElement("div", componentProps, {
    state,
    props: [positioner.props, elementProps],
    ref: [forwardedRef, setPositionerElement],
    customStyleHookMapping: popupStateMapping
  });
  return /* @__PURE__ */ jsx(TooltipPositionerContext.Provider, {
    value: contextValue,
    children: element2
  });
});
define_process_env_default$7.NODE_ENV !== "production" && (TooltipPositioner.displayName = "TooltipPositioner");
var define_process_env_default$6 = {};
const customStyleHookMapping = {
  ...popupStateMapping,
  ...transitionStatusMapping
}, TooltipPopup = /* @__PURE__ */ React.forwardRef(function(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps, {
    open,
    instantType,
    transitionStatus,
    popupProps,
    popupRef,
    onOpenChangeComplete
  } = useTooltipRootContext(), {
    side,
    align
  } = useTooltipPositionerContext();
  useOpenChangeComplete({
    open,
    ref: popupRef,
    onComplete() {
      open && (onOpenChangeComplete == null || onOpenChangeComplete(!0));
    }
  });
  const state = React.useMemo(() => ({
    open,
    side,
    align,
    instant: instantType,
    transitionStatus
  }), [open, side, align, instantType, transitionStatus]);
  return useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, popupRef],
    props: [popupProps, transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE : EMPTY_OBJECT, elementProps],
    customStyleHookMapping
  });
});
define_process_env_default$6.NODE_ENV !== "production" && (TooltipPopup.displayName = "TooltipPopup");
var define_process_env_default$5 = {};
const TooltipProvider = function(props) {
  const {
    delay,
    closeDelay,
    timeout = 400
  } = props, contextValue = React.useMemo(() => ({
    delay,
    closeDelay
  }), [delay, closeDelay]), delayValue = React.useMemo(() => ({
    open: delay,
    close: closeDelay
  }), [delay, closeDelay]);
  return /* @__PURE__ */ jsx(TooltipProviderContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsx(FloatingDelayGroup, {
      delay: delayValue,
      timeoutMs: timeout,
      children: props.children
    })
  });
};
define_process_env_default$5.NODE_ENV !== "production" && (TooltipProvider.displayName = "TooltipProvider");
function ContextProviders({
  children,
  config: config2
}) {
  return /* @__PURE__ */ jsx(TooltipProvider, { children: /* @__PURE__ */ jsx(ConfigProvider, { config: config2, children: /* @__PURE__ */ jsx(KartonProvider, { children: /* @__PURE__ */ jsx(PanelsProvider, { children: /* @__PURE__ */ jsx(PluginProvider, { children: /* @__PURE__ */ jsx(ChatStateProvider, { children }) }) }) }) }) });
}
function useEventListener(eventName, handler, options, element2 = window) {
  useEffect(() => {
    if (!(typeof window > "u") && element2)
      return element2.addEventListener(eventName, handler, options), () => element2.removeEventListener(eventName, handler, options);
  }, [eventName, handler, element2, options]);
}
function HotkeyListener() {
  const {
    startPromptCreation,
    stopPromptCreation,
    isPromptCreationActive,
    isContextSelectorActive,
    stopContextSelector,
    startContextSelector
  } = useChatState(), { isChatOpen, closeChat } = usePanels(), hotKeyHandlerMap = useMemo(
    () => ({
      // Functions that return true will prevent further propagation of the event.
      [HotkeyActions.CTRL_ALT_PERIOD]: () => {
        if (isPromptCreationActive) {
          if (!isContextSelectorActive)
            return startContextSelector(), !0;
        } else return startPromptCreation(), !0;
        return !1;
      },
      [HotkeyActions.ESC]: () => isContextSelectorActive ? (stopContextSelector(), !0) : isPromptCreationActive ? (stopPromptCreation(), !0) : isChatOpen ? (closeChat(), !0) : !1
    }),
    [
      startPromptCreation,
      stopPromptCreation,
      isPromptCreationActive,
      isContextSelectorActive,
      stopContextSelector,
      startContextSelector,
      isChatOpen,
      closeChat
    ]
  ), hotKeyListener = useCallback(
    (ev) => {
      for (const [action, definition2] of Object.entries(
        hotkeyActionDefinitions
      ))
        if (definition2.isEventMatching(ev)) {
          hotKeyHandlerMap[action]() && (ev.preventDefault(), ev.stopPropagation());
          break;
        }
    },
    [hotKeyHandlerMap]
  );
  useEventListener("keydown", hotKeyListener, {
    capture: !0
  });
  const iframe = document.getElementById(
    "user-app-iframe"
  );
  return useEventListener(
    "keydown",
    hotKeyListener,
    {
      capture: !0
    },
    iframe == null ? void 0 : iframe.contentWindow
  ), null;
}
function useWindowSize() {
  const iframeWindow = getIFrameWindow(), [size2, setSize] = useState({
    width: (iframeWindow == null ? void 0 : iframeWindow.innerWidth) || window.innerWidth,
    height: (iframeWindow == null ? void 0 : iframeWindow.innerHeight) || window.innerHeight
  }), handleResize = useCallback(() => {
    const iframe = getIFrameWindow();
    iframe && setSize({
      width: iframe.innerWidth,
      height: iframe.innerHeight
    });
  }, []);
  return useEffect(() => {
    const iframe = getIFrameWindow();
    if (iframe)
      return iframe.addEventListener("resize", handleResize), handleResize(), () => {
        iframe.removeEventListener("resize", handleResize);
      };
  }, [handleResize]), size2;
}
function useCyclicUpdate(func, frameRate) {
  const animationFrameHandle = useRef(void 0), timeBetweenFrames = useMemo(
    () => 1e3 / frameRate,
    [frameRate]
  ), lastCallFrameTime = useRef(0), update2 = useCallback(
    (frameTime) => {
      frameTime - lastCallFrameTime.current >= timeBetweenFrames && (func(), lastCallFrameTime.current = frameTime), animationFrameHandle.current = requestAnimationFrame(update2);
    },
    [func, timeBetweenFrames]
  );
  useEffect(() => (animationFrameHandle.current = requestAnimationFrame(update2), () => {
    animationFrameHandle.current && (cancelAnimationFrame(animationFrameHandle.current), animationFrameHandle.current = void 0);
  }), [frameRate, update2]);
}
function HoveredItem({ refElement, ...props }) {
  const boxRef = useRef(null), windowSize = useWindowSize(), { plugins } = usePlugins(), hoveredElementPluginContext = useMemo(() => refElement ? plugins.filter(
    (plugin) => plugin.onContextElementSelect
  ).map((plugin) => {
    var _a;
    return {
      pluginName: plugin.pluginName,
      context: (_a = plugin.onContextElementSelect) == null ? void 0 : _a.call(plugin, refElement)
    };
  }) : [], [refElement]), updateBoxPosition = useCallback(() => {
    if (boxRef.current && refElement) {
      const referenceRect = refElement.getBoundingClientRect();
      boxRef.current.style.top = `${referenceRect.top - 2}px`, boxRef.current.style.left = `${referenceRect.left - 2}px`, boxRef.current.style.width = `${referenceRect.width + 4}px`, boxRef.current.style.height = `${referenceRect.height + 4}px`, boxRef.current.style.display = void 0;
    } else
      boxRef.current.style.height = "0px", boxRef.current.style.width = "0px", boxRef.current.style.top = `${windowSize.height / 2}px`, boxRef.current.style.left = `${windowSize.width / 2}px`, boxRef.current.style.display = "none";
  }, [refElement, windowSize.height, windowSize.width]);
  return useCyclicUpdate(updateBoxPosition, 30), /* @__PURE__ */ jsx(
    "div",
    {
      ...props,
      className: cn(
        "fixed z-10 flex items-center justify-center rounded-sm border-2 border-blue-600/70 border-dotted bg-blue-600/5 text-white transition-all duration-100"
      ),
      ref: boxRef,
      children: /* @__PURE__ */ jsxs("div", { className: "absolute top-0.5 left-0.5 flex w-full flex-row items-start justify-start gap-1", children: [
        /* @__PURE__ */ jsx("div", { className: "flex flex-row items-center justify-center gap-0.5 overflow-hidden rounded-md bg-zinc-700/80 px-1 py-0 font-medium text-white text-xs", children: /* @__PURE__ */ jsx("span", { className: "truncate", children: refElement.tagName.toLowerCase() }) }),
        hoveredElementPluginContext.filter((plugin) => plugin.context.annotation).map((plugin) => {
          var _a;
          return /* @__PURE__ */ jsxs(
            "div",
            {
              className: "flex flex-row items-center justify-center gap-0.5 overflow-hidden rounded-md bg-zinc-700/80 px-1 py-0 font-medium text-white text-xs",
              children: [
                /* @__PURE__ */ jsx("span", { className: "size-3 shrink-0 stroke-white text-white *:size-full", children: (_a = plugins.find((p2) => p2.pluginName === plugin.pluginName)) == null ? void 0 : _a.iconSvg }),
                /* @__PURE__ */ jsx("span", { className: "truncate", children: plugin.context.annotation })
              ]
            },
            plugin.pluginName
          );
        })
      ] })
    }
  );
}
const ContextChipHoverContext = createContext(void 0);
function ContextChipHoverProvider({
  children
}) {
  const [hoveredElement, setHoveredElement] = useState(
    null
  ), { domContextElements } = useChatState();
  return useEffect(() => {
    hoveredElement && (domContextElements.some(
      (contextEl) => contextEl.element === hoveredElement
    ) || setHoveredElement(null));
  }, [hoveredElement, domContextElements]), /* @__PURE__ */ jsx(
    ContextChipHoverContext.Provider,
    {
      value: { hoveredElement, setHoveredElement },
      children
    }
  );
}
function useContextChipHover() {
  const context = useContext(ContextChipHoverContext);
  if (context === void 0)
    throw new Error(
      "useContextChipHover must be used within a ContextChipHoverProvider"
    );
  return context;
}
function SelectedItem({
  refElement,
  isChipHovered,
  ...props
}) {
  const boxRef = useRef(null), windowSize = useWindowSize(), updateBoxPosition = useCallback(() => {
    if (boxRef.current)
      if (refElement) {
        const referenceRect = refElement.getBoundingClientRect();
        boxRef.current.style.top = `${referenceRect.top - 2}px`, boxRef.current.style.left = `${referenceRect.left - 2}px`, boxRef.current.style.width = `${referenceRect.width + 4}px`, boxRef.current.style.height = `${referenceRect.height + 4}px`, boxRef.current.style.display = void 0;
      } else
        boxRef.current.style.height = "0px", boxRef.current.style.width = "0px", boxRef.current.style.top = `${windowSize.height / 2}px`, boxRef.current.style.left = `${windowSize.width / 2}px`, boxRef.current.style.opacity = "none";
  }, [refElement, windowSize.height, windowSize.width]);
  return useCyclicUpdate(updateBoxPosition, 30), /* @__PURE__ */ jsx(
    "button",
    {
      ...props,
      className: cn(
        "pointer-events-auto fixed flex cursor-not-allowed items-center justify-center rounded-sm border-2 border-zinc-600/70 border-dotted transition-all duration-100 hover:border-rose-600/70 hover:bg-rose-600/5",
        isChipHovered && "border-blue-600/70 bg-blue-600/5"
      ),
      onClick: props.onRemoveClick,
      ref: boxRef
    }
  );
}
function DOMContextSelector() {
  const {
    domContextElements,
    addChatDomContext,
    isContextSelectorActive,
    removeChatDomContext
  } = useChatState(), shouldShow = isContextSelectorActive, [hoveredElement, setHoveredElement] = useState(
    null
  ), { hoveredElement: chipHoveredElement } = useContextChipHover(), handleElementSelected = useCallback(
    (el) => {
      domContextElements.find(
        (contextEl) => contextEl.element === el
      ) || addChatDomContext(el);
    },
    [addChatDomContext, domContextElements]
  ), hoveredSelectedElement = hoveredElement ? domContextElements.find((el) => el.element === hoveredElement) : null, selectedItems = useMemo(() => domContextElements.map((el) => el.element), [domContextElements]), lastHoveredElement = useRef(null), mouseState = useRef(null), nextUpdateTimeout = useRef(null), [hoversAddable, setHoversAddable] = useState(!1), updateHoveredElement = useCallback(() => {
    if (!mouseState.current) return;
    const refElement = getElementAtPoint(
      mouseState.current.lastX,
      mouseState.current.lastY
    );
    if (selectedItems.includes(refElement)) {
      setHoversAddable(!1), lastHoveredElement.current = null, setHoveredElement(null);
      return;
    }
    lastHoveredElement.current !== refElement && (lastHoveredElement.current = refElement, setHoveredElement(refElement), setHoversAddable(!0));
  }, [selectedItems]);
  useEffect(() => {
    updateHoveredElement();
  }, [updateHoveredElement]);
  const handleMouseMove = useCallback(
    (event) => {
      var _a, _b, _c, _d, _e2, _f;
      const currentTimestamp = performance.now(), deltaX = event.clientX - (((_a = mouseState.current) == null ? void 0 : _a.lastX) ?? event.clientX), deltaY = event.clientY - (((_b = mouseState.current) == null ? void 0 : _b.lastY) ?? event.clientY), deltaTime = currentTimestamp - (((_c = mouseState.current) == null ? void 0 : _c.lastTimestamp) ?? currentTimestamp), distance = Math.hypot(deltaX, deltaY);
      mouseState.current = {
        lastX: deltaTime > 0 ? event.clientX : (_d = mouseState.current) == null ? void 0 : _d.lastX,
        lastY: deltaTime > 0 ? event.clientY : (_e2 = mouseState.current) == null ? void 0 : _e2.lastY,
        velocity: deltaTime > 0 ? distance / deltaTime * 1e3 : 0,
        lastTimestamp: currentTimestamp
      }, ((_f = mouseState.current) == null ? void 0 : _f.velocity) > 30 ? (nextUpdateTimeout.current && clearTimeout(nextUpdateTimeout.current), nextUpdateTimeout.current = setTimeout(updateHoveredElement, 1e3 / 28)) : nextUpdateTimeout.current || (nextUpdateTimeout.current = setTimeout(updateHoveredElement, 1e3 / 28));
    },
    [updateHoveredElement]
  ), handleMouseLeave = useCallback(() => {
    clearTimeout(nextUpdateTimeout.current), lastHoveredElement.current = null, setHoveredElement(null);
  }, []), handleMouseClick = useCallback(
    (event) => {
      event.preventDefault(), event.stopPropagation(), lastHoveredElement.current && (selectedItems.includes(lastHoveredElement.current) || handleElementSelected(lastHoveredElement.current));
    },
    [handleElementSelected, selectedItems]
  );
  return shouldShow ? /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "pointer-events-auto fixed inset-0 h-screen w-screen",
        hoversAddable ? "cursor-copy" : "cursor-default"
      ),
      id: "element-selector",
      onMouseMove: handleMouseMove,
      onMouseLeave: handleMouseLeave,
      onClick: handleMouseClick,
      role: "button",
      tabIndex: 0,
      children: [
        hoveredElement && !hoveredSelectedElement && /* @__PURE__ */ jsx(HoveredItem, { refElement: hoveredElement }),
        domContextElements.map((el) => /* @__PURE__ */ jsx(
          SelectedItem,
          {
            refElement: el.element,
            isChipHovered: chipHoveredElement === el.element,
            onRemoveClick: () => removeChatDomContext(el.element)
          },
          getXPathForElement(el.element, !0)
        ))
      ]
    }
  ) : null;
}
const DraggableContext = createContext(
  null
), DraggableProvider = ({
  containerRef,
  children,
  snapAreas,
  onDragStart,
  onDragEnd
}) => {
  const [borderLocation, setBorderLocation] = useState({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  });
  useEffect(() => {
    if (!containerRef.current) return;
    const updateBorderLocation = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setBorderLocation({
          top: rect.top,
          left: rect.left,
          right: rect.right,
          bottom: rect.bottom
        });
      }
    };
    updateBorderLocation();
    const resizeObserver = new ResizeObserver(updateBorderLocation);
    return resizeObserver.observe(containerRef.current), window.addEventListener("resize", updateBorderLocation), () => {
      containerRef.current && resizeObserver.unobserve(containerRef.current), resizeObserver.disconnect(), window.removeEventListener("resize", updateBorderLocation);
    };
  }, [containerRef]);
  const dragStartListeners = useRef(/* @__PURE__ */ new Set()), dragEndListeners = useRef(/* @__PURE__ */ new Set()), registerDragStart = useCallback((cb) => (dragStartListeners.current.add(cb), () => dragStartListeners.current.delete(cb)), []), registerDragEnd = useCallback((cb) => (dragEndListeners.current.add(cb), () => dragEndListeners.current.delete(cb)), []), emitDragStart = useCallback(() => {
    onDragStart && onDragStart(), dragStartListeners.current.forEach((cb) => cb());
  }, [onDragStart]), emitDragEnd = useCallback(() => {
    onDragEnd && onDragEnd(), dragEndListeners.current.forEach((cb) => cb());
  }, [onDragEnd]), contextValue = {
    borderLocation,
    snapAreas,
    registerDragStart,
    registerDragEnd,
    emitDragStart,
    emitDragEnd
  };
  return /* @__PURE__ */ jsx(DraggableContext.Provider, { value: contextValue, children: contextValue.borderLocation.right - contextValue.borderLocation.left > 0 && contextValue.borderLocation.bottom - contextValue.borderLocation.top > 0 && children });
};
function useDraggable(config2) {
  const providerData = useContext(DraggableContext), latestProviderDataRef = useRef(providerData);
  useEffect(() => {
    latestProviderDataRef.current = providerData;
  }, [providerData]);
  const movingElementRef = useRef(null), dragInitiatorRef = useRef(null), [movingElementNode, setMovingElementNode] = useState(null), [dragInitiatorNode, setDragInitiatorNode] = useState(null), mouseToDraggableCenterOffsetRef = useRef(null), mouseDownPosRef = useRef(null), currentMousePosRef = useRef(null), isDraggingRef = useRef(!1), [isDragging, setIsDragging] = useState(!1), persistedRelativeCenterRef = useRef(config2.initialRelativeCenter), [currentSnapArea, setCurrentSnapArea] = useState(null), {
    startThreshold = 2,
    areaSnapThreshold = 60,
    // px, default threshold for snapping
    onDragStart,
    onDragEnd,
    initialSnapArea,
    springStiffness = 0.1,
    // Default spring stiffness for dragging
    springStiffnessSnap = 0.02,
    // Default spring stiffness for snapping (higher for faster snap)
    springDampness = 0.55
    // Default spring dampness
    // initialRelativeCenter is used to initialize persistedRelativeCenterRef
  } = config2, animatedPositionRef = useRef(null), velocityRef = useRef({ x: 0, y: 0 }), hasAnimatedOnceRef = useRef(!1), animationInProgressRef = useRef(!1), animationFrameRef = useRef(null);
  useEffect(() => {
    if (initialSnapArea && providerData && providerData.borderLocation && providerData.snapAreas && providerData.snapAreas[initialSnapArea] && !isDraggingRef.current && !animationInProgressRef.current) {
      const { top, left, right, bottom } = providerData.borderLocation, width = right - left, height = bottom - top, center = {
        topLeft: { x: left, y: top },
        topRight: { x: right, y: top },
        bottomLeft: { x: left, y: bottom },
        bottomRight: { x: right, y: bottom }
      }[initialSnapArea];
      if (center && width > 0 && height > 0) {
        const relX = (center.x - left) / width, relY = (center.y - top) / height;
        persistedRelativeCenterRef.current = { x: relX, y: relY };
      } else center && console.warn(
        "useDraggable: Container for initialSnapArea has zero width or height. Cannot calculate relative center from snap area. Falling back to initialRelativeCenter or undefined."
      );
    }
  }, [initialSnapArea, providerData]);
  function getSnapAreaCenters(borderLocation) {
    const { top, left, right, bottom } = borderLocation, centerX = (left + right) / 2;
    return {
      topLeft: { x: left, y: top },
      topCenter: { x: centerX, y: top },
      topRight: { x: right, y: top },
      bottomLeft: { x: left, y: bottom },
      bottomCenter: { x: centerX, y: bottom },
      bottomRight: { x: right, y: bottom }
    };
  }
  const updateDraggablePosition = useCallback(() => {
    var _a, _b;
    const draggableEl = movingElementRef.current;
    if (!draggableEl) return;
    const draggableWidth = draggableEl.offsetWidth, draggableHeight = draggableEl.offsetHeight, offsetParent = draggableEl.offsetParent;
    let parentViewportLeft = 0, parentViewportTop = 0, parentWidth = window.innerWidth, parentHeight = window.innerHeight;
    if (offsetParent) {
      const opRect = offsetParent.getBoundingClientRect();
      parentViewportLeft = opRect.left, parentViewportTop = opRect.top, parentWidth = offsetParent.offsetWidth || window.innerWidth, parentHeight = offsetParent.offsetHeight || window.innerHeight;
    }
    let targetViewportCenterX = null, targetViewportCenterY = null;
    const currentDesiredRelativeCenter = persistedRelativeCenterRef.current;
    let snapArea = null, snapTarget = null;
    const provider = latestProviderDataRef.current;
    let isTopHalf = !0, isLeftHalf = !0;
    if (isDraggingRef.current && mouseToDraggableCenterOffsetRef.current && currentMousePosRef.current && provider && provider.borderLocation && provider.snapAreas) {
      const dragCenter = {
        x: currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x,
        y: currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y
      }, areaCenters = getSnapAreaCenters(provider.borderLocation);
      let minDist = Number.POSITIVE_INFINITY, closestArea = null, closestCenter = null;
      for (const area in provider.snapAreas)
        if (provider.snapAreas[area]) {
          const center = areaCenters[area];
          if (!center) continue;
          const dist = Math.hypot(
            center.x - dragCenter.x,
            center.y - dragCenter.y
          );
          dist < minDist && (minDist = dist, closestArea = area, closestCenter = center);
        }
      closestArea && closestCenter && minDist <= areaSnapThreshold && (snapArea = closestArea, snapTarget = closestCenter), isLeftHalf = (dragCenter.x - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (dragCenter.y - parentViewportTop) / parentHeight <= 0.5;
    }
    if (isDraggingRef.current && snapTarget)
      targetViewportCenterX = snapTarget.x, targetViewportCenterY = snapTarget.y, setCurrentSnapArea(snapArea), isLeftHalf = (snapTarget.x - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (snapTarget.y - parentViewportTop) / parentHeight <= 0.5;
    else if (isDraggingRef.current && mouseToDraggableCenterOffsetRef.current && currentMousePosRef.current)
      targetViewportCenterX = currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x, targetViewportCenterY = currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y, setCurrentSnapArea(null), isLeftHalf = (targetViewportCenterX - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (targetViewportCenterY - parentViewportTop) / parentHeight <= 0.5;
    else {
      if (currentDesiredRelativeCenter && parentWidth > 0 && parentHeight > 0) {
        if (isTopHalf = currentDesiredRelativeCenter.y <= 0.5, isLeftHalf = currentDesiredRelativeCenter.x <= 0.5, isLeftHalf) {
          const targetCenterXInParent = parentWidth * currentDesiredRelativeCenter.x;
          targetViewportCenterX = parentViewportLeft + targetCenterXInParent;
        } else {
          const targetCenterXInParent = parentWidth * (1 - currentDesiredRelativeCenter.x);
          targetViewportCenterX = parentViewportLeft + parentWidth - targetCenterXInParent;
        }
        if (isTopHalf) {
          const targetCenterYInParent = parentHeight * currentDesiredRelativeCenter.y;
          targetViewportCenterY = parentViewportTop + targetCenterYInParent;
        } else {
          const targetCenterYInParent = parentHeight * (1 - currentDesiredRelativeCenter.y);
          targetViewportCenterY = parentViewportTop + parentHeight - targetCenterYInParent;
        }
      } else {
        !((_a = movingElementRef.current) != null && _a.style.left) && !((_b = movingElementRef.current) != null && _b.style.top) && console.warn(
          "useDraggable: Cannot determine position. Parent has no dimensions or initialRelativeCenter was not effectively set."
        );
        return;
      }
      setCurrentSnapArea(null);
    }
    if (targetViewportCenterX === null || targetViewportCenterY === null)
      return;
    const { borderLocation } = latestProviderDataRef.current || {
      borderLocation: void 0
    };
    if (borderLocation && draggableWidth > 0 && draggableHeight > 0) {
      const providerRectWidth = borderLocation.right - borderLocation.left, providerRectHeight = borderLocation.bottom - borderLocation.top;
      let clampedCenterX = targetViewportCenterX, clampedCenterY = targetViewportCenterY;
      if (draggableWidth >= providerRectWidth)
        clampedCenterX = borderLocation.left + providerRectWidth / 2;
      else {
        const minX = borderLocation.left + draggableWidth / 2, maxX = borderLocation.right - draggableWidth / 2;
        clampedCenterX = Math.max(minX, Math.min(clampedCenterX, maxX));
      }
      if (draggableHeight >= providerRectHeight)
        clampedCenterY = borderLocation.top + providerRectHeight / 2;
      else {
        const minY = borderLocation.top + draggableHeight / 2, maxY = borderLocation.bottom - draggableHeight / 2;
        clampedCenterY = Math.max(minY, Math.min(clampedCenterY, maxY));
      }
      targetViewportCenterX = clampedCenterX, targetViewportCenterY = clampedCenterY;
    }
    if (!animatedPositionRef.current) {
      animatedPositionRef.current = {
        x: targetViewportCenterX,
        y: targetViewportCenterY
      }, velocityRef.current = { x: 0, y: 0 };
      const targetElementStyleX2 = targetViewportCenterX - draggableWidth / 2, targetElementStyleY2 = targetViewportCenterY - draggableHeight / 2, elStyle2 = draggableEl.style;
      if (elStyle2.right = "", elStyle2.bottom = "", elStyle2.left = "", elStyle2.top = "", isLeftHalf) {
        const styleLeftPx = targetElementStyleX2 - parentViewportLeft;
        elStyle2.left = parentWidth > 0 ? `${(styleLeftPx / parentWidth * 100).toFixed(2)}%` : "0px", elStyle2.right = "";
      } else {
        const styleRightPx = parentViewportLeft + parentWidth - (targetElementStyleX2 + draggableWidth);
        elStyle2.right = parentWidth > 0 ? `${(styleRightPx / parentWidth * 100).toFixed(2)}%` : "0px", elStyle2.left = "";
      }
      if (isTopHalf) {
        const styleTopPx = targetElementStyleY2 - parentViewportTop;
        elStyle2.top = parentHeight > 0 ? `${(styleTopPx / parentHeight * 100).toFixed(2)}%` : "0px", elStyle2.bottom = "";
      } else {
        const styleBottomPx = parentViewportTop + parentHeight - (targetElementStyleY2 + draggableHeight);
        elStyle2.bottom = parentHeight > 0 ? `${(styleBottomPx / parentHeight * 100).toFixed(2)}%` : "0px", elStyle2.top = "";
      }
      hasAnimatedOnceRef.current = !0;
      return;
    }
    if (!hasAnimatedOnceRef.current) {
      hasAnimatedOnceRef.current = !0;
      return;
    }
    const pos = animatedPositionRef.current, vel = velocityRef.current, dx = targetViewportCenterX - pos.x, dy = targetViewportCenterY - pos.y, currentStiffness = isDraggingRef.current ? springStiffness : springStiffnessSnap, ax = currentStiffness * dx - springDampness * vel.x, ay = currentStiffness * dy - springDampness * vel.y;
    vel.x += ax, vel.y += ay, pos.x += vel.x, pos.y += vel.y;
    const threshold = 0.5;
    Math.abs(dx) < threshold && Math.abs(dy) < threshold && Math.abs(vel.x) < threshold && Math.abs(vel.y) < threshold && (pos.x = targetViewportCenterX, pos.y = targetViewportCenterY, vel.x = 0, vel.y = 0), animatedPositionRef.current = { ...pos }, velocityRef.current = { ...vel };
    const targetElementStyleX = pos.x - draggableWidth / 2, targetElementStyleY = pos.y - draggableHeight / 2, elStyle = draggableEl.style;
    if (elStyle.right = "", elStyle.bottom = "", elStyle.left = "", elStyle.top = "", isLeftHalf) {
      const styleLeftPx = targetElementStyleX - parentViewportLeft;
      elStyle.left = parentWidth > 0 ? `${(styleLeftPx / parentWidth * 100).toFixed(2)}%` : "0px", elStyle.right = "";
    } else {
      const styleRightPx = parentViewportLeft + parentWidth - (targetElementStyleX + draggableWidth);
      elStyle.right = parentWidth > 0 ? `${(styleRightPx / parentWidth * 100).toFixed(2)}%` : "0px", elStyle.left = "";
    }
    if (isTopHalf) {
      const styleTopPx = targetElementStyleY - parentViewportTop;
      elStyle.top = parentHeight > 0 ? `${(styleTopPx / parentHeight * 100).toFixed(2)}%` : "0px", elStyle.bottom = "";
    } else {
      const styleBottomPx = parentViewportTop + parentHeight - (targetElementStyleY + draggableHeight);
      elStyle.bottom = parentHeight > 0 ? `${(styleBottomPx / parentHeight * 100).toFixed(2)}%` : "0px", elStyle.top = "";
    }
    Math.abs(pos.x - targetViewportCenterX) > threshold || Math.abs(pos.y - targetViewportCenterY) > threshold || Math.abs(vel.x) > threshold || Math.abs(vel.y) > threshold || isDraggingRef.current ? (animationInProgressRef.current = !0, animationFrameRef.current = requestAnimationFrame(
      updateDraggablePosition
    )) : (animationInProgressRef.current = !1, animationFrameRef.current = null);
  }, [areaSnapThreshold, springStiffness, springStiffnessSnap, springDampness]), [wasDragged, setWasDragged] = useState(!1), mouseUpHandler = useCallback(
    (_e2) => {
      var _a;
      let finalSnapArea = null;
      if (isDraggingRef.current) {
        setWasDragged(!0), setTimeout(() => setWasDragged(!1), 20);
        const draggableEl = movingElementRef.current, provider = latestProviderDataRef.current;
        if (draggableEl && provider && provider.borderLocation) {
          const draggableWidth = draggableEl.offsetWidth, draggableHeight = draggableEl.offsetHeight, offsetParent = draggableEl.offsetParent;
          let parentViewportLeft = 0, parentViewportTop = 0, parentWidth = window.innerWidth, parentHeight = window.innerHeight;
          if (offsetParent) {
            const opRect = offsetParent.getBoundingClientRect();
            parentViewportLeft = opRect.left, parentViewportTop = opRect.top, parentWidth = offsetParent.offsetWidth || window.innerWidth, parentHeight = offsetParent.offsetHeight || window.innerHeight;
          }
          let releasedCenterX = 0, releasedCenterY = 0;
          currentMousePosRef.current && mouseToDraggableCenterOffsetRef.current ? (releasedCenterX = currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x, releasedCenterY = currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y) : animatedPositionRef.current && (releasedCenterX = animatedPositionRef.current.x, releasedCenterY = animatedPositionRef.current.y);
          const borderLocation = provider.borderLocation, minX = borderLocation.left + draggableWidth / 2, maxX = borderLocation.right - draggableWidth / 2, minY = borderLocation.top + draggableHeight / 2, maxY = borderLocation.bottom - draggableHeight / 2;
          releasedCenterX = Math.max(minX, Math.min(releasedCenterX, maxX)), releasedCenterY = Math.max(minY, Math.min(releasedCenterY, maxY));
          const areaCenters = getSnapAreaCenters(borderLocation);
          let minDist = Number.POSITIVE_INFINITY, closestArea = null, closestCenter = null;
          for (const area in provider.snapAreas)
            if (provider.snapAreas[area]) {
              const center = areaCenters[area];
              if (!center) continue;
              const dist = Math.hypot(
                center.x - releasedCenterX,
                center.y - releasedCenterY
              );
              dist < minDist && (minDist = dist, closestArea = area, closestCenter = center);
            }
          if (closestArea && closestCenter) {
            finalSnapArea = closestArea, setCurrentSnapArea(closestArea);
            const relX = (closestCenter.x - parentViewportLeft) / parentWidth, relY = (closestCenter.y - parentViewportTop) / parentHeight;
            persistedRelativeCenterRef.current = { x: relX, y: relY };
          } else {
            finalSnapArea = null, setCurrentSnapArea(null);
            const relX = (releasedCenterX - parentViewportLeft) / parentWidth, relY = (releasedCenterY - parentViewportTop) / parentHeight;
            persistedRelativeCenterRef.current = { x: relX, y: relY };
          }
        }
        isDraggingRef.current = !1, animationInProgressRef.current = !0, animationFrameRef.current = requestAnimationFrame(
          updateDraggablePosition
        ), setIsDragging(!1), onDragEnd && onDragEnd(finalSnapArea), (_a = latestProviderDataRef.current) != null && _a.emitDragEnd && latestProviderDataRef.current.emitDragEnd();
      }
      mouseDownPosRef.current = null, window.removeEventListener("mousemove", mouseMoveHandler, {
        capture: !0
      }), window.removeEventListener("mouseup", mouseUpHandler, {
        capture: !0
      }), movingElementRef.current && (movingElementRef.current.style.userSelect = ""), document.body.style.userSelect = "", document.body.style.cursor = "";
    },
    [onDragEnd, updateDraggablePosition]
  ), mouseMoveHandler = useCallback(
    (e2) => {
      var _a;
      if (!mouseDownPosRef.current) return;
      Math.hypot(
        e2.clientX - mouseDownPosRef.current.x,
        e2.clientY - mouseDownPosRef.current.y
      ) > startThreshold && !isDraggingRef.current && (isDraggingRef.current = !0, setIsDragging(!0), movingElementRef.current && (movingElementRef.current.style.userSelect = "none"), document.body.style.userSelect = "none", document.body.style.cursor = "grabbing", onDragStart && onDragStart(), (_a = latestProviderDataRef.current) != null && _a.emitDragStart && latestProviderDataRef.current.emitDragStart(), animationInProgressRef.current = !0, animationFrameRef.current = requestAnimationFrame(
        updateDraggablePosition
      )), currentMousePosRef.current = { x: e2.clientX, y: e2.clientY };
    },
    [startThreshold, onDragStart, updateDraggablePosition]
  ), mouseDownHandler = useCallback(
    (e2) => {
      if (e2.button !== 0)
        return;
      const handleNode = dragInitiatorRef.current, draggableItemNode = movingElementRef.current;
      if (handleNode) {
        if (!handleNode.contains(e2.target) && e2.target !== handleNode)
          return;
      } else if (draggableItemNode) {
        if (!draggableItemNode.contains(e2.target) && e2.target !== draggableItemNode)
          return;
      } else {
        console.error(
          "Draggable element or handle ref not set in mouseDownHandler"
        );
        return;
      }
      if (mouseDownPosRef.current = { x: e2.clientX, y: e2.clientY }, !movingElementRef.current) {
        console.error("Draggable element ref not set in mouseDownHandler");
        return;
      }
      const rect = movingElementRef.current.getBoundingClientRect(), currentDraggableCenterX = rect.left + rect.width / 2, currentDraggableCenterY = rect.top + rect.height / 2;
      mouseToDraggableCenterOffsetRef.current = {
        x: e2.clientX - currentDraggableCenterX,
        y: e2.clientY - currentDraggableCenterY
      }, window.addEventListener("mousemove", mouseMoveHandler, {
        capture: !0
      }), window.addEventListener("mouseup", mouseUpHandler, {
        capture: !0
      });
    },
    [mouseMoveHandler, mouseUpHandler]
  );
  useEffect(() => {
    const elementToListenOn = dragInitiatorNode || movingElementNode;
    return elementToListenOn && elementToListenOn.addEventListener("mousedown", mouseDownHandler), () => {
      elementToListenOn && elementToListenOn.removeEventListener("mousedown", mouseDownHandler), isDraggingRef.current && (onDragEnd && onDragEnd(currentSnapArea), isDraggingRef.current = !1, setIsDragging(!1), movingElementNode && (movingElementNode.style.userSelect = ""), document.body.style.userSelect = "", document.body.style.cursor = "");
    };
  }, [
    movingElementNode,
    dragInitiatorNode,
    mouseDownHandler,
    onDragEnd,
    mouseMoveHandler,
    mouseUpHandler,
    currentSnapArea
  ]), useEffect(() => {
    movingElementRef.current && providerData && providerData.borderLocation && // Needed for calculations within updateDraggablePosition
    persistedRelativeCenterRef.current && // Ensure we have a center to position to
    !isDraggingRef.current && // Not currently dragging
    !hasAnimatedOnceRef.current && requestAnimationFrame(() => {
      movingElementRef.current && updateDraggablePosition();
    });
  }, [
    movingElementNode,
    // Run when element is available/changes
    providerData,
    // Run if provider context changes (for borderLocation)
    config2.initialRelativeCenter,
    // If this changes, persistedRelativeCenterRef might be re-initialized
    initialSnapArea,
    // If this changes, an effect updates persistedRelativeCenterRef
    updateDraggablePosition
    // Memoized callback for positioning
    // hasAnimatedOnceRef is intentionally not a dep, its current value is checked inside.
  ]);
  const draggableRefCallback = useCallback((node2) => {
    setMovingElementNode(node2), movingElementRef.current = node2;
  }, []), handleRefCallback = useCallback((node2) => {
    setDragInitiatorNode(node2), dragInitiatorRef.current = node2;
  }, []);
  return {
    draggableRef: draggableRefCallback,
    handleRef: handleRefCallback,
    position: {
      snapArea: currentSnapArea,
      isTopHalf: persistedRelativeCenterRef.current ? persistedRelativeCenterRef.current.y <= 0.5 : !0,
      isLeftHalf: persistedRelativeCenterRef.current ? persistedRelativeCenterRef.current.x <= 0.5 : !0
    },
    wasDragged,
    isDragging
  };
}
const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < "u" ? React__default.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {
  const ref = useRef(null);
  return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    ref.current = fn;
  }, [
    fn
  ]), useCallback((...args) => {
    const f2 = ref.current;
    return f2 == null ? void 0 : f2(...args);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el == null ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
}, $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => el && "window" in el && el.window === el ? el : $431fbd86ca7dc216$export$b204af158042fbac(el).defaultView || window;
function $431fbd86ca7dc216$var$isNode(value) {
  return value !== null && typeof value == "object" && "nodeType" in value && typeof value.nodeType == "number";
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(node2) {
  return $431fbd86ca7dc216$var$isNode(node2) && node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in node2;
}
let $f4e2df6bd15f8569$var$_shadowDOM = !1;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
  return $f4e2df6bd15f8569$var$_shadowDOM;
}
function $d4ee10de306f2510$export$4282f70798064fe0(node2, otherNode) {
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return otherNode && node2 ? node2.contains(otherNode) : !1;
  if (!node2 || !otherNode) return !1;
  let currentNode = otherNode;
  for (; currentNode !== null; ) {
    if (currentNode === node2) return !0;
    currentNode.tagName === "SLOT" && currentNode.assignedSlot ? currentNode = currentNode.assignedSlot.parentNode : $431fbd86ca7dc216$export$af51f0f06c0f328a(currentNode) ? currentNode = currentNode.host : currentNode = currentNode.parentNode;
  }
  return !1;
}
const $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => {
  var _activeElement_shadowRoot;
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return doc.activeElement;
  let activeElement2 = doc.activeElement;
  for (; activeElement2 && "shadowRoot" in activeElement2 && (!((_activeElement_shadowRoot = activeElement2.shadowRoot) === null || _activeElement_shadowRoot === void 0) && _activeElement_shadowRoot.activeElement); ) activeElement2 = activeElement2.shadowRoot.activeElement;
  return activeElement2;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
  return $f4e2df6bd15f8569$export$98658e8c59125e6a() && event.target.shadowRoot && event.composedPath ? event.composedPath()[0] : event.target;
}
var define_process_env_default$4 = {};
function $c87311424ea30a05$var$testUserAgent(re2) {
  var _window_navigator_userAgentData;
  return typeof window > "u" || window.navigator == null ? !1 : ((_window_navigator_userAgentData = window.navigator.userAgentData) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re2.test(brand.brand))) || re2.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re2) {
  var _window_navigator_userAgentData;
  return typeof window < "u" && window.navigator != null ? re2.test(((_window_navigator_userAgentData = window.navigator.userAgentData) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : !1;
}
function $c87311424ea30a05$var$cached(fn) {
  if (define_process_env_default$4.NODE_ENV === "test") return fn;
  let res = null;
  return () => (res == null && (res = fn()), res);
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = useRef(/* @__PURE__ */ new Map()), addGlobalListener = useCallback((eventTarget, type, listener, options) => {
    let fn = options != null && options.once ? (...args) => {
      globalListeners.current.delete(listener), listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      fn,
      options
    }), eventTarget.addEventListener(type, fn, options);
  }, []), removeGlobalListener = useCallback((eventTarget, type, listener, options) => {
    var _globalListeners_current_get;
    let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type, fn, options), globalListeners.current.delete(listener);
  }, []), removeAllGlobalListeners = useCallback(() => {
    globalListeners.current.forEach((value, key) => {
      removeGlobalListener(value.eventTarget, value.type, key, value.options);
    });
  }, [
    removeGlobalListener
  ]);
  return useEffect(() => removeAllGlobalListeners, [
    removeAllGlobalListeners
  ]), {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}
function $6a7db85432448f7f$export$60278871457622de(event) {
  return event.mozInputSource === 0 && event.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType ? event.type === "click" && event.buttons === 1 : event.detail === 0 && !event.pointerType;
}
function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
  let event = nativeEvent;
  return event.nativeEvent = nativeEvent, event.isDefaultPrevented = () => event.defaultPrevented, event.isPropagationStopped = () => event.cancelBubble, event.persist = () => {
  }, event;
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {
  Object.defineProperty(event, "target", {
    value: target
  }), Object.defineProperty(event, "currentTarget", {
    value: target
  });
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = useRef({
    isFocused: !1,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const state = stateRef.current;
    return () => {
      state.observer && (state.observer.disconnect(), state.observer = null);
    };
  }, []);
  let dispatchBlur = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {
    onBlur == null || onBlur(e2);
  });
  return useCallback((e2) => {
    if (e2.target instanceof HTMLButtonElement || e2.target instanceof HTMLInputElement || e2.target instanceof HTMLTextAreaElement || e2.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = !0;
      let target = e2.target, onBlurHandler = (e3) => {
        if (stateRef.current.isFocused = !1, target.disabled) {
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e3);
          dispatchBlur(event);
        }
        stateRef.current.observer && (stateRef.current.observer.disconnect(), stateRef.current.observer = null);
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: !0
      }), stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 || _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          })), target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: relatedTargetEl
          }));
        }
      }), stateRef.current.observer.observe(target, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
let $8a9cb279dc87e130$export$fda7da73ab5d4c48 = !1;
var define_process_env_default$3 = {};
let $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: !0,
  Escape: !0
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e2) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e2);
}
function $507fabe10e71c6fb$var$isValidKey(e2) {
  return !(e2.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e2) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$isValidKey(e2) && ($507fabe10e71c6fb$var$currentModality = "keyboard", $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e2));
}
function $507fabe10e71c6fb$var$handlePointerEvent(e2) {
  $507fabe10e71c6fb$var$currentModality = "pointer", (e2.type === "mousedown" || e2.type === "pointerdown") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e2));
}
function $507fabe10e71c6fb$var$handleClickEvent(e2) {
  $6a7db85432448f7f$export$60278871457622de(e2) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = "virtual");
}
function $507fabe10e71c6fb$var$handleFocusEvent(e2) {
  e2.target === window || e2.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !e2.isTrusted || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = "virtual", $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e2)), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1);
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element2) {
  if (typeof window > "u" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element2))) return;
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element2), documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element2);
  let focus = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, focus.apply(this, arguments);
  }, documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : define_process_env_default$3.NODE_ENV === "test" && (documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element2);
  }, {
    once: !0
  }), $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element2, loadListener) => {
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element2), documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element2);
  loadListener && documentObject.removeEventListener("DOMContentLoaded", loadListener), $507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject) && (windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus, documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : define_process_env_default$3.NODE_ENV === "test" && (documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject));
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element2) {
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element2);
  let loadListener;
  return documentObject.readyState !== "loading" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(element2) : (loadListener = () => {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(element2);
  }, documentObject.addEventListener("DOMContentLoaded", loadListener)), () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element2, loadListener);
}
typeof document < "u" && $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e2) {
  let document1 = $431fbd86ca7dc216$export$b204af158042fbac(e2 == null ? void 0 : e2.target);
  const IHTMLInputElement = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLInputElement : HTMLInputElement, IHTMLTextAreaElement = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLTextAreaElement : HTMLTextAreaElement, IHTMLElement = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLElement : HTMLElement, IKeyboardEvent = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).KeyboardEvent : KeyboardEvent;
  return isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable, !(isTextInput && modality === "keyboard" && e2 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e2.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents(), useEffect(() => {
    let handler = (modality, e2) => {
      $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts != null && opts.isTextInput), modality, e2) && fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    return $507fabe10e71c6fb$var$changeHandlers.add(handler), () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = useCallback((e2) => {
    if (e2.target === e2.currentTarget)
      return onBlurProp && onBlurProp(e2), onFocusChange && onFocusChange(!1), !0;
  }, [
    onBlurProp,
    onFocusChange
  ]), onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur), onFocus = useCallback((e2) => {
    const ownerDocument2 = $431fbd86ca7dc216$export$b204af158042fbac(e2.target), activeElement2 = ownerDocument2 ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument2) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
    e2.target === e2.currentTarget && activeElement2 === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent) && (onFocusProp && onFocusProp(e2), onFocusChange && onFocusChange(!0), onSyntheticFocus(e2));
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props, state = useRef({
    isFocusWithin: !1
  }), { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6(), onBlur = useCallback((e2) => {
    e2.currentTarget.contains(e2.target) && state.current.isFocusWithin && !e2.currentTarget.contains(e2.relatedTarget) && (state.current.isFocusWithin = !1, removeAllGlobalListeners(), onBlurWithin && onBlurWithin(e2), onFocusWithinChange && onFocusWithinChange(!1));
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state,
    removeAllGlobalListeners
  ]), onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur), onFocus = useCallback((e2) => {
    if (!e2.currentTarget.contains(e2.target)) return;
    const ownerDocument2 = $431fbd86ca7dc216$export$b204af158042fbac(e2.target), activeElement2 = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument2);
    if (!state.current.isFocusWithin && activeElement2 === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      onFocusWithin && onFocusWithin(e2), onFocusWithinChange && onFocusWithinChange(!0), state.current.isFocusWithin = !0, onSyntheticFocus(e2);
      let currentTarget = e2.currentTarget;
      addGlobalListener(ownerDocument2, "focus", (e3) => {
        if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(currentTarget, e3.target)) {
          let nativeEvent = new ownerDocument2.defaultView.FocusEvent("blur", {
            relatedTarget: e3.target
          });
          $8a9cb279dc87e130$export$c2b7abe5d61ec696(nativeEvent, currentTarget);
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent);
          onBlur(event);
        }
      }, {
        capture: !0
      });
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus,
    addGlobalListener,
    onBlur
  ]);
  return isDisabled ? {
    focusWithinProps: {
      // These cannot be null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}
var define_process_env_default$2 = {};
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0, setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e2) {
  e2.pointerType === "touch" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : define_process_env_default$2.NODE_ENV === "test" && document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents), $6179b936705e76d3$var$hoverCount++, () => {
      $6179b936705e76d3$var$hoverCount--, !($6179b936705e76d3$var$hoverCount > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : define_process_env_default$2.NODE_ENV === "test" && document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents));
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props, [isHovered, setHovered] = useState(!1), state = useRef({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6(), { hoverProps, triggerHoverEnd } = useMemo(() => {
    let triggerHoverStart = (event, pointerType) => {
      if (state.pointerType = pointerType, isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
      state.isHovered = !0;
      let target = event.currentTarget;
      state.target = target, addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), "pointerover", (e2) => {
        state.isHovered && state.target && !$d4ee10de306f2510$export$4282f70798064fe0(state.target, e2.target) && triggerHoverEnd2(e2, e2.pointerType);
      }, {
        capture: !0
      }), onHoverStart && onHoverStart({
        type: "hoverstart",
        target,
        pointerType
      }), onHoverChange && onHoverChange(!0), setHovered(!0);
    }, triggerHoverEnd2 = (event, pointerType) => {
      let target = state.target;
      state.pointerType = "", state.target = null, !(pointerType === "touch" || !state.isHovered || !target) && (state.isHovered = !1, removeAllGlobalListeners(), onHoverEnd && onHoverEnd({
        type: "hoverend",
        target,
        pointerType
      }), onHoverChange && onHoverChange(!1), setHovered(!1));
    }, hoverProps2 = {};
    return typeof PointerEvent < "u" ? (hoverProps2.onPointerEnter = (e2) => {
      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e2.pointerType === "mouse" || triggerHoverStart(e2, e2.pointerType);
    }, hoverProps2.onPointerLeave = (e2) => {
      !isDisabled && e2.currentTarget.contains(e2.target) && triggerHoverEnd2(e2, e2.pointerType);
    }) : define_process_env_default$2.NODE_ENV === "test" && (hoverProps2.onTouchStart = () => {
      state.ignoreEmulatedMouseEvents = !0;
    }, hoverProps2.onMouseEnter = (e2) => {
      !state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && triggerHoverStart(e2, "mouse"), state.ignoreEmulatedMouseEvents = !1;
    }, hoverProps2.onMouseLeave = (e2) => {
      !isDisabled && e2.currentTarget.contains(e2.target) && triggerHoverEnd2(e2, "mouse");
    }), {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state,
    addGlobalListener,
    removeAllGlobalListeners
  ]);
  return useEffect(() => {
    isDisabled && triggerHoverEnd({
      currentTarget: state.target
    }, state.pointerType);
  }, [
    isDisabled
  ]), {
    hoverProps,
    isHovered
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = !1, isTextInput, within } = props, state = useRef({
    isFocused: !1,
    isFocusVisible: autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  }), [isFocused, setFocused] = useState(!1), [isFocusVisibleState, setFocusVisible] = useState(() => state.current.isFocused && state.current.isFocusVisible), updateState = useCallback(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []), onFocusChange = useCallback((isFocused2) => {
    state.current.isFocused = isFocused2, setFocused(isFocused2), updateState();
  }, [
    updateState
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible, updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: within,
    onFocusChange
  }), { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}
var i$6 = Object.defineProperty, d$3 = (t2, e2, n2) => e2 in t2 ? i$6(t2, e2, { enumerable: !0, configurable: !0, writable: !0, value: n2 }) : t2[e2] = n2, r$2 = (t2, e2, n2) => (d$3(t2, typeof e2 != "symbol" ? e2 + "" : e2, n2), n2);
let o$7 = class {
  constructor() {
    r$2(this, "current", this.detect()), r$2(this, "handoffState", "pending"), r$2(this, "currentId", 0);
  }
  set(e2) {
    this.current !== e2 && (this.handoffState = "pending", this.currentId = 0, this.current = e2);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$9 = new o$7();
function o$6(n2) {
  var e2, r2;
  return s$9.isServer ? null : n2 ? "ownerDocument" in n2 ? n2.ownerDocument : "current" in n2 ? (r2 = (e2 = n2.current) == null ? void 0 : e2.ownerDocument) != null ? r2 : document : null : document;
}
function t$4(e2) {
  typeof queueMicrotask == "function" ? queueMicrotask(e2) : Promise.resolve().then(e2).catch((o3) => setTimeout(() => {
    throw o3;
  }));
}
function o$5() {
  let n2 = [], r2 = { addEventListener(e2, t2, s2, a3) {
    return e2.addEventListener(t2, s2, a3), r2.add(() => e2.removeEventListener(t2, s2, a3));
  }, requestAnimationFrame(...e2) {
    let t2 = requestAnimationFrame(...e2);
    return r2.add(() => cancelAnimationFrame(t2));
  }, nextFrame(...e2) {
    return r2.requestAnimationFrame(() => r2.requestAnimationFrame(...e2));
  }, setTimeout(...e2) {
    let t2 = setTimeout(...e2);
    return r2.add(() => clearTimeout(t2));
  }, microTask(...e2) {
    let t2 = { current: !0 };
    return t$4(() => {
      t2.current && e2[0]();
    }), r2.add(() => {
      t2.current = !1;
    });
  }, style(e2, t2, s2) {
    let a3 = e2.style.getPropertyValue(t2);
    return Object.assign(e2.style, { [t2]: s2 }), this.add(() => {
      Object.assign(e2.style, { [t2]: a3 });
    });
  }, group(e2) {
    let t2 = o$5();
    return e2(t2), this.add(() => t2.dispose());
  }, add(e2) {
    return n2.includes(e2) || n2.push(e2), () => {
      let t2 = n2.indexOf(e2);
      if (t2 >= 0) for (let s2 of n2.splice(t2, 1)) s2();
    };
  }, dispose() {
    for (let e2 of n2.splice(0)) e2();
  } };
  return r2;
}
function p$2() {
  let [e2] = useState(o$5);
  return useEffect(() => () => e2.dispose(), [e2]), e2;
}
let n$3 = (e2, t2) => {
  s$9.isServer ? useEffect(e2, t2) : useLayoutEffect(e2, t2);
};
function s$8(e2) {
  let r2 = useRef(e2);
  return n$3(() => {
    r2.current = e2;
  }, [e2]), r2;
}
let o$4 = function(t2) {
  let e2 = s$8(t2);
  return React__default.useCallback((...r2) => e2.current(...r2), [e2]);
};
function E$2(e2) {
  let t2 = e2.width / 2, n2 = e2.height / 2;
  return { top: e2.clientY - n2, right: e2.clientX + t2, bottom: e2.clientY + n2, left: e2.clientX - t2 };
}
function P$3(e2, t2) {
  return !(!e2 || !t2 || e2.right < t2.left || e2.left > t2.right || e2.bottom < t2.top || e2.top > t2.bottom);
}
function w$3({ disabled: e2 = !1 } = {}) {
  let t2 = useRef(null), [n2, l2] = useState(!1), r2 = p$2(), o3 = o$4(() => {
    t2.current = null, l2(!1), r2.dispose();
  }), f2 = o$4((s2) => {
    if (r2.dispose(), t2.current === null) {
      t2.current = s2.currentTarget, l2(!0);
      {
        let i2 = o$6(s2.currentTarget);
        r2.addEventListener(i2, "pointerup", o3, !1), r2.addEventListener(i2, "pointermove", (c2) => {
          if (t2.current) {
            let p2 = E$2(c2);
            l2(P$3(p2, t2.current.getBoundingClientRect()));
          }
        }, !1), r2.addEventListener(i2, "pointercancel", o3, !1);
      }
    }
  });
  return { pressed: n2, pressProps: e2 ? {} : { onPointerDown: f2, onPointerUp: o3, onClick: o3 } };
}
let e$4 = createContext(void 0);
function a$d() {
  return useContext(e$4);
}
function t$3(...r2) {
  return Array.from(new Set(r2.flatMap((n2) => typeof n2 == "string" ? n2.split(" ") : []))).filter(Boolean).join(" ");
}
function u$8(r2, n2, ...a3) {
  if (r2 in n2) {
    let e2 = n2[r2];
    return typeof e2 == "function" ? e2(...a3) : e2;
  }
  let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e2) => `"${e2}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$8), t2;
}
var O$2 = ((a3) => (a3[a3.None = 0] = "None", a3[a3.RenderStrategy = 1] = "RenderStrategy", a3[a3.Static = 2] = "Static", a3))(O$2 || {}), A$1 = ((e2) => (e2[e2.Unmount = 0] = "Unmount", e2[e2.Hidden = 1] = "Hidden", e2))(A$1 || {});
function L$2() {
  let n2 = U$3();
  return useCallback((r2) => C$3({ mergeRefs: n2, ...r2 }), [n2]);
}
function C$3({ ourProps: n2, theirProps: r2, slot: e2, defaultTag: a3, features: s2, visible: t2 = !0, name: l2, mergeRefs: i2 }) {
  i2 = i2 ?? $;
  let o3 = P$2(r2, n2);
  if (t2) return F$4(o3, e2, a3, l2, i2);
  let y2 = s2 ?? 0;
  if (y2 & 2) {
    let { static: f2 = !1, ...u2 } = o3;
    if (f2) return F$4(u2, e2, a3, l2, i2);
  }
  if (y2 & 1) {
    let { unmount: f2 = !0, ...u2 } = o3;
    return u$8(f2 ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return F$4({ ...u2, hidden: !0, style: { display: "none" } }, e2, a3, l2, i2);
    } });
  }
  return F$4(o3, e2, a3, l2, i2);
}
function F$4(n2, r2 = {}, e2, a3, s2) {
  let { as: t2 = e2, children: l2, refName: i2 = "ref", ...o3 } = h$4(n2, ["unmount", "static"]), y2 = n2.ref !== void 0 ? { [i2]: n2.ref } : {}, f2 = typeof l2 == "function" ? l2(r2) : l2;
  "className" in o3 && o3.className && typeof o3.className == "function" && (o3.className = o3.className(r2)), o3["aria-labelledby"] && o3["aria-labelledby"] === o3.id && (o3["aria-labelledby"] = void 0);
  let u2 = {};
  if (r2) {
    let d2 = !1, p2 = [];
    for (let [c2, T2] of Object.entries(r2)) typeof T2 == "boolean" && (d2 = !0), T2 === !0 && p2.push(c2.replace(/([A-Z])/g, (g2) => `-${g2.toLowerCase()}`));
    if (d2) {
      u2["data-headlessui-state"] = p2.join(" ");
      for (let c2 of p2) u2[`data-${c2}`] = "";
    }
  }
  if (t2 === Fragment && (Object.keys(m$4(o3)).length > 0 || Object.keys(m$4(u2)).length > 0)) if (!isValidElement(f2) || Array.isArray(f2) && f2.length > 1) {
    if (Object.keys(m$4(o3)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${a3} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(o3)).concat(Object.keys(m$4(u2))).map((d2) => `  - ${d2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d2) => `  - ${d2}`).join(`
`)].join(`
`));
  } else {
    let d2 = f2.props, p2 = d2 == null ? void 0 : d2.className, c2 = typeof p2 == "function" ? (...R2) => t$3(p2(...R2), o3.className) : t$3(p2, o3.className), T2 = c2 ? { className: c2 } : {}, g2 = P$2(f2.props, m$4(h$4(o3, ["ref"])));
    for (let R2 in u2) R2 in g2 && delete u2[R2];
    return cloneElement(f2, Object.assign({}, g2, u2, y2, { ref: s2(H$6(f2), y2.ref) }, T2));
  }
  return createElement(t2, Object.assign({}, h$4(o3, ["ref"]), t2 !== Fragment && y2, t2 !== Fragment && u2), f2);
}
function U$3() {
  let n2 = useRef([]), r2 = useCallback((e2) => {
    for (let a3 of n2.current) a3 != null && (typeof a3 == "function" ? a3(e2) : a3.current = e2);
  }, []);
  return (...e2) => {
    if (!e2.every((a3) => a3 == null)) return n2.current = e2, r2;
  };
}
function $(...n2) {
  return n2.every((r2) => r2 == null) ? void 0 : (r2) => {
    for (let e2 of n2) e2 != null && (typeof e2 == "function" ? e2(r2) : e2.current = r2);
  };
}
function P$2(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  if (r2.disabled || r2["aria-disabled"]) for (let s2 in e2) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s2) && (e2[s2] = [(t2) => {
    var l2;
    return (l2 = t2 == null ? void 0 : t2.preventDefault) == null ? void 0 : l2.call(t2);
  }]);
  for (let s2 in e2) Object.assign(r2, { [s2](t2, ...l2) {
    let i2 = e2[s2];
    for (let o3 of i2) {
      if ((t2 instanceof Event || (t2 == null ? void 0 : t2.nativeEvent) instanceof Event) && t2.defaultPrevented) return;
      o3(t2, ...l2);
    }
  } });
  return r2;
}
function _$3(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  for (let s2 in e2) Object.assign(r2, { [s2](...t2) {
    let l2 = e2[s2];
    for (let i2 of l2) i2 == null || i2(...t2);
  } });
  return r2;
}
function K$1(n2) {
  var r2;
  return Object.assign(forwardRef(n2), { displayName: (r2 = n2.displayName) != null ? r2 : n2.name });
}
function m$4(n2) {
  let r2 = Object.assign({}, n2);
  for (let e2 in r2) r2[e2] === void 0 && delete r2[e2];
  return r2;
}
function h$4(n2, r2 = []) {
  let e2 = Object.assign({}, n2);
  for (let a3 of r2) a3 in e2 && delete e2[a3];
  return e2;
}
function H$6(n2) {
  return React__default.version.split(".")[0] >= "19" ? n2.props.ref : n2.ref;
}
let R$3 = "button";
function v$1(a3, u2) {
  var p2;
  let l2 = a$d(), { disabled: e2 = l2 || !1, autoFocus: t2 = !1, ...o3 } = a3, { isFocusVisible: r2, focusProps: i2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: t2 }), { isHovered: s2, hoverProps: T2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e2 }), { pressed: n2, pressProps: d2 } = w$3({ disabled: e2 }), f2 = _$3({ ref: u2, type: (p2 = o3.type) != null ? p2 : "button", disabled: e2 || void 0, autoFocus: t2 }, i2, T2, d2), m2 = useMemo(() => ({ disabled: e2, hover: s2, focus: r2, active: n2, autofocus: t2 }), [e2, s2, r2, n2, t2]);
  return L$2()({ ourProps: f2, theirProps: o3, slot: m2, defaultTag: R$3, name: "Button" });
}
let H$5 = K$1(v$1), a$c = "span";
var s$7 = ((e2) => (e2[e2.None = 1] = "None", e2[e2.Focusable = 2] = "Focusable", e2[e2.Hidden = 4] = "Hidden", e2))(s$7 || {});
function l$3(t2, r2) {
  var n2;
  let { features: d2 = 1, ...e2 } = t2, o3 = { ref: r2, "aria-hidden": (d2 & 2) === 2 ? !0 : (n2 = e2["aria-hidden"]) != null ? n2 : void 0, hidden: (d2 & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(d2 & 4) === 4 && (d2 & 2) !== 2 && { display: "none" } } };
  return L$2()({ ourProps: o3, theirProps: e2, slot: {}, defaultTag: a$c, name: "Hidden" });
}
let f$8 = K$1(l$3), e$3 = createContext(void 0);
function u$7() {
  return useContext(e$3);
}
function r$1(n2) {
  let e2 = n2.parentElement, l2 = null;
  for (; e2 && !(e2 instanceof HTMLFieldSetElement); ) e2 instanceof HTMLLegendElement && (l2 = e2), e2 = e2.parentElement;
  let t2 = (e2 == null ? void 0 : e2.getAttribute("disabled")) === "";
  return t2 && i$5(l2) ? !1 : t2;
}
function i$5(n2) {
  if (!n2) return !1;
  let e2 = n2.previousElementSibling;
  for (; e2 !== null; ) {
    if (e2 instanceof HTMLLegendElement) return !1;
    e2 = e2.previousElementSibling;
  }
  return !0;
}
let u$6 = Symbol();
function T$3(t2, n2 = !0) {
  return Object.assign(t2, { [u$6]: n2 });
}
function y$4(...t2) {
  let n2 = useRef(t2);
  useEffect(() => {
    n2.current = t2;
  }, [t2]);
  let c2 = o$4((e2) => {
    for (let o3 of n2.current) o3 != null && (typeof o3 == "function" ? o3(e2) : o3.current = e2);
  });
  return t2.every((e2) => e2 == null || (e2 == null ? void 0 : e2[u$6])) ? void 0 : c2;
}
let a$b = createContext(null);
a$b.displayName = "DescriptionContext";
function f$7() {
  let r2 = useContext(a$b);
  if (r2 === null) {
    let e2 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(e2, f$7), e2;
  }
  return r2;
}
function U$2() {
  var r2, e2;
  return (e2 = (r2 = useContext(a$b)) == null ? void 0 : r2.value) != null ? e2 : void 0;
}
function w$2() {
  let [r2, e2] = useState([]);
  return [r2.length > 0 ? r2.join(" ") : void 0, useMemo(() => function(t2) {
    let i2 = o$4((n2) => (e2((s2) => [...s2, n2]), () => e2((s2) => {
      let o3 = s2.slice(), p2 = o3.indexOf(n2);
      return p2 !== -1 && o3.splice(p2, 1), o3;
    }))), l2 = useMemo(() => ({ register: i2, slot: t2.slot, name: t2.name, props: t2.props, value: t2.value }), [i2, t2.slot, t2.name, t2.props, t2.value]);
    return React__default.createElement(a$b.Provider, { value: l2 }, t2.children);
  }, [e2])];
}
let S$4 = "p";
function C$2(r2, e2) {
  let d2 = useId$2(), t2 = a$d(), { id: i2 = `headlessui-description-${d2}`, ...l2 } = r2, n2 = f$7(), s2 = y$4(e2);
  n$3(() => n2.register(i2), [i2, n2.register]);
  let o3 = t2 || !1, p2 = useMemo(() => ({ ...n2.slot, disabled: o3 }), [n2.slot, o3]), D2 = { ref: s2, ...n2.props, id: i2 };
  return L$2()({ ourProps: D2, theirProps: l2, slot: p2, defaultTag: S$4, name: n2.name || "Description" });
}
let _$2 = K$1(C$2);
Object.assign(_$2, {});
var o$3 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(o$3 || {});
let c$5 = createContext(null);
c$5.displayName = "LabelContext";
function P$1() {
  let r2 = useContext(c$5);
  if (r2 === null) {
    let l2 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(l2, P$1), l2;
  }
  return r2;
}
function I$2(r2) {
  var a3, e2, o3;
  let l2 = (e2 = (a3 = useContext(c$5)) == null ? void 0 : a3.value) != null ? e2 : void 0;
  return ((o3 = void 0) != null ? o3 : 0) > 0 ? [l2, ...r2].filter(Boolean).join(" ") : l2;
}
function K({ inherit: r2 = !1 } = {}) {
  let l2 = I$2(), [a3, e2] = useState([]), o3 = r2 ? [l2, ...a3].filter(Boolean) : a3;
  return [o3.length > 0 ? o3.join(" ") : void 0, useMemo(() => function(t2) {
    let s2 = o$4((i2) => (e2((p2) => [...p2, i2]), () => e2((p2) => {
      let u2 = p2.slice(), d2 = u2.indexOf(i2);
      return d2 !== -1 && u2.splice(d2, 1), u2;
    }))), m2 = useMemo(() => ({ register: s2, slot: t2.slot, name: t2.name, props: t2.props, value: t2.value }), [s2, t2.slot, t2.name, t2.props, t2.value]);
    return React__default.createElement(c$5.Provider, { value: m2 }, t2.children);
  }, [e2])];
}
let N = "label";
function G$1(r2, l2) {
  var y2;
  let a3 = useId$2(), e2 = P$1(), o3 = u$7(), g2 = a$d(), { id: t2 = `headlessui-label-${a3}`, htmlFor: s2 = o3 ?? ((y2 = e2.props) == null ? void 0 : y2.htmlFor), passive: m2 = !1, ...i2 } = r2, p2 = y$4(l2);
  n$3(() => e2.register(t2), [t2, e2.register]);
  let u2 = o$4((L2) => {
    let b2 = L2.currentTarget;
    if (b2 instanceof HTMLLabelElement && L2.preventDefault(), e2.props && "onClick" in e2.props && typeof e2.props.onClick == "function" && e2.props.onClick(L2), b2 instanceof HTMLLabelElement) {
      let n2 = document.getElementById(b2.htmlFor);
      if (n2) {
        let E2 = n2.getAttribute("disabled");
        if (E2 === "true" || E2 === "") return;
        let x2 = n2.getAttribute("aria-disabled");
        if (x2 === "true" || x2 === "") return;
        (n2 instanceof HTMLInputElement && (n2.type === "radio" || n2.type === "checkbox") || n2.role === "radio" || n2.role === "checkbox" || n2.role === "switch") && n2.click(), n2.focus({ preventScroll: !0 });
      }
    }
  }), d2 = g2 || !1, C2 = useMemo(() => ({ ...e2.slot, disabled: d2 }), [e2.slot, d2]), f2 = { ref: p2, ...e2.props, id: t2, htmlFor: s2, onClick: u2 };
  return m2 && ("onClick" in f2 && (delete f2.htmlFor, delete f2.onClick), "onClick" in i2 && delete i2.onClick), L$2()({ ourProps: f2, theirProps: i2, slot: C2, defaultTag: s2 ? N : "div", name: e2.name || "Label" });
}
let U$1 = K$1(G$1);
Object.assign(U$1, {});
let e$2 = createContext(() => {
});
function C$1({ value: t2, children: o3 }) {
  return React__default.createElement(e$2.Provider, { value: t2 }, o3);
}
function f$6(e2) {
  if (e2 === null) return { width: 0, height: 0 };
  let { width: t2, height: r2 } = e2.getBoundingClientRect();
  return { width: t2, height: r2 };
}
function d$2(e2, t2 = !1) {
  let [r2, u2] = useReducer(() => ({}), {}), i2 = useMemo(() => f$6(e2), [e2, r2]);
  return n$3(() => {
    if (!e2) return;
    let n2 = new ResizeObserver(u2);
    return n2.observe(e2), () => {
      n2.disconnect();
    };
  }, [e2]), t2 ? { width: `${i2.width}px`, height: `${i2.height}px` } : i2;
}
let a$a = class extends Map {
  constructor(t2) {
    super(), this.factory = t2;
  }
  get(t2) {
    let e2 = super.get(t2);
    return e2 === void 0 && (e2 = this.factory(t2), this.set(t2, e2)), e2;
  }
};
function a$9(o3, r2) {
  let t2 = o3(), n2 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t2;
  }, subscribe(e2) {
    return n2.add(e2), () => n2.delete(e2);
  }, dispatch(e2, ...s2) {
    let i2 = r2[e2].call(t2, ...s2);
    i2 && (t2 = i2, n2.forEach((c2) => c2()));
  } };
}
function o$2(t2) {
  return useSyncExternalStore(t2.subscribe, t2.getSnapshot, t2.getSnapshot);
}
let p$1 = new a$a(() => a$9(() => [], { ADD(r2) {
  return this.includes(r2) ? this : [...this, r2];
}, REMOVE(r2) {
  let e2 = this.indexOf(r2);
  if (e2 === -1) return this;
  let t2 = this.slice();
  return t2.splice(e2, 1), t2;
} }));
function x$2(r2, e2) {
  let t2 = p$1.get(e2), i2 = useId$2(), h2 = o$2(t2);
  if (n$3(() => {
    if (r2) return t2.dispatch("ADD", i2), () => t2.dispatch("REMOVE", i2);
  }, [t2, r2]), !r2) return !1;
  let s2 = h2.indexOf(i2), o3 = h2.length;
  return s2 === -1 && (s2 = o3, o3 += 1), s2 === o3 - 1;
}
let f$5 = /* @__PURE__ */ new Map(), u$5 = /* @__PURE__ */ new Map();
function h$3(t2) {
  var e2;
  let r2 = (e2 = u$5.get(t2)) != null ? e2 : 0;
  return u$5.set(t2, r2 + 1), r2 !== 0 ? () => m$3(t2) : (f$5.set(t2, { "aria-hidden": t2.getAttribute("aria-hidden"), inert: t2.inert }), t2.setAttribute("aria-hidden", "true"), t2.inert = !0, () => m$3(t2));
}
function m$3(t2) {
  var i2;
  let r2 = (i2 = u$5.get(t2)) != null ? i2 : 1;
  if (r2 === 1 ? u$5.delete(t2) : u$5.set(t2, r2 - 1), r2 !== 1) return;
  let e2 = f$5.get(t2);
  e2 && (e2["aria-hidden"] === null ? t2.removeAttribute("aria-hidden") : t2.setAttribute("aria-hidden", e2["aria-hidden"]), t2.inert = e2.inert, f$5.delete(t2));
}
function y$3(t2, { allowed: r2, disallowed: e2 } = {}) {
  let i2 = x$2(t2, "inert-others");
  n$3(() => {
    var d2, c2;
    if (!i2) return;
    let a3 = o$5();
    for (let n2 of (d2 = e2 == null ? void 0 : e2()) != null ? d2 : []) n2 && a3.add(h$3(n2));
    let s2 = (c2 = r2 == null ? void 0 : r2()) != null ? c2 : [];
    for (let n2 of s2) {
      if (!n2) continue;
      let l2 = o$6(n2);
      if (!l2) continue;
      let o3 = n2.parentElement;
      for (; o3 && o3 !== l2.body; ) {
        for (let p2 of o3.children) s2.some((E2) => p2.contains(E2)) || a3.add(h$3(p2));
        o3 = o3.parentElement;
      }
    }
    return a3.dispose;
  }, [i2, r2, e2]);
}
function m$2(s2, n2, l2) {
  let i2 = s$8((t2) => {
    let e2 = t2.getBoundingClientRect();
    e2.x === 0 && e2.y === 0 && e2.width === 0 && e2.height === 0 && l2();
  });
  useEffect(() => {
    if (!s2) return;
    let t2 = n2 === null ? null : n2 instanceof HTMLElement ? n2 : n2.current;
    if (!t2) return;
    let e2 = o$5();
    if (typeof ResizeObserver < "u") {
      let r2 = new ResizeObserver(() => i2.current(t2));
      r2.observe(t2), e2.add(() => r2.disconnect());
    }
    if (typeof IntersectionObserver < "u") {
      let r2 = new IntersectionObserver(() => i2.current(t2));
      r2.observe(t2), e2.add(() => r2.disconnect());
    }
    return () => e2.dispose();
  }, [n2, i2, s2]);
}
let f$4 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e2) => `${e2}:not([tabindex='-1'])`).join(","), p = ["[data-autofocus]"].map((e2) => `${e2}:not([tabindex='-1'])`).join(",");
var F$3 = ((n2) => (n2[n2.First = 1] = "First", n2[n2.Previous = 2] = "Previous", n2[n2.Next = 4] = "Next", n2[n2.Last = 8] = "Last", n2[n2.WrapAround = 16] = "WrapAround", n2[n2.NoScroll = 32] = "NoScroll", n2[n2.AutoFocus = 64] = "AutoFocus", n2))(F$3 || {}), T$2 = ((o3) => (o3[o3.Error = 0] = "Error", o3[o3.Overflow = 1] = "Overflow", o3[o3.Success = 2] = "Success", o3[o3.Underflow = 3] = "Underflow", o3))(T$2 || {}), y$2 = ((t2) => (t2[t2.Previous = -1] = "Previous", t2[t2.Next = 1] = "Next", t2))(y$2 || {});
function b$3(e2 = document.body) {
  return e2 == null ? [] : Array.from(e2.querySelectorAll(f$4)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S$3(e2 = document.body) {
  return e2 == null ? [] : Array.from(e2.querySelectorAll(p)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$2 = ((t2) => (t2[t2.Strict = 0] = "Strict", t2[t2.Loose = 1] = "Loose", t2))(h$2 || {});
function A(e2, r2 = 0) {
  var t2;
  return e2 === ((t2 = o$6(e2)) == null ? void 0 : t2.body) ? !1 : u$8(r2, { 0() {
    return e2.matches(f$4);
  }, 1() {
    let u2 = e2;
    for (; u2 !== null; ) {
      if (u2.matches(f$4)) return !0;
      u2 = u2.parentElement;
    }
    return !1;
  } });
}
function G(e2) {
  let r2 = o$6(e2);
  o$5().nextFrame(() => {
    r2 && !A(r2.activeElement, 0) && I$1(e2);
  });
}
var H$4 = ((t2) => (t2[t2.Keyboard = 0] = "Keyboard", t2[t2.Mouse = 1] = "Mouse", t2))(H$4 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (e2) => {
  e2.metaKey || e2.altKey || e2.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (e2) => {
  e2.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e2.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function I$1(e2) {
  e2 == null || e2.focus({ preventScroll: !0 });
}
let w$1 = ["textarea", "input"].join(",");
function O$1(e2) {
  var r2, t2;
  return (t2 = (r2 = e2 == null ? void 0 : e2.matches) == null ? void 0 : r2.call(e2, w$1)) != null ? t2 : !1;
}
function _$1(e2, r2 = (t2) => t2) {
  return e2.slice().sort((t2, u2) => {
    let o3 = r2(t2), c2 = r2(u2);
    if (o3 === null || c2 === null) return 0;
    let l2 = o3.compareDocumentPosition(c2);
    return l2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : l2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j$2(e2, r2) {
  return P(b$3(), r2, { relativeTo: e2 });
}
function P(e2, r2, { sorted: t2 = !0, relativeTo: u2 = null, skipElements: o3 = [] } = {}) {
  let c2 = Array.isArray(e2) ? e2.length > 0 ? e2[0].ownerDocument : document : e2.ownerDocument, l2 = Array.isArray(e2) ? t2 ? _$1(e2) : e2 : r2 & 64 ? S$3(e2) : b$3(e2);
  o3.length > 0 && l2.length > 1 && (l2 = l2.filter((s2) => !o3.some((a3) => a3 != null && "current" in a3 ? (a3 == null ? void 0 : a3.current) === s2 : a3 === s2))), u2 = u2 ?? c2.activeElement;
  let n2 = (() => {
    if (r2 & 5) return 1;
    if (r2 & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x2 = (() => {
    if (r2 & 1) return 0;
    if (r2 & 2) return Math.max(0, l2.indexOf(u2)) - 1;
    if (r2 & 4) return Math.max(0, l2.indexOf(u2)) + 1;
    if (r2 & 8) return l2.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), M2 = r2 & 32 ? { preventScroll: !0 } : {}, m2 = 0, d2 = l2.length, i2;
  do {
    if (m2 >= d2 || m2 + d2 <= 0) return 0;
    let s2 = x2 + m2;
    if (r2 & 16) s2 = (s2 + d2) % d2;
    else {
      if (s2 < 0) return 3;
      if (s2 >= d2) return 1;
    }
    i2 = l2[s2], i2 == null || i2.focus(M2), m2 += n2;
  } while (i2 !== c2.activeElement);
  return r2 & 6 && O$1(i2) && i2.select(), 2;
}
function t$2() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$4() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$2() {
  return t$2() || i$4();
}
function i$3(t2, e2, o3, n2) {
  let u2 = s$8(o3);
  useEffect(() => {
    if (!t2) return;
    function r2(m2) {
      u2.current(m2);
    }
    return document.addEventListener(e2, r2, n2), () => document.removeEventListener(e2, r2, n2);
  }, [t2, e2, n2]);
}
function s$6(t2, e2, o3, n2) {
  let i2 = s$8(o3);
  useEffect(() => {
    if (!t2) return;
    function r2(d2) {
      i2.current(d2);
    }
    return window.addEventListener(e2, r2, n2), () => window.removeEventListener(e2, r2, n2);
  }, [t2, e2, n2]);
}
const E$1 = 30;
function R$2(p2, f2, C2) {
  let u2 = x$2(p2, "outside-click"), m2 = s$8(C2), s2 = useCallback(function(e2, n2) {
    if (e2.defaultPrevented) return;
    let r2 = n2(e2);
    if (r2 === null || !r2.getRootNode().contains(r2) || !r2.isConnected) return;
    let h2 = (function l2(o3) {
      return typeof o3 == "function" ? l2(o3()) : Array.isArray(o3) || o3 instanceof Set ? o3 : [o3];
    })(f2);
    for (let l2 of h2) if (l2 !== null && (l2.contains(r2) || e2.composed && e2.composedPath().includes(l2))) return;
    return !A(r2, h$2.Loose) && r2.tabIndex !== -1 && e2.preventDefault(), m2.current(e2, r2);
  }, [m2, f2]), i2 = useRef(null);
  i$3(u2, "pointerdown", (t2) => {
    var e2, n2;
    i2.current = ((n2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : n2[0]) || t2.target;
  }, !0), i$3(u2, "mousedown", (t2) => {
    var e2, n2;
    i2.current = ((n2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : n2[0]) || t2.target;
  }, !0), i$3(u2, "click", (t2) => {
    n$2() || i2.current && (s2(t2, () => i2.current), i2.current = null);
  }, !0);
  let a3 = useRef({ x: 0, y: 0 });
  i$3(u2, "touchstart", (t2) => {
    a3.current.x = t2.touches[0].clientX, a3.current.y = t2.touches[0].clientY;
  }, !0), i$3(u2, "touchend", (t2) => {
    let e2 = { x: t2.changedTouches[0].clientX, y: t2.changedTouches[0].clientY };
    if (!(Math.abs(e2.x - a3.current.x) >= E$1 || Math.abs(e2.y - a3.current.y) >= E$1)) return s2(t2, () => t2.target instanceof HTMLElement ? t2.target : null);
  }, !0), s$6(u2, "blur", (t2) => s2(t2, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$1(...e2) {
  return useMemo(() => o$6(...e2), [...e2]);
}
function E(n2, e2, a3, t2) {
  let i2 = s$8(a3);
  useEffect(() => {
    n2 = n2 ?? window;
    function r2(o3) {
      i2.current(o3);
    }
    return n2.addEventListener(e2, r2, t2), () => n2.removeEventListener(e2, r2, t2);
  }, [n2, e2, t2]);
}
function e$1(t2, u2) {
  return useMemo(() => {
    var n2;
    if (t2.type) return t2.type;
    let r2 = (n2 = t2.as) != null ? n2 : "button";
    if (typeof r2 == "string" && r2.toLowerCase() === "button" || (u2 == null ? void 0 : u2.tagName) === "BUTTON" && !u2.hasAttribute("type")) return "button";
  }, [t2.type, t2.as, u2]);
}
function d$1() {
  let r2;
  return { before({ doc: e2 }) {
    var l2;
    let o3 = e2.documentElement, t2 = (l2 = e2.defaultView) != null ? l2 : window;
    r2 = Math.max(0, t2.innerWidth - o3.clientWidth);
  }, after({ doc: e2, d: o3 }) {
    let t2 = e2.documentElement, l2 = Math.max(0, t2.clientWidth - t2.offsetWidth), n2 = Math.max(0, r2 - l2);
    o3.style(t2, "paddingRight", `${n2}px`);
  } };
}
function d() {
  return t$2() ? { before({ doc: r2, d: n2, meta: c2 }) {
    function o3(a3) {
      return c2.containers.flatMap((l2) => l2()).some((l2) => l2.contains(a3));
    }
    n2.microTask(() => {
      var s2;
      if (window.getComputedStyle(r2.documentElement).scrollBehavior !== "auto") {
        let t2 = o$5();
        t2.style(r2.documentElement, "scrollBehavior", "auto"), n2.add(() => n2.microTask(() => t2.dispose()));
      }
      let a3 = (s2 = window.scrollY) != null ? s2 : window.pageYOffset, l2 = null;
      n2.addEventListener(r2, "click", (t2) => {
        if (t2.target instanceof HTMLElement) try {
          let e2 = t2.target.closest("a");
          if (!e2) return;
          let { hash: f2 } = new URL(e2.href), i2 = r2.querySelector(f2);
          i2 && !o3(i2) && (l2 = i2);
        } catch {
        }
      }, !0), n2.addEventListener(r2, "touchstart", (t2) => {
        if (t2.target instanceof HTMLElement) if (o3(t2.target)) {
          let e2 = t2.target;
          for (; e2.parentElement && o3(e2.parentElement); ) e2 = e2.parentElement;
          n2.style(e2, "overscrollBehavior", "contain");
        } else n2.style(t2.target, "touchAction", "none");
      }), n2.addEventListener(r2, "touchmove", (t2) => {
        if (t2.target instanceof HTMLElement) {
          if (t2.target.tagName === "INPUT") return;
          if (o3(t2.target)) {
            let e2 = t2.target;
            for (; e2.parentElement && e2.dataset.headlessuiPortal !== "" && !(e2.scrollHeight > e2.clientHeight || e2.scrollWidth > e2.clientWidth); ) e2 = e2.parentElement;
            e2.dataset.headlessuiPortal === "" && t2.preventDefault();
          } else t2.preventDefault();
        }
      }, { passive: !1 }), n2.add(() => {
        var e2;
        let t2 = (e2 = window.scrollY) != null ? e2 : window.pageYOffset;
        a3 !== t2 && window.scrollTo(0, a3), l2 && l2.isConnected && (l2.scrollIntoView({ block: "nearest" }), l2 = null);
      });
    });
  } } : {};
}
function r() {
  return { before({ doc: e2, d: o3 }) {
    o3.style(e2.documentElement, "overflow", "hidden");
  } };
}
function m$1(e2) {
  let n2 = {};
  for (let t2 of e2) Object.assign(n2, t2(n2));
  return n2;
}
let a$8 = a$9(() => /* @__PURE__ */ new Map(), { PUSH(e2, n2) {
  var o3;
  let t2 = (o3 = this.get(e2)) != null ? o3 : { doc: e2, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return t2.count++, t2.meta.add(n2), this.set(e2, t2), this;
}, POP(e2, n2) {
  let t2 = this.get(e2);
  return t2 && (t2.count--, t2.meta.delete(n2)), this;
}, SCROLL_PREVENT({ doc: e2, d: n2, meta: t2 }) {
  let o3 = { doc: e2, d: n2, meta: m$1(t2) }, c2 = [d(), d$1(), r()];
  c2.forEach(({ before: r2 }) => r2 == null ? void 0 : r2(o3)), c2.forEach(({ after: r2 }) => r2 == null ? void 0 : r2(o3));
}, SCROLL_ALLOW({ d: e2 }) {
  e2.dispose();
}, TEARDOWN({ doc: e2 }) {
  this.delete(e2);
} });
a$8.subscribe(() => {
  let e2 = a$8.getSnapshot(), n2 = /* @__PURE__ */ new Map();
  for (let [t2] of e2) n2.set(t2, t2.documentElement.style.overflow);
  for (let t2 of e2.values()) {
    let o3 = n2.get(t2.doc) === "hidden", c2 = t2.count !== 0;
    (c2 && !o3 || !c2 && o3) && a$8.dispatch(t2.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t2), t2.count === 0 && a$8.dispatch("TEARDOWN", t2);
  }
});
function a$7(r2, e2, n2 = () => ({ containers: [] })) {
  let f2 = o$2(a$8), o3 = e2 ? f2.get(e2) : void 0, i2 = o3 ? o3.count > 0 : !1;
  return n$3(() => {
    if (!(!e2 || !r2)) return a$8.dispatch("PUSH", e2, n2), () => a$8.dispatch("POP", e2, n2);
  }, [r2, e2]), i2;
}
function f$3(e2, c2, n2 = () => [document.body]) {
  let r2 = x$2(e2, "scroll-lock");
  a$7(r2, c2, (t2) => {
    var o3;
    return { containers: [...(o3 = t2.containers) != null ? o3 : [], n2] };
  });
}
function t$1(e2) {
  return [e2.screenX, e2.screenY];
}
function u$4() {
  let e2 = useRef([-1, -1]);
  return { wasMoved(r2) {
    let n2 = t$1(r2);
    return e2.current[0] === n2[0] && e2.current[1] === n2[1] ? !1 : (e2.current = n2, !0);
  }, update(r2) {
    e2.current = t$1(r2);
  } };
}
function c$4(u2 = 0) {
  let [t2, l2] = useState(u2), g2 = useCallback((e2) => l2(e2), [t2]), s2 = useCallback((e2) => l2((a3) => a3 | e2), [t2]), m2 = useCallback((e2) => (t2 & e2) === e2, [t2]), n2 = useCallback((e2) => l2((a3) => a3 & ~e2), [l2]), F2 = useCallback((e2) => l2((a3) => a3 ^ e2), [l2]);
  return { flags: t2, setFlag: g2, addFlag: s2, hasFlag: m2, removeFlag: n2, toggleFlag: F2 };
}
var define_process_env_default$1 = {}, T$1, b$2;
typeof process < "u" && typeof globalThis < "u" && typeof Element < "u" && ((T$1 = process == null ? void 0 : define_process_env_default$1) == null ? void 0 : T$1.NODE_ENV) === "test" && typeof ((b$2 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$2.getAnimations) > "u" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L$1 = ((r2) => (r2[r2.None = 0] = "None", r2[r2.Closed = 1] = "Closed", r2[r2.Enter = 2] = "Enter", r2[r2.Leave = 4] = "Leave", r2))(L$1 || {});
function R$1(t2) {
  let n2 = {};
  for (let e2 in t2) t2[e2] === !0 && (n2[`data-${e2}`] = "");
  return n2;
}
function x$1(t2, n2, e2, i2) {
  let [r2, o3] = useState(e2), { hasFlag: s2, addFlag: a3, removeFlag: l2 } = c$4(t2 && r2 ? 3 : 0), u2 = useRef(!1), f2 = useRef(!1), E2 = p$2();
  return n$3(() => {
    var d2;
    if (t2) {
      if (e2 && o3(!0), !n2) {
        e2 && a3(3);
        return;
      }
      return (d2 = i2 == null ? void 0 : i2.start) == null || d2.call(i2, e2), C(n2, { inFlight: u2, prepare() {
        f2.current ? f2.current = !1 : f2.current = u2.current, u2.current = !0, !f2.current && (e2 ? (a3(3), l2(4)) : (a3(4), l2(2)));
      }, run() {
        f2.current ? e2 ? (l2(3), a3(4)) : (l2(4), a3(3)) : e2 ? l2(1) : a3(1);
      }, done() {
        var p2;
        f2.current && typeof n2.getAnimations == "function" && n2.getAnimations().length > 0 || (u2.current = !1, l2(7), e2 || o3(!1), (p2 = i2 == null ? void 0 : i2.end) == null || p2.call(i2, e2));
      } });
    }
  }, [t2, e2, n2, E2]), t2 ? [r2, { closed: s2(1), enter: s2(2), leave: s2(4), transition: s2(2) || s2(4) }] : [e2, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C(t2, { prepare: n2, run: e2, done: i2, inFlight: r2 }) {
  let o3 = o$5();
  return j$1(t2, { prepare: n2, inFlight: r2 }), o3.nextFrame(() => {
    e2(), o3.requestAnimationFrame(() => {
      o3.add(M$4(t2, i2));
    });
  }), o3.dispose;
}
function M$4(t2, n2) {
  var o3, s2;
  let e2 = o$5();
  if (!t2) return e2.dispose;
  let i2 = !1;
  e2.add(() => {
    i2 = !0;
  });
  let r2 = (s2 = (o3 = t2.getAnimations) == null ? void 0 : o3.call(t2).filter((a3) => a3 instanceof CSSTransition)) != null ? s2 : [];
  return r2.length === 0 ? (n2(), e2.dispose) : (Promise.allSettled(r2.map((a3) => a3.finished)).then(() => {
    i2 || n2();
  }), e2.dispose);
}
function j$1(t2, { inFlight: n2, prepare: e2 }) {
  if (n2 != null && n2.current) {
    e2();
    return;
  }
  let i2 = t2.style.transition;
  t2.style.transition = "none", e2(), t2.offsetHeight, t2.style.transition = i2;
}
function F$2(c2, { container: e2, accept: t2, walk: r2 }) {
  let o3 = useRef(t2), l2 = useRef(r2);
  useEffect(() => {
    o3.current = t2, l2.current = r2;
  }, [t2, r2]), n$3(() => {
    if (!e2 || !c2) return;
    let n2 = o$6(e2);
    if (!n2) return;
    let f2 = o3.current, p2 = l2.current, i2 = Object.assign((m2) => f2(m2), { acceptNode: f2 }), u2 = n2.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, i2, !1);
    for (; u2.nextNode(); ) p2(u2.currentNode);
  }, [e2, c2, o3, l2]);
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map((_ref) => {
    let {
      brand,
      version
    } = _ref;
    return brand + "/" + version;
  }).join(" ") : navigator.userAgent;
}
var define_process_env_default = {};
const SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
    if (define_process_env_default.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return useSafeInsertionEffect(() => {
    ref.current = callback;
  }), React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index$1(() => {
    id == null && setId(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), id;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
let devMessageSet;
define_process_env_default.NODE_ENV !== "production" && (devMessageSet = /* @__PURE__ */ new Set());
function warn() {
  for (var _devMessageSet, _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++)
    messages[_key] = arguments[_key];
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message), console.warn(message);
  }
}
function error() {
  for (var _devMessageSet3, _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
    messages[_key2] = arguments[_key2];
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message), console.error(message);
  }
}
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext), FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(options) {
  const {
    open = !1,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options, floatingId = useId(), dataRef = React.useRef({}), [events] = React.useState(() => createPubSub()), nested = useFloatingParentNodeId() != null;
  if (define_process_env_default.NODE_ENV !== "production") {
    const optionDomReference = elementsProp.reference;
    optionDomReference && !isElement(optionDomReference) && error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0, events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    }), onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  }), refs = React.useMemo(() => ({
    setPositionReference
  }), []), elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  options === void 0 && (options = {});
  const {
    nodeId
  } = options, internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [_domReference, setDomReference] = React.useState(null), [positionReference, _setPositionReference] = React.useState(null), domReference = (computedElements == null ? void 0 : computedElements.domReference) || _domReference, domReferenceRef = React.useRef(null), tree = useFloatingTree();
  index$1(() => {
    domReference && (domReferenceRef.current = domReference);
  }, [domReference]);
  const position2 = useFloating$2({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  }), setPositionReference = React.useCallback((node2) => {
    const computedPositionReference = isElement(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      contextElement: node2
    } : node2;
    _setPositionReference(computedPositionReference), position2.refs.setReference(computedPositionReference);
  }, [position2.refs]), setReference = React.useCallback((node2) => {
    (isElement(node2) || node2 === null) && (domReferenceRef.current = node2, setDomReference(node2)), (isElement(position2.refs.reference.current) || position2.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node2 !== null && !isElement(node2)) && position2.refs.setReference(node2);
  }, [position2.refs]), refs = React.useMemo(() => ({
    ...position2.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position2.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({
    ...position2.elements,
    domReference
  }), [position2.elements, domReference]), context = React.useMemo(() => ({
    ...position2,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position2, refs, elements, nodeId, rootContext]);
  return index$1(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node2 = tree == null ? void 0 : tree.nodesRef.current.find((node22) => node22.id === nodeId);
    node2 && (node2.context = context);
  }), React.useMemo(() => ({
    ...position2,
    context,
    refs,
    elements
  }), [position2, refs, elements, context]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map(), isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _2,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      return typeof propsOrGetProps == "function" ? userProps ? propsOrGetProps(userProps) : null : propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => (props && Object.entries(props).forEach((_ref) => {
      let [key, value] = _ref;
      if (!(isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)))
        if (key.indexOf("on") === 0) {
          if (map.has(key) || map.set(key, []), typeof value == "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value), acc[key] = function() {
              for (var _map$get2, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
                args[_key] = arguments[_key];
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else
          acc[key] = value;
    }), acc), {})
  };
}
function useInteractions(propsList) {
  propsList === void 0 && (propsList = []);
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference), floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating), itemDeps = propsList.map((key) => key == null ? void 0 : key.item), getReferenceProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  ), getFloatingProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  ), getItemProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
const inner = (props) => ({
  name: "inner",
  options: props,
  async fn(state) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index: index2 = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      scrollRef,
      ...detectOverflowOptions
    } = evaluate(props, state), {
      rects,
      elements: {
        floating
      }
    } = state, item = listRef.current[index2], scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating, clientTop = floating.clientTop || scrollEl.clientTop, floatingIsBordered = floating.clientTop !== 0, scrollElIsBordered = scrollEl.clientTop !== 0, floatingIsScrollEl = floating === scrollEl;
    if (define_process_env_default.NODE_ENV !== "production" && (state.placement.startsWith("bottom") || warn('`placement` side must be "bottom" when using the `inner`', "middleware.")), !item)
      return {};
    const nextArgs = {
      ...state,
      ...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
    }, overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions), refOverflow = await detectOverflow(nextArgs, {
      ...detectOverflowOptions,
      elementContext: "reference"
    }), diffY = max(0, overflow.top), nextY = nextArgs.y + diffY, maxHeight = (scrollEl.scrollHeight > scrollEl.clientHeight ? (v2) => v2 : round)(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
    if (scrollEl.style.maxHeight = maxHeight + "px", scrollEl.scrollTop = diffY, onFallbackChange) {
      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
      ReactDOM.flushSync(() => onFallbackChange(shouldFallback));
    }
    return overflowRef && (overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({
      ...nextArgs,
      y: nextY
    }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions)), {
      y: nextY
    };
  }
});
function useInnerOffset(context, props) {
  const {
    open,
    elements
  } = context, {
    enabled = !0,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props, onChange = useEffectEvent(unstable_onChange), controlledScrollingRef = React.useRef(!1), prevScrollTopRef = React.useRef(null), initialOverflowRef = React.useRef(null);
  React.useEffect(() => {
    if (!enabled) return;
    function onWheel(e2) {
      if (e2.ctrlKey || !el || overflowRef.current == null)
        return;
      const dY = e2.deltaY, isAtTop = overflowRef.current.top >= -0.5, isAtBottom = overflowRef.current.bottom >= -0.5, remainingScroll = el.scrollHeight - el.clientHeight, sign = dY < 0 ? -1 : 1, method = dY < 0 ? "max" : "min";
      el.scrollHeight <= el.clientHeight || (!isAtTop && dY > 0 || !isAtBottom && dY < 0 ? (e2.preventDefault(), ReactDOM.flushSync(() => {
        onChange((d2) => d2 + Math[method](dY, remainingScroll * sign));
      })) : /firefox/i.test(getUserAgent()) && (el.scrollTop += dY));
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el)
      return el.addEventListener("wheel", onWheel), requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop, overflowRef.current != null && (initialOverflowRef.current = {
          ...overflowRef.current
        });
      }), () => {
        prevScrollTopRef.current = null, initialOverflowRef.current = null, el.removeEventListener("wheel", onWheel);
      };
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
  const floating = React.useMemo(() => ({
    onKeyDown() {
      controlledScrollingRef.current = !0;
    },
    onWheel() {
      controlledScrollingRef.current = !1;
    },
    onPointerMove() {
      controlledScrollingRef.current = !1;
    },
    onScroll() {
      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
      if (!(!overflowRef.current || !el || !controlledScrollingRef.current)) {
        if (prevScrollTopRef.current !== null) {
          const scrollDiff = el.scrollTop - prevScrollTopRef.current;
          (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) && ReactDOM.flushSync(() => onChange((d2) => d2 + scrollDiff));
        }
        requestAnimationFrame(() => {
          prevScrollTopRef.current = el.scrollTop;
        });
      }
    }
  }), [elements.floating, onChange, overflowRef, scrollRef]);
  return React.useMemo(() => enabled ? {
    floating
  } : {}, [enabled, floating]);
}
let y$1 = createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$1.displayName = "FloatingContext";
let H$3 = createContext(null);
H$3.displayName = "PlacementContext";
function xe(e2) {
  return useMemo(() => e2 ? typeof e2 == "string" ? { to: e2 } : e2 : null, [e2]);
}
function ye$1() {
  return useContext(y$1).setReference;
}
function Fe$1() {
  return useContext(y$1).getReferenceProps;
}
function be$2() {
  let { getFloatingProps: e2, slot: t2 } = useContext(y$1);
  return useCallback((...n2) => Object.assign({}, e2(...n2), { "data-anchor": t2.anchor }), [e2, t2]);
}
function Re$1(e2 = null) {
  e2 === !1 && (e2 = null), typeof e2 == "string" && (e2 = { to: e2 });
  let t2 = useContext(H$3), n2 = useMemo(() => e2, [JSON.stringify(e2, (r2, o3) => {
    var u2;
    return (u2 = o3 == null ? void 0 : o3.outerHTML) != null ? u2 : o3;
  })]);
  n$3(() => {
    t2 == null || t2(n2 ?? null);
  }, [t2, n2]);
  let l2 = useContext(y$1);
  return useMemo(() => [l2.setFloating, e2 ? l2.styles : {}], [l2.setFloating, e2, l2.styles]);
}
let q = 4;
function Me({ children: e2, enabled: t2 = !0 }) {
  let [n2, l2] = useState(null), [r2, o3] = useState(0), u2 = useRef(null), [f2, s2] = useState(null);
  pe(f2);
  let i2 = t2 && n2 !== null && f2 !== null, { to: F2 = "bottom", gap: E2 = 0, offset: v2 = 0, padding: c2 = 0, inner: P2 } = ce$1(n2, f2), [a3, p2 = "center"] = F2.split(" ");
  n$3(() => {
    i2 && o3(0);
  }, [i2]);
  let { refs: b2, floatingStyles: w2, context: g2 } = useFloating({ open: i2, placement: a3 === "selection" ? p2 === "center" ? "bottom" : `bottom-${p2}` : p2 === "center" ? `${a3}` : `${a3}-${p2}`, strategy: "absolute", transform: !1, middleware: [offset({ mainAxis: a3 === "selection" ? 0 : E2, crossAxis: v2 }), shift({ padding: c2 }), a3 !== "selection" && flip({ padding: c2 }), a3 === "selection" && P2 ? inner({ ...P2, padding: c2, overflowRef: u2, offset: r2, minItemsVisible: q, referenceOverflowThreshold: c2, onFallbackChange(h2) {
    var O2, W;
    if (!h2) return;
    let d2 = g2.elements.floating;
    if (!d2) return;
    let T2 = parseFloat(getComputedStyle(d2).scrollPaddingBottom) || 0, $2 = Math.min(q, d2.childElementCount), L2 = 0, N2 = 0;
    for (let m2 of (W = (O2 = g2.elements.floating) == null ? void 0 : O2.childNodes) != null ? W : []) if (m2 instanceof HTMLElement) {
      let x2 = m2.offsetTop, k2 = x2 + m2.clientHeight + T2, S2 = d2.scrollTop, U2 = S2 + d2.clientHeight;
      if (x2 >= S2 && k2 <= U2) $2--;
      else {
        N2 = Math.max(0, Math.min(k2, U2) - Math.max(x2, S2)), L2 = m2.clientHeight;
        break;
      }
    }
    $2 >= 1 && o3((m2) => {
      let x2 = L2 * $2 - N2 + T2;
      return m2 >= x2 ? m2 : x2;
    });
  } }) : null, size({ padding: c2, apply({ availableWidth: h2, availableHeight: d2, elements: T2 }) {
    Object.assign(T2.floating.style, { overflow: "auto", maxWidth: `${h2}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${d2}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [I2 = a3, B2 = p2] = g2.placement.split("-");
  a3 === "selection" && (I2 = "selection");
  let G2 = useMemo(() => ({ anchor: [I2, B2].filter(Boolean).join(" ") }), [I2, B2]), K2 = useInnerOffset(g2, { overflowRef: u2, onChange: o3 }), { getReferenceProps: Q, getFloatingProps: X2 } = useInteractions([K2]), Y = o$4((h2) => {
    s2(h2), b2.setFloating(h2);
  });
  return React.createElement(H$3.Provider, { value: l2 }, React.createElement(y$1.Provider, { value: { setFloating: Y, setReference: b2.setReference, styles: w2, getReferenceProps: Q, getFloatingProps: X2, slot: G2 } }, e2));
}
function pe(e2) {
  n$3(() => {
    if (!e2) return;
    let t2 = new MutationObserver(() => {
      let n2 = window.getComputedStyle(e2).maxHeight, l2 = parseFloat(n2);
      if (isNaN(l2)) return;
      let r2 = parseInt(n2);
      isNaN(r2) || l2 !== r2 && (e2.style.maxHeight = `${Math.ceil(l2)}px`);
    });
    return t2.observe(e2, { attributes: !0, attributeFilter: ["style"] }), () => {
      t2.disconnect();
    };
  }, [e2]);
}
function ce$1(e2, t2) {
  var o3, u2, f2;
  let n2 = V((o3 = e2 == null ? void 0 : e2.gap) != null ? o3 : "var(--anchor-gap, 0)", t2), l2 = V((u2 = e2 == null ? void 0 : e2.offset) != null ? u2 : "var(--anchor-offset, 0)", t2), r2 = V((f2 = e2 == null ? void 0 : e2.padding) != null ? f2 : "var(--anchor-padding, 0)", t2);
  return { ...e2, gap: n2, offset: l2, padding: r2 };
}
function V(e2, t2, n2 = void 0) {
  let l2 = p$2(), r2 = o$4((s2, i2) => {
    if (s2 == null) return [n2, null];
    if (typeof s2 == "number") return [s2, null];
    if (typeof s2 == "string") {
      if (!i2) return [n2, null];
      let F2 = J$3(s2, i2);
      return [F2, (E2) => {
        let v2 = D$1(s2);
        {
          let c2 = v2.map((P2) => window.getComputedStyle(i2).getPropertyValue(P2));
          l2.requestAnimationFrame(function P2() {
            l2.nextFrame(P2);
            let a3 = !1;
            for (let [b2, w2] of v2.entries()) {
              let g2 = window.getComputedStyle(i2).getPropertyValue(w2);
              if (c2[b2] !== g2) {
                c2[b2] = g2, a3 = !0;
                break;
              }
            }
            if (!a3) return;
            let p2 = J$3(s2, i2);
            F2 !== p2 && (E2(p2), F2 = p2);
          });
        }
        return l2.dispose;
      }];
    }
    return [n2, null];
  }), o3 = useMemo(() => r2(e2, t2)[0], [e2, t2]), [u2 = o3, f2] = useState();
  return n$3(() => {
    let [s2, i2] = r2(e2, t2);
    if (f2(s2), !!i2) return i2(f2);
  }, [e2, t2]), u2;
}
function D$1(e2) {
  let t2 = /var\((.*)\)/.exec(e2);
  if (t2) {
    let n2 = t2[1].indexOf(",");
    if (n2 === -1) return [t2[1]];
    let l2 = t2[1].slice(0, n2).trim(), r2 = t2[1].slice(n2 + 1).trim();
    return r2 ? [l2, ...D$1(r2)] : [l2];
  }
  return [];
}
function J$3(e2, t2) {
  let n2 = document.createElement("div");
  t2.appendChild(n2), n2.style.setProperty("margin-top", "0px", "important"), n2.style.setProperty("margin-top", e2, "important");
  let l2 = parseFloat(window.getComputedStyle(n2).marginTop) || 0;
  return t2.removeChild(n2), l2;
}
let n = createContext(null);
n.displayName = "OpenClosedContext";
var i$2 = ((e2) => (e2[e2.Open = 1] = "Open", e2[e2.Closed = 2] = "Closed", e2[e2.Closing = 4] = "Closing", e2[e2.Opening = 8] = "Opening", e2))(i$2 || {});
function u$3() {
  return useContext(n);
}
function c$3({ value: o3, children: t2 }) {
  return React__default.createElement(n.Provider, { value: o3 }, t2);
}
function s$5({ children: o3 }) {
  return React__default.createElement(n.Provider, { value: null }, o3);
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
var withSelector = { exports: {} }, useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_production;
function requireUseSyncExternalStoreWithSelector_production() {
  if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;
  hasRequiredUseSyncExternalStoreWithSelector_production = 1;
  var React2 = React__default;
  function is(x2, y2) {
    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is, useSyncExternalStore2 = React2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;
  return useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef2(null);
    if (instRef.current === null) {
      var inst = { hasValue: !1, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo2(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector(nextSnapshot), isEqual !== void 0 && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
        }
        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
    return useEffect2(
      function() {
        inst.hasValue = !0, inst.value = value;
      },
      [value]
    ), useDebugValue(value), value;
  }, useSyncExternalStoreWithSelector_production;
}
var useSyncExternalStoreWithSelector_development = {}, hasRequiredUseSyncExternalStoreWithSelector_development;
function requireUseSyncExternalStoreWithSelector_development() {
  if (hasRequiredUseSyncExternalStoreWithSelector_development) return useSyncExternalStoreWithSelector_development;
  hasRequiredUseSyncExternalStoreWithSelector_development = 1;
  var define_process_env_default2 = {};
  /**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return define_process_env_default2.NODE_ENV !== "production" && (function() {
    function is(x2, y2) {
      return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React2 = React__default, objectIs = typeof Object.is == "function" ? Object.is : is, useSyncExternalStore2 = React2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;
    useSyncExternalStoreWithSelector_development.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef2(null);
      if (instRef.current === null) {
        var inst = { hasValue: !1, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo2(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector(nextSnapshot), isEqual !== void 0 && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot))
              return currentSelection;
            var nextSelection = selector(nextSnapshot);
            return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
          }
          var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual]
      );
      var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
      return useEffect2(
        function() {
          inst.hasValue = !0, inst.value = value;
        },
        [value]
      ), useDebugValue(value), value;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })(), useSyncExternalStoreWithSelector_development;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  var define_process_env_default2 = {};
  return define_process_env_default2.NODE_ENV === "production" ? withSelector.exports = requireUseSyncExternalStoreWithSelector_production() : withSelector.exports = requireUseSyncExternalStoreWithSelector_development(), withSelector.exports;
}
var withSelectorExports = requireWithSelector(), f$2 = (t2, e2, r2) => {
  if (!e2.has(t2)) throw TypeError("Cannot " + r2);
}, a$6 = (t2, e2, r2) => (f$2(t2, e2, "read from private field"), r2 ? r2.call(t2) : e2.get(t2)), l$2 = (t2, e2, r2) => {
  if (e2.has(t2)) throw TypeError("Cannot add the same private member more than once");
  e2 instanceof WeakSet ? e2.add(t2) : e2.set(t2, r2);
}, c$2 = (t2, e2, r2, n2) => (f$2(t2, e2, "write to private field"), e2.set(t2, r2), r2), i$1, s$4, o$1;
class m {
  constructor(e2) {
    l$2(this, i$1, {}), l$2(this, s$4, new a$a(() => /* @__PURE__ */ new Set())), l$2(this, o$1, /* @__PURE__ */ new Set()), c$2(this, i$1, e2);
  }
  get state() {
    return a$6(this, i$1);
  }
  subscribe(e2, r2) {
    let n2 = { selector: e2, callback: r2, current: e2(a$6(this, i$1)) };
    return a$6(this, o$1).add(n2), () => {
      a$6(this, o$1).delete(n2);
    };
  }
  on(e2, r2) {
    return a$6(this, s$4).get(e2).add(r2), () => {
      a$6(this, s$4).get(e2).delete(r2);
    };
  }
  send(e2) {
    c$2(this, i$1, this.reduce(a$6(this, i$1), e2));
    for (let r2 of a$6(this, o$1)) {
      let n2 = r2.selector(a$6(this, i$1));
      h$1(r2.current, n2) || (r2.current = n2, r2.callback(n2));
    }
    for (let r2 of a$6(this, s$4).get(e2.type)) r2(a$6(this, i$1), e2);
  }
}
i$1 = /* @__PURE__ */ new WeakMap(), s$4 = /* @__PURE__ */ new WeakMap(), o$1 = /* @__PURE__ */ new WeakMap();
function h$1(t2, e2) {
  return Object.is(t2, e2) ? !0 : typeof t2 != "object" || t2 === null || typeof e2 != "object" || e2 === null ? !1 : Array.isArray(t2) && Array.isArray(e2) ? t2.length !== e2.length ? !1 : u$2(t2[Symbol.iterator](), e2[Symbol.iterator]()) : t2 instanceof Map && e2 instanceof Map || t2 instanceof Set && e2 instanceof Set ? t2.size !== e2.size ? !1 : u$2(t2.entries(), e2.entries()) : S$2(t2) && S$2(e2) ? u$2(Object.entries(t2)[Symbol.iterator](), Object.entries(e2)[Symbol.iterator]()) : !1;
}
function u$2(t2, e2) {
  do {
    let r2 = t2.next(), n2 = e2.next();
    if (r2.done && n2.done) return !0;
    if (r2.done || n2.done || !Object.is(r2.value, n2.value)) return !1;
  } while (!0);
}
function S$2(t2) {
  if (Object.prototype.toString.call(t2) !== "[object Object]") return !1;
  let e2 = Object.getPrototypeOf(t2);
  return e2 === null || Object.getPrototypeOf(e2) === null;
}
function g$2(t2) {
  let [e2, r2] = t2(), n2 = o$5();
  return (...b2) => {
    e2(...b2), n2.dispose(), n2.microTask(r2);
  };
}
function S$1(e2, n2, r2 = h$1) {
  return withSelectorExports.useSyncExternalStoreWithSelector(o$4((i2) => e2.subscribe(s$3, i2)), o$4(() => e2.state), o$4(() => e2.state), o$4(n2), r2);
}
function s$3(e2) {
  return e2;
}
function u$1(l2) {
  throw new Error("Unexpected object: " + l2);
}
var c$1 = ((i2) => (i2[i2.First = 0] = "First", i2[i2.Previous = 1] = "Previous", i2[i2.Next = 2] = "Next", i2[i2.Last = 3] = "Last", i2[i2.Specific = 4] = "Specific", i2[i2.Nothing = 5] = "Nothing", i2))(c$1 || {});
function f$1(l2, n2) {
  let t2 = n2.resolveItems();
  if (t2.length <= 0) return null;
  let r2 = n2.resolveActiveIndex(), s2 = r2 ?? -1;
  switch (l2.focus) {
    case 0: {
      for (let e2 = 0; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 1: {
      s2 === -1 && (s2 = t2.length);
      for (let e2 = s2 - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 2: {
      for (let e2 = s2 + 1; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 3: {
      for (let e2 = t2.length - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 4: {
      for (let e2 = 0; e2 < t2.length; ++e2) if (n2.resolveId(t2[e2], e2, t2) === l2.id) return e2;
      return r2;
    }
    case 5:
      return null;
    default:
      u$1(l2);
  }
}
function c(t2) {
  let r2 = o$4(t2), e2 = useRef(!1);
  useEffect(() => (e2.current = !1, () => {
    e2.current = !0, t$4(() => {
      e2.current && r2();
    });
  }), [r2]);
}
function s$2() {
  let r2 = typeof document > "u";
  return "useSyncExternalStore" in React ? ((o3) => o3.useSyncExternalStore)(React)(() => () => {
  }, () => !1, () => !r2) : !1;
}
function l$1() {
  let r2 = s$2(), [e2, n2] = React.useState(s$9.isHandoffComplete);
  return e2 && s$9.isHandoffComplete === !1 && n2(!1), React.useEffect(() => {
    e2 !== !0 && n2(!0);
  }, [e2]), React.useEffect(() => s$9.handoff(), []), r2 ? !1 : e2;
}
let e = createContext(!1);
function a$5() {
  return useContext(e);
}
function j(e2) {
  let l2 = a$5(), o3 = useContext(H$2), [r2, u2] = useState(() => {
    var i2;
    if (!l2 && o3 !== null) return (i2 = o3.current) != null ? i2 : null;
    if (s$9.isServer) return null;
    let t2 = e2 == null ? void 0 : e2.getElementById("headlessui-portal-root");
    if (t2) return t2;
    if (e2 === null) return null;
    let a3 = e2.createElement("div");
    return a3.setAttribute("id", "headlessui-portal-root"), e2.body.appendChild(a3);
  });
  return useEffect(() => {
    r2 !== null && (e2 != null && e2.body.contains(r2) || e2 == null || e2.body.appendChild(r2));
  }, [r2, e2]), useEffect(() => {
    l2 || o3 !== null && u2(o3.current);
  }, [o3, u2, l2]), r2;
}
let M$3 = Fragment, I = K$1(function(l2, o3) {
  let { ownerDocument: r2 = null, ...u2 } = l2, t2 = useRef(null), a3 = y$4(T$3((s2) => {
    t2.current = s2;
  }), o3), i2 = n$1(t2), f2 = r2 ?? i2, p2 = j(f2), [n2] = useState(() => {
    var s2;
    return s$9.isServer ? null : (s2 = f2 == null ? void 0 : f2.createElement("div")) != null ? s2 : null;
  }), P2 = useContext(g$1), b2 = l$1();
  n$3(() => {
    !p2 || !n2 || p2.contains(n2) || (n2.setAttribute("data-headlessui-portal", ""), p2.appendChild(n2));
  }, [p2, n2]), n$3(() => {
    if (n2 && P2) return P2.register(n2);
  }, [P2, n2]), c(() => {
    var s2;
    !p2 || !n2 || (n2 instanceof Node && p2.contains(n2) && p2.removeChild(n2), p2.childNodes.length <= 0 && ((s2 = p2.parentElement) == null || s2.removeChild(p2)));
  });
  let h2 = L$2();
  return b2 ? !p2 || !n2 ? null : createPortal(h2({ ourProps: { ref: a3 }, theirProps: u2, slot: {}, defaultTag: M$3, name: "Portal" }), n2) : null;
});
function J$2(e2, l2) {
  let o3 = y$4(l2), { enabled: r2 = !0, ownerDocument: u2, ...t2 } = e2, a3 = L$2();
  return r2 ? React__default.createElement(I, { ...t2, ownerDocument: u2, ref: o3 }) : a3({ ourProps: { ref: o3 }, theirProps: t2, slot: {}, defaultTag: M$3, name: "Portal" });
}
let X$2 = Fragment, H$2 = createContext(null);
function k(e2, l2) {
  let { target: o3, ...r2 } = e2, t2 = { ref: y$4(l2) }, a3 = L$2();
  return React__default.createElement(H$2.Provider, { value: o3 }, a3({ ourProps: t2, theirProps: r2, defaultTag: X$2, name: "Popover.Group" }));
}
let g$1 = createContext(null);
function le() {
  let e2 = useContext(g$1), l2 = useRef([]), o3 = o$4((t2) => (l2.current.push(t2), e2 && e2.register(t2), () => r2(t2))), r2 = o$4((t2) => {
    let a3 = l2.current.indexOf(t2);
    a3 !== -1 && l2.current.splice(a3, 1), e2 && e2.unregister(t2);
  }), u2 = useMemo(() => ({ register: o3, unregister: r2, portals: l2 }), [o3, r2, l2]);
  return [l2, useMemo(() => function({ children: a3 }) {
    return React__default.createElement(g$1.Provider, { value: u2 }, a3);
  }, [u2])];
}
let B = K$1(J$2), D = K$1(k), oe = Object.assign(B, { Group: D });
function R({ defaultContainers: l2 = [], portals: n2, mainTreeNode: o3 } = {}) {
  let r2 = n$1(o3), u2 = o$4(() => {
    var i2, c2;
    let t2 = [];
    for (let e2 of l2) e2 !== null && (e2 instanceof HTMLElement ? t2.push(e2) : "current" in e2 && e2.current instanceof HTMLElement && t2.push(e2.current));
    if (n2 != null && n2.current) for (let e2 of n2.current) t2.push(e2);
    for (let e2 of (i2 = r2 == null ? void 0 : r2.querySelectorAll("html > *, body > *")) != null ? i2 : []) e2 !== document.body && e2 !== document.head && e2 instanceof HTMLElement && e2.id !== "headlessui-portal-root" && (o3 && (e2.contains(o3) || e2.contains((c2 = o3 == null ? void 0 : o3.getRootNode()) == null ? void 0 : c2.host)) || t2.some((m2) => e2.contains(m2)) || t2.push(e2));
    return t2;
  });
  return { resolveContainers: u2, contains: o$4((t2) => u2().some((i2) => i2.contains(t2))) };
}
let a$4 = createContext(null);
function O({ children: l2, node: n2 }) {
  let [o3, r2] = useState(null), u2 = b$1(n2 ?? o3);
  return React__default.createElement(a$4.Provider, { value: u2 }, l2, u2 === null && React__default.createElement(f$8, { features: s$7.Hidden, ref: (t2) => {
    var i2, c2;
    if (t2) {
      for (let e2 of (c2 = (i2 = o$6(t2)) == null ? void 0 : i2.querySelectorAll("html > *, body > *")) != null ? c2 : []) if (e2 !== document.body && e2 !== document.head && e2 instanceof HTMLElement && e2 != null && e2.contains(t2)) {
        r2(e2);
        break;
      }
    }
  } }));
}
function b$1(l2 = null) {
  var n2;
  return (n2 = useContext(a$4)) != null ? n2 : l2;
}
function f() {
  let e2 = useRef(!1);
  return n$3(() => (e2.current = !0, () => {
    e2.current = !1;
  }), []), e2;
}
var a$3 = ((r2) => (r2[r2.Forwards = 0] = "Forwards", r2[r2.Backwards = 1] = "Backwards", r2))(a$3 || {});
function u() {
  let e2 = useRef(0);
  return s$6(!0, "keydown", (r2) => {
    r2.key === "Tab" && (e2.current = r2.shiftKey ? 1 : 0);
  }, !0), e2;
}
function ue(e2) {
  var t2;
  return !!(e2.enter || e2.enterFrom || e2.enterTo || e2.leave || e2.leaveFrom || e2.leaveTo) || ((t2 = e2.as) != null ? t2 : de$2) !== Fragment || React__default.Children.count(e2.children) === 1;
}
let w = createContext(null);
w.displayName = "TransitionContext";
var _e = ((n2) => (n2.Visible = "visible", n2.Hidden = "hidden", n2))(_e || {});
function De$1() {
  let e2 = useContext(w);
  if (e2 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e2;
}
function He() {
  let e2 = useContext(M$2);
  if (e2 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e2;
}
let M$2 = createContext(null);
M$2.displayName = "NestingContext";
function U(e2) {
  return "children" in e2 ? U(e2.children) : e2.current.filter(({ el: t2 }) => t2.current !== null).filter(({ state: t2 }) => t2 === "visible").length > 0;
}
function Te$1(e2, t2) {
  let n2 = s$8(e2), l2 = useRef([]), S2 = f(), R2 = p$2(), d2 = o$4((o3, i2 = A$1.Hidden) => {
    let a3 = l2.current.findIndex(({ el: s2 }) => s2 === o3);
    a3 !== -1 && (u$8(i2, { [A$1.Unmount]() {
      l2.current.splice(a3, 1);
    }, [A$1.Hidden]() {
      l2.current[a3].state = "hidden";
    } }), R2.microTask(() => {
      var s2;
      !U(l2) && S2.current && ((s2 = n2.current) == null || s2.call(n2));
    }));
  }), y2 = o$4((o3) => {
    let i2 = l2.current.find(({ el: a3 }) => a3 === o3);
    return i2 ? i2.state !== "visible" && (i2.state = "visible") : l2.current.push({ el: o3, state: "visible" }), () => d2(o3, A$1.Unmount);
  }), C2 = useRef([]), p2 = useRef(Promise.resolve()), h2 = useRef({ enter: [], leave: [] }), g2 = o$4((o3, i2, a3) => {
    C2.current.splice(0), t2 && (t2.chains.current[i2] = t2.chains.current[i2].filter(([s2]) => s2 !== o3)), t2 == null || t2.chains.current[i2].push([o3, new Promise((s2) => {
      C2.current.push(s2);
    })]), t2 == null || t2.chains.current[i2].push([o3, new Promise((s2) => {
      Promise.all(h2.current[i2].map(([r2, f2]) => f2)).then(() => s2());
    })]), i2 === "enter" ? p2.current = p2.current.then(() => t2 == null ? void 0 : t2.wait.current).then(() => a3(i2)) : a3(i2);
  }), v2 = o$4((o3, i2, a3) => {
    Promise.all(h2.current[i2].splice(0).map(([s2, r2]) => r2)).then(() => {
      var s2;
      (s2 = C2.current.shift()) == null || s2();
    }).then(() => a3(i2));
  });
  return useMemo(() => ({ children: l2, register: y2, unregister: d2, onStart: g2, onStop: v2, wait: p2, chains: h2 }), [y2, d2, l2, g2, v2, h2, p2]);
}
let de$2 = Fragment, fe$1 = O$2.RenderStrategy;
function Ae$1(e2, t2) {
  var ee, te;
  let { transition: n2 = !0, beforeEnter: l2, afterEnter: S2, beforeLeave: R2, afterLeave: d2, enter: y2, enterFrom: C2, enterTo: p2, entered: h2, leave: g2, leaveFrom: v2, leaveTo: o3, ...i2 } = e2, [a3, s2] = useState(null), r2 = useRef(null), f2 = ue(e2), j2 = y$4(...f2 ? [r2, t2, s2] : t2 === null ? [] : [t2]), H2 = (ee = i2.unmount) == null || ee ? A$1.Unmount : A$1.Hidden, { show: u2, appear: z, initial: K2 } = De$1(), [m2, G2] = useState(u2 ? "visible" : "hidden"), Q = He(), { register: A2, unregister: I2 } = Q;
  n$3(() => A2(r2), [A2, r2]), n$3(() => {
    if (H2 === A$1.Hidden && r2.current) {
      if (u2 && m2 !== "visible") {
        G2("visible");
        return;
      }
      return u$8(m2, { hidden: () => I2(r2), visible: () => A2(r2) });
    }
  }, [m2, r2, A2, I2, u2, H2]);
  let B2 = l$1();
  n$3(() => {
    if (f2 && B2 && m2 === "visible" && r2.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [r2, m2, B2, f2]);
  let ce2 = K2 && !z, Y = z && u2 && K2, W = useRef(!1), L2 = Te$1(() => {
    W.current || (G2("hidden"), I2(r2));
  }, Q), Z = o$4((k2) => {
    W.current = !0;
    let F2 = k2 ? "enter" : "leave";
    L2.onStart(r2, F2, (_2) => {
      _2 === "enter" ? l2 == null || l2() : _2 === "leave" && (R2 == null || R2());
    });
  }), $2 = o$4((k2) => {
    let F2 = k2 ? "enter" : "leave";
    W.current = !1, L2.onStop(r2, F2, (_2) => {
      _2 === "enter" ? S2 == null || S2() : _2 === "leave" && (d2 == null || d2());
    }), F2 === "leave" && !U(L2) && (G2("hidden"), I2(r2));
  });
  useEffect(() => {
    f2 && n2 || (Z(u2), $2(u2));
  }, [u2, f2, n2]);
  let pe2 = !(!n2 || !f2 || !B2 || ce2), [, T2] = x$1(pe2, a3, u2, { start: Z, end: $2 }), Ce2 = m$4({ ref: j2, className: ((te = t$3(i2.className, Y && y2, Y && C2, T2.enter && y2, T2.enter && T2.closed && C2, T2.enter && !T2.closed && p2, T2.leave && g2, T2.leave && !T2.closed && v2, T2.leave && T2.closed && o3, !T2.transition && u2 && h2)) == null ? void 0 : te.trim()) || void 0, ...R$1(T2) }), N2 = 0;
  m2 === "visible" && (N2 |= i$2.Open), m2 === "hidden" && (N2 |= i$2.Closed), u2 && m2 === "hidden" && (N2 |= i$2.Opening), !u2 && m2 === "visible" && (N2 |= i$2.Closing);
  let he = L$2();
  return React__default.createElement(M$2.Provider, { value: L2 }, React__default.createElement(c$3, { value: N2 }, he({ ourProps: Ce2, theirProps: i2, defaultTag: de$2, features: fe$1, visible: m2 === "visible", name: "Transition.Child" })));
}
function Ie(e2, t2) {
  let { show: n2, appear: l2 = !1, unmount: S2 = !0, ...R2 } = e2, d2 = useRef(null), y2 = ue(e2), C2 = y$4(...y2 ? [d2, t2] : t2 === null ? [] : [t2]);
  l$1();
  let p2 = u$3();
  if (n2 === void 0 && p2 !== null && (n2 = (p2 & i$2.Open) === i$2.Open), n2 === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [h2, g2] = useState(n2 ? "visible" : "hidden"), v2 = Te$1(() => {
    n2 || g2("hidden");
  }), [o3, i2] = useState(!0), a3 = useRef([n2]);
  n$3(() => {
    o3 !== !1 && a3.current[a3.current.length - 1] !== n2 && (a3.current.push(n2), i2(!1));
  }, [a3, n2]);
  let s2 = useMemo(() => ({ show: n2, appear: l2, initial: o3 }), [n2, l2, o3]);
  n$3(() => {
    n2 ? g2("visible") : !U(v2) && d2.current !== null && g2("hidden");
  }, [n2, v2]);
  let r2 = { unmount: S2 }, f2 = o$4(() => {
    var u2;
    o3 && i2(!1), (u2 = e2.beforeEnter) == null || u2.call(e2);
  }), j2 = o$4(() => {
    var u2;
    o3 && i2(!1), (u2 = e2.beforeLeave) == null || u2.call(e2);
  }), H2 = L$2();
  return React__default.createElement(M$2.Provider, { value: v2 }, React__default.createElement(w.Provider, { value: s2 }, H2({ ourProps: { ...r2, as: Fragment, children: React__default.createElement(me$1, { ref: C2, ...r2, ...R2, beforeEnter: f2, beforeLeave: j2 }) }, theirProps: {}, defaultTag: Fragment, features: fe$1, visible: h2 === "visible", name: "Transition" })));
}
function Le$1(e2, t2) {
  let n2 = useContext(w) !== null, l2 = u$3() !== null;
  return React__default.createElement(React__default.Fragment, null, !n2 && l2 ? React__default.createElement(X$1, { ref: t2, ...e2 }) : React__default.createElement(me$1, { ref: t2, ...e2 }));
}
let X$1 = K$1(Ie), me$1 = K$1(Ae$1), Fe = K$1(Le$1), ze$1 = Object.assign(X$1, { Child: Fe, Root: X$1 });
var t;
let a$2 = (t = React__default.startTransition) != null ? t : function(i2) {
  i2();
};
var ce = ((l2) => (l2[l2.Open = 0] = "Open", l2[l2.Closed = 1] = "Closed", l2))(ce || {}), de$1 = ((n2) => (n2[n2.ToggleDisclosure = 0] = "ToggleDisclosure", n2[n2.CloseDisclosure = 1] = "CloseDisclosure", n2[n2.SetButtonId = 2] = "SetButtonId", n2[n2.SetPanelId = 3] = "SetPanelId", n2[n2.SetButtonElement = 4] = "SetButtonElement", n2[n2.SetPanelElement = 5] = "SetPanelElement", n2))(de$1 || {});
let Te = { 0: (e2) => ({ ...e2, disclosureState: u$8(e2.disclosureState, { 0: 1, 1: 0 }) }), 1: (e2) => e2.disclosureState === 1 ? e2 : { ...e2, disclosureState: 1 }, 2(e2, t2) {
  return e2.buttonId === t2.buttonId ? e2 : { ...e2, buttonId: t2.buttonId };
}, 3(e2, t2) {
  return e2.panelId === t2.panelId ? e2 : { ...e2, panelId: t2.panelId };
}, 4(e2, t2) {
  return e2.buttonElement === t2.element ? e2 : { ...e2, buttonElement: t2.element };
}, 5(e2, t2) {
  return e2.panelElement === t2.element ? e2 : { ...e2, panelElement: t2.element };
} }, _ = createContext(null);
_.displayName = "DisclosureContext";
function M$1(e2) {
  let t2 = useContext(_);
  if (t2 === null) {
    let l2 = new Error(`<${e2} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(l2, M$1), l2;
  }
  return t2;
}
let F$1 = createContext(null);
F$1.displayName = "DisclosureAPIContext";
function J$1(e2) {
  let t2 = useContext(F$1);
  if (t2 === null) {
    let l2 = new Error(`<${e2} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(l2, J$1), l2;
  }
  return t2;
}
let H$1 = createContext(null);
H$1.displayName = "DisclosurePanelContext";
function fe() {
  return useContext(H$1);
}
function me(e2, t2) {
  return u$8(t2.type, Te, e2, t2);
}
let De = Fragment;
function ye(e2, t2) {
  let { defaultOpen: l2 = !1, ...p2 } = e2, i2 = useRef(null), c2 = y$4(t2, T$3((a3) => {
    i2.current = a3;
  }, e2.as === void 0 || e2.as === Fragment)), n2 = useReducer(me, { disclosureState: l2 ? 0 : 1, buttonElement: null, panelElement: null, buttonId: null, panelId: null }), [{ disclosureState: o3, buttonId: r2 }, m2] = n2, s2 = o$4((a3) => {
    m2({ type: 1 });
    let d2 = o$6(i2);
    if (!d2 || !r2) return;
    let T2 = a3 ? a3 instanceof HTMLElement ? a3 : a3.current instanceof HTMLElement ? a3.current : d2.getElementById(r2) : d2.getElementById(r2);
    T2 == null || T2.focus();
  }), E2 = useMemo(() => ({ close: s2 }), [s2]), f2 = useMemo(() => ({ open: o3 === 0, close: s2 }), [o3, s2]), D2 = { ref: c2 }, S2 = L$2();
  return React__default.createElement(_.Provider, { value: n2 }, React__default.createElement(F$1.Provider, { value: E2 }, React__default.createElement(C$1, { value: s2 }, React__default.createElement(c$3, { value: u$8(o3, { 0: i$2.Open, 1: i$2.Closed }) }, S2({ ourProps: D2, theirProps: p2, slot: f2, defaultTag: De, name: "Disclosure" })))));
}
let Pe$1 = "button";
function Ee(e2, t2) {
  let l2 = useId$2(), { id: p2 = `headlessui-disclosure-button-${l2}`, disabled: i2 = !1, autoFocus: c2 = !1, ...n2 } = e2, [o3, r2] = M$1("Disclosure.Button"), m2 = fe(), s2 = m2 === null ? !1 : m2 === o3.panelId, E2 = useRef(null), f2 = y$4(E2, t2, o$4((u2) => {
    if (!s2) return r2({ type: 4, element: u2 });
  }));
  useEffect(() => {
    if (!s2) return r2({ type: 2, buttonId: p2 }), () => {
      r2({ type: 2, buttonId: null });
    };
  }, [p2, r2, s2]);
  let D2 = o$4((u2) => {
    var g2;
    if (s2) {
      if (o3.disclosureState === 1) return;
      switch (u2.key) {
        case o$3.Space:
        case o$3.Enter:
          u2.preventDefault(), u2.stopPropagation(), r2({ type: 0 }), (g2 = o3.buttonElement) == null || g2.focus();
          break;
      }
    } else switch (u2.key) {
      case o$3.Space:
      case o$3.Enter:
        u2.preventDefault(), u2.stopPropagation(), r2({ type: 0 });
        break;
    }
  }), S2 = o$4((u2) => {
    switch (u2.key) {
      case o$3.Space:
        u2.preventDefault();
        break;
    }
  }), a3 = o$4((u2) => {
    var g2;
    r$1(u2.currentTarget) || i2 || (s2 ? (r2({ type: 0 }), (g2 = o3.buttonElement) == null || g2.focus()) : r2({ type: 0 }));
  }), { isFocusVisible: d2, focusProps: T2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: c2 }), { isHovered: b2, hoverProps: h2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: i2 }), { pressed: U2, pressProps: N2 } = w$3({ disabled: i2 }), X2 = useMemo(() => ({ open: o3.disclosureState === 0, hover: b2, active: U2, disabled: i2, focus: d2, autofocus: c2 }), [o3, b2, U2, d2, i2, c2]), k2 = e$1(e2, o3.buttonElement), V2 = _$3(s2 ? { ref: f2, type: k2, disabled: i2 || void 0, autoFocus: c2, onKeyDown: D2, onClick: a3 } : { ref: f2, id: p2, type: k2, "aria-expanded": o3.disclosureState === 0, "aria-controls": o3.panelElement ? o3.panelId : void 0, disabled: i2 || void 0, autoFocus: c2, onKeyDown: D2, onKeyUp: S2, onClick: a3 }, T2, h2, N2);
  return L$2()({ ourProps: V2, theirProps: n2, slot: X2, defaultTag: Pe$1, name: "Disclosure.Button" });
}
let Se$1 = "div", ge$1 = O$2.RenderStrategy | O$2.Static;
function Ae(e2, t2) {
  let l2 = useId$2(), { id: p2 = `headlessui-disclosure-panel-${l2}`, transition: i2 = !1, ...c2 } = e2, [n2, o3] = M$1("Disclosure.Panel"), { close: r2 } = J$1("Disclosure.Panel"), [m2, s2] = useState(null), E2 = y$4(t2, o$4((b2) => {
    a$2(() => o3({ type: 5, element: b2 }));
  }), s2);
  useEffect(() => (o3({ type: 3, panelId: p2 }), () => {
    o3({ type: 3, panelId: null });
  }), [p2, o3]);
  let f2 = u$3(), [D2, S2] = x$1(i2, m2, f2 !== null ? (f2 & i$2.Open) === i$2.Open : n2.disclosureState === 0), a3 = useMemo(() => ({ open: n2.disclosureState === 0, close: r2 }), [n2.disclosureState, r2]), d2 = { ref: E2, id: p2, ...R$1(S2) }, T2 = L$2();
  return React__default.createElement(s$5, null, React__default.createElement(H$1.Provider, { value: n2.panelId }, T2({ ourProps: d2, theirProps: c2, slot: a3, defaultTag: Se$1, features: ge$1, visible: D2, name: "Disclosure.Panel" })));
}
let be$1 = K$1(ye), Ce = K$1(Ee), Re = K$1(Ae), je = Object.assign(be$1, { Button: Ce, Panel: Re });
function s$1(n2, t2) {
  let e2 = useRef({ left: 0, top: 0 });
  if (n$3(() => {
    if (!t2) return;
    let r2 = t2.getBoundingClientRect();
    r2 && (e2.current = r2);
  }, [n2, t2]), t2 == null || !n2 || t2 === document.activeElement) return !1;
  let o3 = t2.getBoundingClientRect();
  return o3.top !== e2.current.top || o3.left !== e2.current.left;
}
let a$1 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o2(e2) {
  var r2, i2;
  let n2 = (r2 = e2.innerText) != null ? r2 : "", t2 = e2.cloneNode(!0);
  if (!(t2 instanceof HTMLElement)) return n2;
  let u2 = !1;
  for (let f2 of t2.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) f2.remove(), u2 = !0;
  let l2 = u2 ? (i2 = t2.innerText) != null ? i2 : "" : n2;
  return a$1.test(l2) && (l2 = l2.replace(a$1, "")), l2;
}
function g(e2) {
  let n2 = e2.getAttribute("aria-label");
  if (typeof n2 == "string") return n2.trim();
  let t2 = e2.getAttribute("aria-labelledby");
  if (t2) {
    let u2 = t2.split(" ").map((l2) => {
      let r2 = document.getElementById(l2);
      if (r2) {
        let i2 = r2.getAttribute("aria-label");
        return typeof i2 == "string" ? i2.trim() : o2(r2).trim();
      }
      return null;
    }).filter(Boolean);
    if (u2.length > 0) return u2.join(", ");
  }
  return o2(e2).trim();
}
function s(c2) {
  let t2 = useRef(""), r2 = useRef("");
  return o$4(() => {
    let e2 = c2.current;
    if (!e2) return "";
    let u2 = e2.innerText;
    if (t2.current === u2) return r2.current;
    let n2 = g(e2).trim().toLowerCase();
    return t2.current = u2, r2.current = n2, n2;
  });
}
var h = Object.defineProperty, y = (e2, n2, t2) => n2 in e2 ? h(e2, n2, { enumerable: !0, configurable: !0, writable: !0, value: t2 }) : e2[n2] = t2, v = (e2, n2, t2) => (y(e2, typeof n2 != "symbol" ? n2 + "" : n2, t2), t2), M = ((t2) => (t2[t2.Open = 0] = "Open", t2[t2.Closed = 1] = "Closed", t2))(M || {}), T = ((t2) => (t2[t2.Pointer = 0] = "Pointer", t2[t2.Other = 1] = "Other", t2))(T || {}), b = ((i2) => (i2[i2.OpenMenu = 0] = "OpenMenu", i2[i2.CloseMenu = 1] = "CloseMenu", i2[i2.GoToItem = 2] = "GoToItem", i2[i2.Search = 3] = "Search", i2[i2.ClearSearch = 4] = "ClearSearch", i2[i2.RegisterItems = 5] = "RegisterItems", i2[i2.UnregisterItems = 6] = "UnregisterItems", i2[i2.SetButtonElement = 7] = "SetButtonElement", i2[i2.SetItemsElement = 8] = "SetItemsElement", i2[i2.SortItems = 9] = "SortItems", i2))(b || {});
function S(e2, n2 = (t2) => t2) {
  let t2 = e2.activeItemIndex !== null ? e2.items[e2.activeItemIndex] : null, r2 = _$1(n2(e2.items.slice()), (u2) => u2.dataRef.current.domRef.current), l2 = t2 ? r2.indexOf(t2) : null;
  return l2 === -1 && (l2 = null), { items: r2, activeItemIndex: l2 };
}
let F = { 1(e2) {
  return e2.menuState === 1 ? e2 : { ...e2, activeItemIndex: null, pendingFocus: { focus: c$1.Nothing }, menuState: 1 };
}, 0(e2, n2) {
  return e2.menuState === 0 ? e2 : { ...e2, __demoMode: !1, pendingFocus: n2.focus, menuState: 0 };
}, 2: (e2, n2) => {
  var u2, m2, d2, a3, I2;
  if (e2.menuState === 1) return e2;
  let t2 = { ...e2, searchQuery: "", activationTrigger: (u2 = n2.trigger) != null ? u2 : 1, __demoMode: !1 };
  if (n2.focus === c$1.Nothing) return { ...t2, activeItemIndex: null };
  if (n2.focus === c$1.Specific) return { ...t2, activeItemIndex: e2.items.findIndex((i2) => i2.id === n2.id) };
  if (n2.focus === c$1.Previous) {
    let i2 = e2.activeItemIndex;
    if (i2 !== null) {
      let g2 = e2.items[i2].dataRef.current.domRef, o3 = f$1(n2, { resolveItems: () => e2.items, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (s2) => s2.id, resolveDisabled: (s2) => s2.dataRef.current.disabled });
      if (o3 !== null) {
        let s2 = e2.items[o3].dataRef.current.domRef;
        if (((m2 = g2.current) == null ? void 0 : m2.previousElementSibling) === s2.current || ((d2 = s2.current) == null ? void 0 : d2.previousElementSibling) === null) return { ...t2, activeItemIndex: o3 };
      }
    }
  } else if (n2.focus === c$1.Next) {
    let i2 = e2.activeItemIndex;
    if (i2 !== null) {
      let g2 = e2.items[i2].dataRef.current.domRef, o3 = f$1(n2, { resolveItems: () => e2.items, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (s2) => s2.id, resolveDisabled: (s2) => s2.dataRef.current.disabled });
      if (o3 !== null) {
        let s2 = e2.items[o3].dataRef.current.domRef;
        if (((a3 = g2.current) == null ? void 0 : a3.nextElementSibling) === s2.current || ((I2 = s2.current) == null ? void 0 : I2.nextElementSibling) === null) return { ...t2, activeItemIndex: o3 };
      }
    }
  }
  let r2 = S(e2), l2 = f$1(n2, { resolveItems: () => r2.items, resolveActiveIndex: () => r2.activeItemIndex, resolveId: (i2) => i2.id, resolveDisabled: (i2) => i2.dataRef.current.disabled });
  return { ...t2, ...r2, activeItemIndex: l2 };
}, 3: (e2, n2) => {
  let r2 = e2.searchQuery !== "" ? 0 : 1, l2 = e2.searchQuery + n2.value.toLowerCase(), m2 = (e2.activeItemIndex !== null ? e2.items.slice(e2.activeItemIndex + r2).concat(e2.items.slice(0, e2.activeItemIndex + r2)) : e2.items).find((a3) => {
    var I2;
    return ((I2 = a3.dataRef.current.textValue) == null ? void 0 : I2.startsWith(l2)) && !a3.dataRef.current.disabled;
  }), d2 = m2 ? e2.items.indexOf(m2) : -1;
  return d2 === -1 || d2 === e2.activeItemIndex ? { ...e2, searchQuery: l2 } : { ...e2, searchQuery: l2, activeItemIndex: d2, activationTrigger: 1 };
}, 4(e2) {
  return e2.searchQuery === "" ? e2 : { ...e2, searchQuery: "", searchActiveItemIndex: null };
}, 5: (e2, n2) => {
  let t2 = e2.items.concat(n2.items.map((l2) => l2)), r2 = e2.activeItemIndex;
  return e2.pendingFocus.focus !== c$1.Nothing && (r2 = f$1(e2.pendingFocus, { resolveItems: () => t2, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (l2) => l2.id, resolveDisabled: (l2) => l2.dataRef.current.disabled })), { ...e2, items: t2, activeItemIndex: r2, pendingFocus: { focus: c$1.Nothing }, pendingShouldSort: !0 };
}, 6: (e2, n2) => {
  let t2 = e2.items, r2 = [], l2 = new Set(n2.items);
  for (let [u2, m2] of t2.entries()) if (l2.has(m2.id) && (r2.push(u2), l2.delete(m2.id), l2.size === 0)) break;
  if (r2.length > 0) {
    t2 = t2.slice();
    for (let u2 of r2.reverse()) t2.splice(u2, 1);
  }
  return { ...e2, items: t2, activationTrigger: 1 };
}, 7: (e2, n2) => e2.buttonElement === n2.element ? e2 : { ...e2, buttonElement: n2.element }, 8: (e2, n2) => e2.itemsElement === n2.element ? e2 : { ...e2, itemsElement: n2.element }, 9: (e2) => e2.pendingShouldSort ? { ...e2, ...S(e2), pendingShouldSort: !1 } : e2 };
class x extends m {
  constructor(t2) {
    super(t2), v(this, "actions", { registerItem: g$2(() => {
      let t3 = [], r2 = /* @__PURE__ */ new Set();
      return [(l2, u2) => {
        r2.has(u2) || (r2.add(u2), t3.push({ id: l2, dataRef: u2 }));
      }, () => (r2.clear(), this.send({ type: 5, items: t3.splice(0) }))];
    }), unregisterItem: g$2(() => {
      let t3 = [];
      return [(r2) => t3.push(r2), () => this.send({ type: 6, items: t3.splice(0) })];
    }) }), v(this, "selectors", { activeDescendantId(t3) {
      var u2;
      let r2 = t3.activeItemIndex, l2 = t3.items;
      return r2 === null || (u2 = l2[r2]) == null ? void 0 : u2.id;
    }, isActive(t3, r2) {
      var m2;
      let l2 = t3.activeItemIndex, u2 = t3.items;
      return l2 !== null ? ((m2 = u2[l2]) == null ? void 0 : m2.id) === r2 : !1;
    }, shouldScrollIntoView(t3, r2) {
      return t3.__demoMode || t3.menuState !== 0 || t3.activationTrigger === 0 ? !1 : this.isActive(t3, r2);
    } }), this.on(5, () => {
      requestAnimationFrame(() => {
        this.send({ type: 9 });
      });
    });
  }
  static new({ __demoMode: t2 = !1 } = {}) {
    return new x({ __demoMode: t2, menuState: t2 ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1, pendingShouldSort: !1, pendingFocus: { focus: c$1.Nothing } });
  }
  reduce(t2, r2) {
    return u$8(r2.type, F, t2, r2);
  }
}
const a2 = createContext(null);
function l(e2) {
  let n2 = useContext(a2);
  if (n2 === null) {
    let t2 = new Error(`<${e2} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t2, i), t2;
  }
  return n2;
}
function i({ __demoMode: e2 = !1 } = {}) {
  return useMemo(() => x.new({ __demoMode: e2 }), []);
}
let ze = Fragment;
function Qe(T2, E2) {
  let { __demoMode: i$12 = !1, ...a$12 } = T2, n2 = i({ __demoMode: i$12 }), [s2, o3, P2] = S$1(n2, (p2) => [p2.menuState, p2.itemsElement, p2.buttonElement]), c2 = y$4(E2), _2 = s2 === M.Open;
  R$2(_2, [P2, o3], (p2, F2) => {
    var A$12;
    n2.send({ type: b.CloseMenu }), A(F2, h$2.Loose) || (p2.preventDefault(), (A$12 = n2.state.buttonElement) == null || A$12.focus());
  });
  let t2 = o$4(() => {
    n2.send({ type: b.CloseMenu });
  }), R2 = useMemo(() => ({ open: s2 === M.Open, close: t2 }), [s2, t2]), I2 = { ref: c2 }, g2 = L$2();
  return React__default.createElement(Me, null, React__default.createElement(a2.Provider, { value: n2 }, React__default.createElement(c$3, { value: u$8(s2, { [M.Open]: i$2.Open, [M.Closed]: i$2.Closed }) }, g2({ ourProps: I2, theirProps: a$12, slot: R2, defaultTag: ze, name: "Menu" }))));
}
let Ye = "button";
function Ze(T$12, E2) {
  let i2 = l("Menu.Button"), a3 = useId$2(), { id: n2 = `headlessui-menu-button-${a3}`, disabled: s2 = !1, autoFocus: o3 = !1, ...P2 } = T$12, c2 = useRef(null), _2 = Fe$1(), t2 = y$4(E2, c2, ye$1(), o$4((l2) => i2.send({ type: b.SetButtonElement, element: l2 }))), R2 = o$4((l2) => {
    switch (l2.key) {
      case o$3.Space:
      case o$3.Enter:
      case o$3.ArrowDown:
        l2.preventDefault(), l2.stopPropagation(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.First } });
        break;
      case o$3.ArrowUp:
        l2.preventDefault(), l2.stopPropagation(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.Last } });
        break;
    }
  }), I2 = o$4((l2) => {
    switch (l2.key) {
      case o$3.Space:
        l2.preventDefault();
        break;
    }
  }), [g2, p2] = S$1(i2, (l2) => [l2.menuState, l2.itemsElement]), F2 = o$4((l2) => {
    var H2;
    if (l2.button === 0) {
      if (r$1(l2.currentTarget)) return l2.preventDefault();
      s2 || (g2 === M.Open ? (flushSync(() => i2.send({ type: b.CloseMenu })), (H2 = c2.current) == null || H2.focus({ preventScroll: !0 })) : (l2.preventDefault(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.Nothing }, trigger: T.Pointer })));
    }
  }), { isFocusVisible: A2, focusProps: f2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o3 }), { isHovered: M$12, hoverProps: L2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: s2 }), { pressed: S2, pressProps: O2 } = w$3({ disabled: s2 }), x2 = useMemo(() => ({ open: g2 === M.Open, active: S2 || g2 === M.Open, disabled: s2, hover: M$12, focus: A2, autofocus: o3 }), [g2, M$12, A2, S2, s2, o3]), U2 = _$3(_2(), { ref: t2, id: n2, type: e$1(T$12, c2.current), "aria-haspopup": "menu", "aria-controls": p2 == null ? void 0 : p2.id, "aria-expanded": g2 === M.Open, disabled: s2 || void 0, autoFocus: o3, onKeyDown: R2, onKeyUp: I2, onMouseDown: F2 }, f2, L2, O2);
  return L$2()({ ourProps: U2, theirProps: P2, slot: x2, defaultTag: Ye, name: "Menu.Button" });
}
let et = "div", tt = O$2.RenderStrategy | O$2.Static;
function ot(T2, E2) {
  let i2 = useId$2(), { id: a3 = `headlessui-menu-items-${i2}`, anchor: n2, portal: s2 = !1, modal: o3 = !0, transition: P2 = !1, ...c2 } = T2, _2 = xe(n2), t2 = l("Menu.Items"), [R2, I2] = Re$1(_2), g2 = be$2(), [p2, F2] = useState(null), A2 = y$4(E2, _2 ? R2 : null, o$4((e2) => t2.send({ type: b.SetItemsElement, element: e2 })), F2), [f2, M$12] = S$1(t2, (e2) => [e2.menuState, e2.buttonElement]), L2 = n$1(M$12), S2 = n$1(p2);
  _2 && (s2 = !0);
  let O2 = u$3(), [x2, U2] = x$1(P2, p2, O2 !== null ? (O2 & i$2.Open) === i$2.Open : f2 === M.Open);
  m$2(x2, M$12, () => {
    t2.send({ type: b.CloseMenu });
  });
  let G$12 = S$1(t2, (e2) => e2.__demoMode), l$12 = G$12 ? !1 : o3 && f2 === M.Open;
  f$3(l$12, S2);
  let H2 = G$12 ? !1 : o3 && f2 === M.Open;
  y$3(H2, { allowed: useCallback(() => [M$12, p2], [M$12, p2]) });
  let u2 = f2 !== M.Open, ae = s$1(u2, M$12) ? !1 : x2;
  useEffect(() => {
    let e2 = p2;
    e2 && f2 === M.Open && e2 !== (S2 == null ? void 0 : S2.activeElement) && e2.focus({ preventScroll: !0 });
  }, [f2, p2, S2]), F$2(f2 === M.Open, { container: p2, accept(e2) {
    return e2.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : e2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(e2) {
    e2.setAttribute("role", "none");
  } });
  let q2 = p$2(), se = o$4((e2) => {
    var N2, z, Q;
    switch (q2.dispose(), e2.key) {
      case o$3.Space:
        if (t2.state.searchQuery !== "") return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.Search, value: e2.key });
      case o$3.Enter:
        if (e2.preventDefault(), e2.stopPropagation(), t2.state.activeItemIndex !== null) {
          let { dataRef: de2 } = t2.state.items[t2.state.activeItemIndex];
          (z = (N2 = de2.current) == null ? void 0 : N2.domRef.current) == null || z.click();
        }
        t2.send({ type: b.CloseMenu }), G(t2.state.buttonElement);
        break;
      case o$3.ArrowDown:
        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Next });
      case o$3.ArrowUp:
        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Previous });
      case o$3.Home:
      case o$3.PageUp:
        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.First });
      case o$3.End:
      case o$3.PageDown:
        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Last });
      case o$3.Escape:
        e2.preventDefault(), e2.stopPropagation(), flushSync(() => t2.send({ type: b.CloseMenu })), (Q = t2.state.buttonElement) == null || Q.focus({ preventScroll: !0 });
        break;
      case o$3.Tab:
        e2.preventDefault(), e2.stopPropagation(), flushSync(() => t2.send({ type: b.CloseMenu })), j$2(t2.state.buttonElement, e2.shiftKey ? F$3.Previous : F$3.Next);
        break;
      default:
        e2.key.length === 1 && (t2.send({ type: b.Search, value: e2.key }), q2.setTimeout(() => t2.send({ type: b.ClearSearch }), 350));
        break;
    }
  }), le2 = o$4((e2) => {
    switch (e2.key) {
      case o$3.Space:
        e2.preventDefault();
        break;
    }
  }), pe2 = useMemo(() => ({ open: f2 === M.Open }), [f2]), ie2 = _$3(_2 ? g2() : {}, { "aria-activedescendant": S$1(t2, t2.selectors.activeDescendantId), "aria-labelledby": S$1(t2, (e2) => {
    var N2;
    return (N2 = e2.buttonElement) == null ? void 0 : N2.id;
  }), id: a3, onKeyDown: se, onKeyUp: le2, role: "menu", tabIndex: f2 === M.Open ? 0 : void 0, ref: A2, style: { ...c2.style, ...I2, "--button-width": d$2(M$12, !0).width }, ...R$1(U2) }), ue2 = L$2();
  return React__default.createElement(oe, { enabled: s2 ? T2.static || x2 : !1, ownerDocument: L2 }, ue2({ ourProps: ie2, theirProps: c2, slot: pe2, defaultTag: et, features: tt, visible: ae, name: "Menu.Items" }));
}
let nt = Fragment;
function rt(T$12, E2) {
  let i2 = useId$2(), { id: a3 = `headlessui-menu-item-${i2}`, disabled: n2 = !1, ...s$12 } = T$12, o3 = l("Menu.Item"), P2 = S$1(o3, (u2) => o3.selectors.isActive(u2, a3)), c2 = useRef(null), _2 = y$4(E2, c2), t2 = S$1(o3, (u2) => o3.selectors.shouldScrollIntoView(u2, a3));
  n$3(() => {
    if (t2) return o$5().requestAnimationFrame(() => {
      var u2, J2;
      (J2 = (u2 = c2.current) == null ? void 0 : u2.scrollIntoView) == null || J2.call(u2, { block: "nearest" });
    });
  }, [t2, c2]);
  let R2 = s(c2), I2 = useRef({ disabled: n2, domRef: c2, get textValue() {
    return R2();
  } });
  n$3(() => {
    I2.current.disabled = n2;
  }, [I2, n2]), n$3(() => (o3.actions.registerItem(a3, I2), () => o3.actions.unregisterItem(a3)), [I2, a3]);
  let g2 = o$4(() => {
    o3.send({ type: b.CloseMenu });
  }), p2 = o$4((u2) => {
    if (n2) return u2.preventDefault();
    o3.send({ type: b.CloseMenu }), G(o3.state.buttonElement);
  }), F2 = o$4(() => {
    if (n2) return o3.send({ type: b.GoToItem, focus: c$1.Nothing });
    o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3 });
  }), A2 = u$4(), f2 = o$4((u2) => {
    A2.update(u2), !n2 && (P2 || o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3, trigger: T.Pointer }));
  }), M2 = o$4((u2) => {
    A2.wasMoved(u2) && (n2 || P2 || o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3, trigger: T.Pointer }));
  }), L2 = o$4((u2) => {
    A2.wasMoved(u2) && (n2 || P2 && o3.send({ type: b.GoToItem, focus: c$1.Nothing }));
  }), [S2, O2] = K(), [x2, U2] = w$2(), G$12 = useMemo(() => ({ active: P2, focus: P2, disabled: n2, close: g2 }), [P2, n2, g2]), l$12 = { id: a3, ref: _2, role: "menuitem", tabIndex: n2 === !0 ? void 0 : -1, "aria-disabled": n2 === !0 ? !0 : void 0, "aria-labelledby": S2, "aria-describedby": x2, disabled: void 0, onClick: p2, onFocus: F2, onPointerEnter: f2, onMouseEnter: f2, onPointerMove: M2, onMouseMove: M2, onPointerLeave: L2, onMouseLeave: L2 }, H2 = L$2();
  return React__default.createElement(O2, null, React__default.createElement(U2, null, H2({ ourProps: l$12, theirProps: s$12, slot: G$12, defaultTag: nt, name: "Menu.Item" })));
}
let at$1 = "div";
function st$1(T2, E2) {
  let [i2, a3] = K(), n2 = T2, s2 = { ref: E2, "aria-labelledby": i2, role: "group" }, o3 = L$2();
  return React__default.createElement(a3, null, o3({ ourProps: s2, theirProps: n2, slot: {}, defaultTag: at$1, name: "Menu.Section" }));
}
let lt = "header";
function pt$1(T2, E2) {
  let i2 = useId$2(), { id: a3 = `headlessui-menu-heading-${i2}`, ...n2 } = T2, s2 = P$1();
  n$3(() => s2.register(a3), [a3, s2.register]);
  let o3 = { id: a3, ref: E2, role: "presentation", ...s2.props };
  return L$2()({ ourProps: o3, theirProps: n2, slot: {}, defaultTag: lt, name: "Menu.Heading" });
}
let it$1 = "div";
function ut$1(T2, E2) {
  let i2 = T2, a3 = { ref: E2, role: "separator" };
  return L$2()({ ourProps: a3, theirProps: i2, slot: {}, defaultTag: it$1, name: "Menu.Separator" });
}
let dt$1 = K$1(Qe), mt$1 = K$1(Ze), Tt$1 = K$1(ot), ft$1 = K$1(rt), ct$1 = K$1(st$1), yt$1 = K$1(pt$1), Et$1 = K$1(ut$1), to = Object.assign(dt$1, { Button: mt$1, Items: Tt$1, Item: ft$1, Section: ct$1, Heading: yt$1, Separator: Et$1 });
var at = ((P2) => (P2[P2.Open = 0] = "Open", P2[P2.Closed = 1] = "Closed", P2))(at || {}), pt = ((s2) => (s2[s2.TogglePopover = 0] = "TogglePopover", s2[s2.ClosePopover = 1] = "ClosePopover", s2[s2.SetButton = 2] = "SetButton", s2[s2.SetButtonId = 3] = "SetButtonId", s2[s2.SetPanel = 4] = "SetPanel", s2[s2.SetPanelId = 5] = "SetPanelId", s2))(pt || {});
let st = { 0: (t2) => ({ ...t2, popoverState: u$8(t2.popoverState, { 0: 1, 1: 0 }), __demoMode: !1 }), 1(t2) {
  return t2.popoverState === 1 ? t2 : { ...t2, popoverState: 1, __demoMode: !1 };
}, 2(t2, l2) {
  return t2.button === l2.button ? t2 : { ...t2, button: l2.button };
}, 3(t2, l2) {
  return t2.buttonId === l2.buttonId ? t2 : { ...t2, buttonId: l2.buttonId };
}, 4(t2, l2) {
  return t2.panel === l2.panel ? t2 : { ...t2, panel: l2.panel };
}, 5(t2, l2) {
  return t2.panelId === l2.panelId ? t2 : { ...t2, panelId: l2.panelId };
} }, be = createContext(null);
be.displayName = "PopoverContext";
function ie(t2) {
  let l2 = useContext(be);
  if (l2 === null) {
    let P2 = new Error(`<${t2} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(P2, ie), P2;
  }
  return l2;
}
let de = createContext(null);
de.displayName = "PopoverAPIContext";
function ge(t2) {
  let l2 = useContext(de);
  if (l2 === null) {
    let P2 = new Error(`<${t2} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(P2, ge), P2;
  }
  return l2;
}
let Se = createContext(null);
Se.displayName = "PopoverGroupContext";
function Oe() {
  return useContext(Se);
}
let Pe = createContext(null);
Pe.displayName = "PopoverPanelContext";
function ut() {
  return useContext(Pe);
}
function it(t2, l2) {
  return u$8(l2.type, st, t2, l2);
}
let dt = "div";
function Pt(t2, l2) {
  var q2;
  let { __demoMode: P2 = !1, ...C2 } = t2, m2 = useRef(null), A$12 = y$4(l2, T$3((a3) => {
    m2.current = a3;
  })), s2 = useRef([]), n2 = useReducer(it, { __demoMode: P2, popoverState: P2 ? 0 : 1, buttons: s2, button: null, buttonId: null, panel: null, panelId: null, beforePanelSentinel: createRef(), afterPanelSentinel: createRef(), afterButtonSentinel: createRef() }), [{ popoverState: v2, button: i2, buttonId: o3, panel: u2, panelId: R$12, beforePanelSentinel: y2, afterPanelSentinel: h2, afterButtonSentinel: d2 }, r2] = n2, T2 = n$1((q2 = m2.current) != null ? q2 : i2), g2 = useMemo(() => {
    if (!i2 || !u2) return !1;
    for (let S2 of document.querySelectorAll("body > *")) if (Number(S2 == null ? void 0 : S2.contains(i2)) ^ Number(S2 == null ? void 0 : S2.contains(u2))) return !0;
    let a3 = b$3(), e2 = a3.indexOf(i2), p2 = (e2 + a3.length - 1) % a3.length, f2 = (e2 + 1) % a3.length, c2 = a3[p2], O2 = a3[f2];
    return !u2.contains(c2) && !u2.contains(O2);
  }, [i2, u2]), _2 = s$8(o3), L2 = s$8(R$12), I2 = useMemo(() => ({ buttonId: _2, panelId: L2, close: () => r2({ type: 1 }) }), [_2, L2, r2]), M2 = Oe(), k2 = M2 == null ? void 0 : M2.registerPopover, V2 = o$4(() => {
    var a3;
    return (a3 = M2 == null ? void 0 : M2.isFocusWithinPopoverGroup()) != null ? a3 : (T2 == null ? void 0 : T2.activeElement) && ((i2 == null ? void 0 : i2.contains(T2.activeElement)) || (u2 == null ? void 0 : u2.contains(T2.activeElement)));
  });
  useEffect(() => k2 == null ? void 0 : k2(I2), [k2, I2]);
  let [B2, U2] = le(), F2 = b$1(i2), N2 = R({ mainTreeNode: F2, portals: B2, defaultContainers: [i2, u2] });
  E(T2 == null ? void 0 : T2.defaultView, "focus", (a3) => {
    var e2, p2, f2, c2, O2, S2;
    a3.target !== window && a3.target instanceof HTMLElement && v2 === 0 && (V2() || i2 && u2 && (N2.contains(a3.target) || (p2 = (e2 = y2.current) == null ? void 0 : e2.contains) != null && p2.call(e2, a3.target) || (c2 = (f2 = h2.current) == null ? void 0 : f2.contains) != null && c2.call(f2, a3.target) || (S2 = (O2 = d2.current) == null ? void 0 : O2.contains) != null && S2.call(O2, a3.target) || r2({ type: 1 })));
  }, !0), R$2(v2 === 0, N2.resolveContainers, (a3, e2) => {
    r2({ type: 1 }), A(e2, h$2.Loose) || (a3.preventDefault(), i2 == null || i2.focus());
  });
  let x2 = o$4((a3) => {
    r2({ type: 1 });
    let e2 = a3 ? a3 instanceof HTMLElement ? a3 : "current" in a3 && a3.current instanceof HTMLElement ? a3.current : i2 : i2;
    e2 == null || e2.focus();
  }), ee = useMemo(() => ({ close: x2, isPortalled: g2 }), [x2, g2]), $2 = useMemo(() => ({ open: v2 === 0, close: x2 }), [v2, x2]), J2 = { ref: A$12 }, X2 = L$2();
  return React__default.createElement(O, { node: F2 }, React__default.createElement(Me, null, React__default.createElement(Pe.Provider, { value: null }, React__default.createElement(be.Provider, { value: n2 }, React__default.createElement(de.Provider, { value: ee }, React__default.createElement(C$1, { value: x2 }, React__default.createElement(c$3, { value: u$8(v2, { 0: i$2.Open, 1: i$2.Closed }) }, React__default.createElement(U2, null, X2({ ourProps: J2, theirProps: C2, slot: $2, defaultTag: dt, name: "Popover" })))))))));
}
let ft = "button";
function ct(t2, l2) {
  let P$12 = useId$2(), { id: C2 = `headlessui-popover-button-${P$12}`, disabled: m2 = !1, autoFocus: A2 = !1, ...s2 } = t2, [n2, v2] = ie("Popover.Button"), { isPortalled: i2 } = ge("Popover.Button"), o3 = useRef(null), u$12 = `headlessui-focus-sentinel-${useId$2()}`, R2 = Oe(), y2 = R2 == null ? void 0 : R2.closeOthers, d2 = ut() !== null;
  useEffect(() => {
    if (!d2) return v2({ type: 3, buttonId: C2 }), () => {
      v2({ type: 3, buttonId: null });
    };
  }, [d2, C2, v2]);
  let [r2] = useState(() => Symbol()), T2 = y$4(o3, l2, ye$1(), o$4((e2) => {
    if (!d2) {
      if (e2) n2.buttons.current.push(r2);
      else {
        let p2 = n2.buttons.current.indexOf(r2);
        p2 !== -1 && n2.buttons.current.splice(p2, 1);
      }
      n2.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), e2 && v2({ type: 2, button: e2 });
    }
  })), g2 = y$4(o3, l2), _2 = n$1(o3), L2 = o$4((e2) => {
    var p2, f2, c2;
    if (d2) {
      if (n2.popoverState === 1) return;
      switch (e2.key) {
        case o$3.Space:
        case o$3.Enter:
          e2.preventDefault(), (f2 = (p2 = e2.target).click) == null || f2.call(p2), v2({ type: 1 }), (c2 = n2.button) == null || c2.focus();
          break;
      }
    } else switch (e2.key) {
      case o$3.Space:
      case o$3.Enter:
        e2.preventDefault(), e2.stopPropagation(), n2.popoverState === 1 && (y2 == null || y2(n2.buttonId)), v2({ type: 0 });
        break;
      case o$3.Escape:
        if (n2.popoverState !== 0) return y2 == null ? void 0 : y2(n2.buttonId);
        if (!o3.current || _2 != null && _2.activeElement && !o3.current.contains(_2.activeElement)) return;
        e2.preventDefault(), e2.stopPropagation(), v2({ type: 1 });
        break;
    }
  }), I2 = o$4((e2) => {
    d2 || e2.key === o$3.Space && e2.preventDefault();
  }), M2 = o$4((e2) => {
    var p2, f2;
    r$1(e2.currentTarget) || m2 || (d2 ? (v2({ type: 1 }), (p2 = n2.button) == null || p2.focus()) : (e2.preventDefault(), e2.stopPropagation(), n2.popoverState === 1 && (y2 == null || y2(n2.buttonId)), v2({ type: 0 }), (f2 = n2.button) == null || f2.focus()));
  }), k2 = o$4((e2) => {
    e2.preventDefault(), e2.stopPropagation();
  }), { isFocusVisible: V2, focusProps: B2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: A2 }), { isHovered: U2, hoverProps: F2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: m2 }), { pressed: N2, pressProps: Z } = w$3({ disabled: m2 }), x2 = n2.popoverState === 0, ee = useMemo(() => ({ open: x2, active: N2 || x2, disabled: m2, hover: U2, focus: V2, autofocus: A2 }), [x2, U2, V2, N2, m2, A2]), $2 = e$1(t2, n2.button), J2 = _$3(d2 ? { ref: g2, type: $2, onKeyDown: L2, onClick: M2, disabled: m2 || void 0, autoFocus: A2 } : { ref: T2, id: n2.buttonId, type: $2, "aria-expanded": n2.popoverState === 0, "aria-controls": n2.panel ? n2.panelId : void 0, disabled: m2 || void 0, autoFocus: A2, onKeyDown: L2, onKeyUp: I2, onClick: M2, onMouseDown: k2 }, B2, F2, Z), X2 = u(), q2 = o$4(() => {
    let e2 = n2.panel;
    if (!e2) return;
    function p2() {
      u$8(X2.current, { [a$3.Forwards]: () => P(e2, F$3.First), [a$3.Backwards]: () => P(e2, F$3.Last) }) === T$2.Error && P(b$3().filter((c2) => c2.dataset.headlessuiFocusGuard !== "true"), u$8(X2.current, { [a$3.Forwards]: F$3.Next, [a$3.Backwards]: F$3.Previous }), { relativeTo: n2.button });
    }
    p2();
  }), a3 = L$2();
  return React__default.createElement(React__default.Fragment, null, a3({ ourProps: J2, theirProps: s2, slot: ee, defaultTag: ft, name: "Popover.Button" }), x2 && !d2 && i2 && React__default.createElement(f$8, { id: u$12, ref: n2.afterButtonSentinel, features: s$7.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: q2 }));
}
let vt = "div", Tt = O$2.RenderStrategy | O$2.Static;
function Le(t2, l2) {
  let P2 = useId$2(), { id: C2 = `headlessui-popover-backdrop-${P2}`, transition: m2 = !1, ...A2 } = t2, [{ popoverState: s2 }, n2] = ie("Popover.Backdrop"), [v2, i2] = useState(null), o3 = y$4(l2, i2), u2 = u$3(), [R2, y2] = x$1(m2, v2, u2 !== null ? (u2 & i$2.Open) === i$2.Open : s2 === 0), h2 = o$4((g2) => {
    if (r$1(g2.currentTarget)) return g2.preventDefault();
    n2({ type: 1 });
  }), d2 = useMemo(() => ({ open: s2 === 0 }), [s2]), r2 = { ref: o3, id: C2, "aria-hidden": !0, onClick: h2, ...R$1(y2) };
  return L$2()({ ourProps: r2, theirProps: A2, slot: d2, defaultTag: vt, features: Tt, visible: R2, name: "Popover.Backdrop" });
}
let mt = "div", yt = O$2.RenderStrategy | O$2.Static;
function Et(t2, l2) {
  let P$12 = useId$2(), { id: C2 = `headlessui-popover-panel-${P$12}`, focus: m2 = !1, anchor: A2, portal: s2 = !1, modal: n2 = !1, transition: v2 = !1, ...i2 } = t2, [o3, u$12] = ie("Popover.Panel"), { close: R2, isPortalled: y2 } = ge("Popover.Panel"), h2 = `headlessui-focus-sentinel-before-${P$12}`, d2 = `headlessui-focus-sentinel-after-${P$12}`, r2 = useRef(null), T2 = xe(A2), [g2, _2] = Re$1(T2), L2 = be$2();
  T2 && (s2 = !0);
  let [I2, M2] = useState(null), k2 = y$4(r2, l2, T2 ? g2 : null, o$4((e2) => u$12({ type: 4, panel: e2 })), M2), V2 = n$1(o3.button), B2 = n$1(r2);
  n$3(() => (u$12({ type: 5, panelId: C2 }), () => {
    u$12({ type: 5, panelId: null });
  }), [C2, u$12]);
  let U2 = u$3(), [F2, N2] = x$1(v2, I2, U2 !== null ? (U2 & i$2.Open) === i$2.Open : o3.popoverState === 0);
  m$2(F2, o3.button, () => {
    u$12({ type: 1 });
  });
  let Z = o3.__demoMode ? !1 : n2 && F2;
  f$3(Z, B2);
  let x2 = o$4((e2) => {
    var p2;
    switch (e2.key) {
      case o$3.Escape:
        if (o3.popoverState !== 0 || !r2.current || B2 != null && B2.activeElement && !r2.current.contains(B2.activeElement)) return;
        e2.preventDefault(), e2.stopPropagation(), u$12({ type: 1 }), (p2 = o3.button) == null || p2.focus();
        break;
    }
  });
  useEffect(() => {
    var e2;
    t2.static || o3.popoverState === 1 && ((e2 = t2.unmount) == null || e2) && u$12({ type: 4, panel: null });
  }, [o3.popoverState, t2.unmount, t2.static, u$12]), useEffect(() => {
    if (o3.__demoMode || !m2 || o3.popoverState !== 0 || !r2.current) return;
    let e2 = B2 == null ? void 0 : B2.activeElement;
    r2.current.contains(e2) || P(r2.current, F$3.First);
  }, [o3.__demoMode, m2, r2.current, o3.popoverState]);
  let ee = useMemo(() => ({ open: o3.popoverState === 0, close: R2 }), [o3.popoverState, R2]), $2 = _$3(T2 ? L2() : {}, { ref: k2, id: C2, onKeyDown: x2, onBlur: m2 && o3.popoverState === 0 ? (e2) => {
    var f2, c2, O2, S2, w2;
    let p2 = e2.relatedTarget;
    p2 && r2.current && ((f2 = r2.current) != null && f2.contains(p2) || (u$12({ type: 1 }), ((O2 = (c2 = o3.beforePanelSentinel.current) == null ? void 0 : c2.contains) != null && O2.call(c2, p2) || (w2 = (S2 = o3.afterPanelSentinel.current) == null ? void 0 : S2.contains) != null && w2.call(S2, p2)) && p2.focus({ preventScroll: !0 })));
  } : void 0, tabIndex: -1, style: { ...i2.style, ..._2, "--button-width": d$2(o3.button, !0).width }, ...R$1(N2) }), J2 = u(), X2 = o$4(() => {
    let e2 = r2.current;
    if (!e2) return;
    function p2() {
      u$8(J2.current, { [a$3.Forwards]: () => {
        var c2;
        P(e2, F$3.First) === T$2.Error && ((c2 = o3.afterPanelSentinel.current) == null || c2.focus());
      }, [a$3.Backwards]: () => {
        var f2;
        (f2 = o3.button) == null || f2.focus({ preventScroll: !0 });
      } });
    }
    p2();
  }), q2 = o$4(() => {
    let e2 = r2.current;
    if (!e2) return;
    function p2() {
      u$8(J2.current, { [a$3.Forwards]: () => {
        if (!o3.button) return;
        let f2 = b$3(), c2 = f2.indexOf(o3.button), O2 = f2.slice(0, c2 + 1), w2 = [...f2.slice(c2 + 1), ...O2];
        for (let fe2 of w2.slice()) if (fe2.dataset.headlessuiFocusGuard === "true" || I2 != null && I2.contains(fe2)) {
          let Ae2 = w2.indexOf(fe2);
          Ae2 !== -1 && w2.splice(Ae2, 1);
        }
        P(w2, F$3.First, { sorted: !1 });
      }, [a$3.Backwards]: () => {
        var c2;
        P(e2, F$3.Previous) === T$2.Error && ((c2 = o3.button) == null || c2.focus());
      } });
    }
    p2();
  }), a3 = L$2();
  return React__default.createElement(s$5, null, React__default.createElement(Pe.Provider, { value: C2 }, React__default.createElement(de.Provider, { value: { close: R2, isPortalled: y2 } }, React__default.createElement(oe, { enabled: s2 ? t2.static || F2 : !1, ownerDocument: V2 }, F2 && y2 && React__default.createElement(f$8, { id: h2, ref: o3.beforePanelSentinel, features: s$7.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: X2 }), a3({ ourProps: $2, theirProps: i2, slot: ee, defaultTag: mt, features: yt, visible: F2, name: "Popover.Panel" }), F2 && y2 && React__default.createElement(f$8, { id: d2, ref: o3.afterPanelSentinel, features: s$7.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: q2 })))));
}
let bt = "div";
function gt(t2, l2) {
  let P2 = useRef(null), C2 = y$4(P2, l2), [m2, A2] = useState([]), s2 = o$4((d2) => {
    A2((r2) => {
      let T2 = r2.indexOf(d2);
      if (T2 !== -1) {
        let g2 = r2.slice();
        return g2.splice(T2, 1), g2;
      }
      return r2;
    });
  }), n2 = o$4((d2) => (A2((r2) => [...r2, d2]), () => s2(d2))), v2 = o$4(() => {
    var T2;
    let d2 = o$6(P2);
    if (!d2) return !1;
    let r2 = d2.activeElement;
    return (T2 = P2.current) != null && T2.contains(r2) ? !0 : m2.some((g2) => {
      var _2, L2;
      return ((_2 = d2.getElementById(g2.buttonId.current)) == null ? void 0 : _2.contains(r2)) || ((L2 = d2.getElementById(g2.panelId.current)) == null ? void 0 : L2.contains(r2));
    });
  }), i2 = o$4((d2) => {
    for (let r2 of m2) r2.buttonId.current !== d2 && r2.close();
  }), o3 = useMemo(() => ({ registerPopover: n2, unregisterPopover: s2, isFocusWithinPopoverGroup: v2, closeOthers: i2 }), [n2, s2, v2, i2]), u2 = useMemo(() => ({}), []), R2 = t2, y2 = { ref: C2 }, h2 = L$2();
  return React__default.createElement(O, null, React__default.createElement(Se.Provider, { value: o3 }, h2({ ourProps: y2, theirProps: R2, slot: u2, defaultTag: bt, name: "Popover.Group" })));
}
let St = K$1(Pt), At = K$1(ct), Ct = K$1(Le), Rt = K$1(Le), Bt = K$1(Et), _t = K$1(gt), ao = Object.assign(St, { Button: At, Backdrop: Rt, Overlay: Ct, Panel: Bt, Group: _t }), L = "textarea";
function H(s2, l2) {
  let i2 = useId$2(), d2 = u$7(), n2 = a$d(), { id: p2 = d2 || `headlessui-textarea-${i2}`, disabled: e2 = n2 || !1, autoFocus: r2 = !1, invalid: a3 = !1, ...T2 } = s2, f2 = I$2(), m2 = U$2(), { isFocused: o3, focusProps: u2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r2 }), { isHovered: t2, hoverProps: b2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e2 }), y2 = _$3({ ref: l2, id: p2, "aria-labelledby": f2, "aria-describedby": m2, "aria-invalid": a3 ? "true" : void 0, disabled: e2 || void 0, autoFocus: r2 }, u2, b2), x2 = useMemo(() => ({ disabled: e2, invalid: a3, hover: t2, focus: o3, autofocus: r2 }), [e2, a3, t2, o3, r2]);
  return L$2()({ ourProps: y2, theirProps: T2, slot: x2, defaultTag: L, name: "Textarea" });
}
let J = K$1(H);
function ToolbarItem(props) {
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "relative flex h-8 w-8 shrink-0 items-center justify-center",
        props.className
      ),
      children: [
        props.children,
        props.badgeContent && /* @__PURE__ */ jsx(
          "div",
          {
            className: cn(
              "bg-blue-600 text-white",
              props.badgeClassName,
              "pointer-events-none absolute right-0 bottom-0 flex h-3 w-max min-w-3 max-w-8 select-none items-center justify-center truncate rounded-full px-0.5 font-semibold text-[0.5em]"
            ),
            children: props.badgeContent
          }
        ),
        props.statusDot && /* @__PURE__ */ jsx(
          "div",
          {
            className: cn(
              "bg-rose-600 text-white",
              props.statusDotClassName,
              "pointer-events-none absolute top-0 right-0 size-1.5 rounded-full"
            )
          }
        )
      ]
    }
  );
}
const ToolbarButton = forwardRef(
  ({
    badgeContent,
    badgeClassName,
    statusDot,
    statusDotClassName,
    tooltipHint,
    variant = "default",
    active,
    itemClassName,
    ...props
  }, ref) => {
    const button = /* @__PURE__ */ jsx(
      H$5,
      {
        ref,
        ...props,
        className: cn(
          "flex cursor-pointer items-center justify-center rounded-full bg-radial from-transparent to-transparent p-1 text-current transition-all duration-150 hover:from-20% hover:from-zinc-100/40 hover:to-75% hover:to-zinc-100/0",
          variant === "default" ? "size-8" : "h-8 rounded-full",
          active && "from-30% from-zinc-100/60 to-75% to-zinc-100/0 fill-[var(--active)] stroke-[var(--active)] text-[var(--active)]",
          props.className
        )
      }
    );
    return /* @__PURE__ */ jsx(
      ToolbarItem,
      {
        badgeContent,
        badgeClassName,
        statusDot,
        statusDotClassName,
        className: itemClassName,
        children: button
      }
    );
  }
);
ToolbarButton.displayName = "ToolbarButton";
function ToolbarSection({ children }) {
  return /* @__PURE__ */ jsx("div", { className: "fade-in slide-in-from-right-2 flex max-h-sm max-w-full animate-in snap-start flex-col items-center justify-between gap-1 py-0.5", children });
}
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string2) => string2.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), toCamelCase = (string2) => string2.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
), toPascalCase = (string2) => {
  const camelCase = toCamelCase(string2);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
}, mergeClasses = (...classes) => classes.filter((className, index2, array) => !!className && className.trim() !== "" && array.indexOf(className) === index2).join(" ").trim(), hasA11yProp = (props) => {
  for (const prop in props)
    if (prop.startsWith("aria-") || prop === "role" || prop === "title")
      return !0;
};
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = forwardRef(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => createElement(
    "svg",
    {
      ref,
      ...defaultAttributes,
      width: size2,
      height: size2,
      stroke: color,
      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
      className: mergeClasses("lucide", className),
      ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
      ...rest
    },
    [
      ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
      ...Array.isArray(children) ? children : [children]
    ]
  )
);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = forwardRef(
    ({ className, ...props }, ref) => createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props
    })
  );
  return Component.displayName = toPascalCase(iconName), Component;
};
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$r = [
  ["path", { d: "M3 12h18", key: "1i2n21" }],
  ["path", { d: "M3 18h18", key: "1h113x" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }]
], AlignJustify = createLucideIcon("align-justify", __iconNode$r);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$q = [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
], ArrowUp = createLucideIcon("arrow-up", __iconNode$q);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$p = [
  [
    "path",
    {
      d: "M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z",
      key: "l5xja"
    }
  ],
  [
    "path",
    {
      d: "M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z",
      key: "ep3f8r"
    }
  ],
  ["path", { d: "M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4", key: "1p4c4q" }],
  ["path", { d: "M17.599 6.5a3 3 0 0 0 .399-1.375", key: "tmeiqw" }],
  ["path", { d: "M6.003 5.125A3 3 0 0 0 6.401 6.5", key: "105sqy" }],
  ["path", { d: "M3.477 10.896a4 4 0 0 1 .585-.396", key: "ql3yin" }],
  ["path", { d: "M19.938 10.5a4 4 0 0 1 .585.396", key: "1qfode" }],
  ["path", { d: "M6 18a4 4 0 0 1-1.967-.516", key: "2e4loj" }],
  ["path", { d: "M19.967 17.484A4 4 0 0 1 18 18", key: "159ez6" }]
], Brain = createLucideIcon("brain", __iconNode$p);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$o = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], Check = createLucideIcon("check", __iconNode$o);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$n = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], ChevronDown = createLucideIcon("chevron-down", __iconNode$n);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$m = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], ChevronRight = createLucideIcon("chevron-right", __iconNode$m);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$l = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], ChevronUp = createLucideIcon("chevron-up", __iconNode$l);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$k = [
  ["path", { d: "M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z", key: "sobvz5" }],
  ["path", { d: "M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", key: "11i496" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M12 22v-2", key: "1osdcq" }],
  ["path", { d: "m17 20.66-1-1.73", key: "eq3orb" }],
  ["path", { d: "M11 10.27 7 3.34", key: "16pf9h" }],
  ["path", { d: "m20.66 17-1.73-1", key: "sg0v6f" }],
  ["path", { d: "m3.34 7 1.73 1", key: "1ulond" }],
  ["path", { d: "M14 12h8", key: "4f43i9" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "m20.66 7-1.73 1", key: "1ow05n" }],
  ["path", { d: "m3.34 17 1.73-1", key: "nuk764" }],
  ["path", { d: "m17 3.34-1 1.73", key: "2wel8s" }],
  ["path", { d: "m11 13.73-4 6.93", key: "794ttg" }]
], Cog = createLucideIcon("cog", __iconNode$k);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$j = [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], Eye = createLucideIcon("eye", __iconNode$j);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$i = [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }]
], File = createLucideIcon("file", __iconNode$i);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$h = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], LoaderCircle = createLucideIcon("loader-circle", __iconNode$h);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$g = [
  ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
], MessageCircleQuestionMark = createLucideIcon("message-circle-question-mark", __iconNode$g);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$f = [
  ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }]
], MessageCircle = createLucideIcon("message-circle", __iconNode$f);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$e = [
  ["path", { d: "M12.586 12.586 19 19", key: "ea5xo7" }],
  [
    "path",
    {
      d: "M3.688 3.037a.497.497 0 0 0-.651.651l6.5 15.999a.501.501 0 0 0 .947-.062l1.569-6.083a2 2 0 0 1 1.448-1.479l6.124-1.579a.5.5 0 0 0 .063-.947z",
      key: "277e5u"
    }
  ]
], MousePointer = createLucideIcon("mouse-pointer", __iconNode$e);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$d = [
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu"
    }
  ],
  ["path", { d: "m15 5 4 4", key: "1mk7zo" }]
], Pencil = createLucideIcon("pencil", __iconNode$d);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$c = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], Plus = createLucideIcon("plus", __iconNode$c);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$b = [
  [
    "path",
    {
      d: "M15.39 4.39a1 1 0 0 0 1.68-.474 2.5 2.5 0 1 1 3.014 3.015 1 1 0 0 0-.474 1.68l1.683 1.682a2.414 2.414 0 0 1 0 3.414L19.61 15.39a1 1 0 0 1-1.68-.474 2.5 2.5 0 1 0-3.014 3.015 1 1 0 0 1 .474 1.68l-1.683 1.682a2.414 2.414 0 0 1-3.414 0L8.61 19.61a1 1 0 0 0-1.68.474 2.5 2.5 0 1 1-3.014-3.015 1 1 0 0 0 .474-1.68l-1.683-1.682a2.414 2.414 0 0 1 0-3.414L4.39 8.61a1 1 0 0 1 1.68.474 2.5 2.5 0 1 0 3.014-3.015 1 1 0 0 1-.474-1.68l1.683-1.682a2.414 2.414 0 0 1 3.414 0z",
      key: "w46dr5"
    }
  ]
], Puzzle = createLucideIcon("puzzle", __iconNode$b);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$a = [
  ["path", { d: "m15 14 5-5-5-5", key: "12vg1m" }],
  ["path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13", key: "6uklza" }]
], Redo2 = createLucideIcon("redo-2", __iconNode$a);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$9 = [
  ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }],
  ["path", { d: "M16 16h5v5", key: "ccwih5" }]
], RefreshCcw = createLucideIcon("refresh-ccw", __iconNode$9);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$8 = [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
], Search = createLucideIcon("search", __iconNode$8);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$7 = [
  [
    "path",
    {
      d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
      key: "4pj2yx"
    }
  ],
  ["path", { d: "M20 3v4", key: "1olli1" }],
  ["path", { d: "M22 5h-4", key: "1gvqau" }],
  ["path", { d: "M4 17v2", key: "vumght" }],
  ["path", { d: "M5 18H3", key: "zchphs" }]
], Sparkles = createLucideIcon("sparkles", __iconNode$7);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$6 = [
  [
    "path",
    {
      d: "M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z",
      key: "xwnzip"
    }
  ],
  ["path", { d: "M5 3a2 2 0 0 0-2 2", key: "y57alp" }],
  ["path", { d: "M19 3a2 2 0 0 1 2 2", key: "18rm91" }],
  ["path", { d: "M5 21a2 2 0 0 1-2-2", key: "sbafld" }],
  ["path", { d: "M9 3h1", key: "1yesri" }],
  ["path", { d: "M9 21h2", key: "1qve2z" }],
  ["path", { d: "M14 3h1", key: "1ec4yj" }],
  ["path", { d: "M3 9v1", key: "1r0deq" }],
  ["path", { d: "M21 9v2", key: "p14lih" }],
  ["path", { d: "M3 14v1", key: "vnatye" }]
], SquareDashedMousePointer = createLucideIcon("square-dashed-mouse-pointer", __iconNode$6);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$5 = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
], Square = createLucideIcon("square", __iconNode$5);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$4 = [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
], Trash2 = createLucideIcon("trash-2", __iconNode$4);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$3 = [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
], Trash = createLucideIcon("trash", __iconNode$3);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$2 = [
  ["path", { d: "M9 14 4 9l5-5", key: "102s5s" }],
  ["path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11", key: "f3b9sd" }]
], Undo2 = createLucideIcon("undo-2", __iconNode$2);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$1 = [
  ["path", { d: "M12 20h.01", key: "zekei9" }],
  ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0", key: "1bycff" }],
  ["path", { d: "M5 12.859a10 10 0 0 1 5.17-2.69", key: "1dl1wf" }],
  ["path", { d: "M19 12.859a10 10 0 0 0-2.007-1.523", key: "4k23kn" }],
  ["path", { d: "M2 8.82a15 15 0 0 1 4.177-2.643", key: "1grhjp" }],
  ["path", { d: "M22 8.82a15 15 0 0 0-11.288-3.764", key: "z3jwby" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
], WifiOff = createLucideIcon("wifi-off", __iconNode$1);
/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], X = createLucideIcon("x", __iconNode);
function RegularContent() {
  const {
    isChatOpen,
    openChat,
    closeChat,
    openPluginName,
    closePlugin,
    openPlugin
  } = usePanels(), { startPromptCreation } = useChatState(), pluginsWithActions = usePlugins().plugins.filter(
    (plugin) => plugin.onActionClick
  );
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    pluginsWithActions.length > 0 && /* @__PURE__ */ jsx(ToolbarSection, { children: pluginsWithActions.map((plugin) => /* @__PURE__ */ jsx(
      ToolbarButton,
      {
        onClick: openPluginName === plugin.pluginName ? closePlugin : () => openPlugin(plugin.pluginName),
        active: openPluginName === plugin.pluginName,
        children: plugin.iconSvg ? /* @__PURE__ */ jsx("span", { className: "size-4 *:size-full", children: plugin.iconSvg }) : /* @__PURE__ */ jsx(Puzzle, { className: "size-4" })
      },
      plugin.pluginName
    )) }),
    /* @__PURE__ */ jsx(ToolbarSection, { children: /* @__PURE__ */ jsx(
      ToolbarButton,
      {
        onClick: isChatOpen ? closeChat : () => {
          openChat(), startPromptCreation();
        },
        active: isChatOpen,
        children: /* @__PURE__ */ jsx(MessageCircle, { className: "size-4" })
      }
    ) })
  ] });
}
function DisconnectedContent() {
  return /* @__PURE__ */ jsx(ToolbarSection, { children: /* @__PURE__ */ jsx(ToolbarItem, { children: /* @__PURE__ */ jsx(LoaderCircle, { className: "size-4 animate-spin" }) }) });
}
const Logo = ({
  color = "default",
  loading = !1,
  loadingSpeed = "slow",
  ...props
}) => {
  const colorStyle = {
    default: "fill-stagewise-700 stroke-none",
    black: "fill-zinc-950 stroke-none",
    white: "fill-white stroke-none",
    zinc: "fill-zinc-500/50 stroke-none",
    current: "fill-current stroke-none",
    gradient: "fill-white stroke-black/30 stroke-1"
  };
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: `relative ${color === "gradient" ? "rounded-full bg-[image:var(--gradient)] bg-cover bg-no-repeat" : ""} ${props.className || ""} ${loading ? "drop-shadow-xl" : ""} aspect-square overflow-visible`,
      children: [
        /* @__PURE__ */ jsxs(
          "svg",
          {
            className: `absolute overflow-visible ${color === "gradient" ? "top-[25%] left-[25%] h-[50%] w-[50%]" : "top-0 left-0 h-full w-full"}`,
            viewBox: "0 0 2048 2048",
            children: [
              /* @__PURE__ */ jsx("title", { children: "stagewise" }),
              /* @__PURE__ */ jsx(
                "ellipse",
                {
                  className: colorStyle[color] + (loading ? " animate-pulse" : ""),
                  id: "path3",
                  ry: "624",
                  rx: "624",
                  cy: "1024",
                  cx: "1024"
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsx(
          "svg",
          {
            className: `absolute overflow-visible ${color === "gradient" ? "top-[25%] left-[25%] h-[50%] w-[50%]" : "top-0 left-0 h-full w-full"}`,
            viewBox: "0 0 2048 2048",
            children: /* @__PURE__ */ jsx(
              "path",
              {
                id: "path4",
                className: "origin-center " + colorStyle[color] + (loading ? loadingSpeed === "fast" ? " animate-spin-fast" : " animate-spin-slow" : ""),
                d: "M 1024 0 A 1024 1024 0 0 0 0 1024 A 1024 1024 0 0 0 1024 2048 L 1736 2048 L 1848 2048 C 1958.7998 2048 2048 1958.7998 2048 1848 L 2048 1736 L 2048 1024 A 1024 1024 0 0 0 1024 0 z M 1024.9414 200 A 824 824 0 0 1 1848.9414 1024 A 824 824 0 0 1 1024.9414 1848 A 824 824 0 0 1 200.94141 1024 A 824 824 0 0 1 1024.9414 200 z "
              }
            )
          }
        )
      ]
    }
  );
}, AnimatedGradientBackground = ({
  className
}) => /* @__PURE__ */ jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 800 800",
    preserveAspectRatio: "xMidYMid slice",
    className,
    children: [
      /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("filter", { id: "blur", x: "-50%", y: "-50%", width: "200%", height: "200%", children: /* @__PURE__ */ jsx("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "80" }) }) }),
      /* @__PURE__ */ jsx("rect", { width: "800", height: "800", fill: "#000f68" }),
      /* @__PURE__ */ jsxs("g", { filter: "url(#blur)", children: [
        /* @__PURE__ */ jsxs("circle", { cx: "100", cy: "400", r: "260", fill: "#1e90ff", children: [
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cx",
              dur: "15s",
              begin: "0s",
              values: "100; 700; 100",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          ),
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cy",
              dur: "20s",
              begin: "0.1s",
              values: "400; 100; 400",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          )
        ] }),
        /* @__PURE__ */ jsxs("circle", { cx: "700", cy: "100", r: "220", fill: "#c300ff", children: [
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cx",
              dur: "12s",
              begin: "0.2s",
              values: "700; 100; 700",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          ),
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cy",
              dur: "10s",
              begin: "0.3s",
              values: "100; 700; 100",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          )
        ] }),
        /* @__PURE__ */ jsxs("circle", { cx: "400", cy: "700", r: "240", fill: "#0055ff", children: [
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cx",
              dur: "18s",
              begin: "0.4s",
              values: "400; 500; 200; 400",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.33; 0.67; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          ),
          /* @__PURE__ */ jsx(
            "animate",
            {
              attributeName: "cy",
              dur: "22s",
              begin: "0.5s",
              values: "700; 400; 700",
              repeatCount: "indefinite",
              calcMode: "spline",
              keyTimes: "0; 0.5; 1",
              keySplines: "0.42 0 0.58 1; 0.42 0 0.58 1"
            }
          )
        ] })
      ] })
    ]
  }
);
function Toolbar({
  draggableHandleRef,
  position: position2,
  isDragged
}) {
  const { minimized, minimize, expand } = useAppState(), isConnected = useKartonConnected(), [isInitialLoad, setIsInitialLoad] = useState(!0);
  return useEffect(() => {
    const timer = setTimeout(() => {
      setIsInitialLoad(!1);
    }, 200);
    return () => clearTimeout(timer);
  }, []), /* @__PURE__ */ jsxs(
    Glassy,
    {
      as: "div",
      className: cn(
        "pointer-events-auto absolute z-10 origin-center rounded-full p-0.5 shadow-md transition-transform duration-500 ease-spring",
        minimized || isInitialLoad ? "size-10 bg-blue-950/80" : "size-auto",
        isDragged && "scale-110 bg-sky-100/60 shadow-lg shadow-sky-500/10 blur-[0.2px]",
        isConnected || isInitialLoad ? "[--active-secondary:var(--color-blue-100)] [--active:var(--color-blue-600)] [--primary:var(--color-zinc-950)] [--secondary:var(--color-zinc-400)]" : "bg-orange-200/50 [--active-secondary:var(--color-orange-100)] [--active:var(--color-orange-600)] [--primary:var(--color-orange-900)] [--secondary:var(--color-orange-100)]",
        "stroke-[var(--primary)] text-[var(--primary)]"
      ),
      ref: draggableHandleRef,
      children: [
        /* @__PURE__ */ jsxs(
          H$5,
          {
            onClick: () => expand(),
            className: cn(
              "absolute left-0 z-50 flex size-10 origin-center cursor-pointer items-center justify-center overflow-hidden rounded-full border border-zinc-500/20 transition-all duration-500 ease-spring hover:opacity-90",
              minimized || isInitialLoad ? "pointer-events-auto scale-100 opacity-100 blur-none" : "pointer-events-none scale-25 opacity-0 blur-md",
              position2.isTopHalf ? "top-0" : "bottom-0",
              !isConnected && !isInitialLoad && "bg-orange-500"
            ),
            children: [
              isConnected && !isInitialLoad && /* @__PURE__ */ jsxs(Fragment$1, { children: [
                /* @__PURE__ */ jsx(AnimatedGradientBackground, { className: "-z-10 absolute inset-0 size-full" }),
                /* @__PURE__ */ jsx(Logo, { color: "white", className: "mr-px mb-px size-1/2 shadow-2xs" })
              ] }),
              !isConnected && !isInitialLoad && /* @__PURE__ */ jsx(WifiOff, { className: "size-5 stroke-white" })
            ]
          }
        ),
        /* @__PURE__ */ jsxs(
          "div",
          {
            className: cn(
              "flex h-[calc-size(auto,size)] scale-100 items-center justify-center divide-y divide-border/20 transition-all duration-500 ease-spring",
              position2.isTopHalf ? "origin-top flex-col-reverse divide-y-reverse" : "origin-bottom flex-col",
              (minimized || isInitialLoad) && "pointer-events-none h-0 scale-50 opacity-0 blur-md"
            ),
            children: [
              isConnected ? /* @__PURE__ */ jsx(RegularContent, {}) : /* @__PURE__ */ jsx(DisconnectedContent, {}),
              /* @__PURE__ */ jsx(ToolbarSection, { children: /* @__PURE__ */ jsx(
                ToolbarButton,
                {
                  onClick: minimize,
                  className: cn(
                    "h-5",
                    position2.isTopHalf ? "rounded-t-3xl rounded-b-lg" : "rounded-t-lg rounded-b-3xl"
                  ),
                  itemClassName: "h-5",
                  children: position2.isTopHalf ? /* @__PURE__ */ jsx(ChevronUp, { className: "size-4" }) : /* @__PURE__ */ jsx(ChevronDown, { className: "size-4" })
                }
              ) })
            ]
          }
        )
      ]
    }
  );
}
const DropdownMenu = to, DropdownMenuButton = forwardRef(
  (props, ref) => /* @__PURE__ */ jsx(mt$1, { as: Fragment, ref, ...props })
), DropdownMenuContent = forwardRef(
  (props, ref) => /* @__PURE__ */ jsx(
    Tt$1,
    {
      ref,
      anchor: "bottom",
      transition: !0,
      portal: !0,
      ...props,
      className: cn(
        glassyBoxClassName,
        "z-50 flex w-fit min-w-24 max-w-90 flex-col items-stretch justify-start gap-1 rounded-xl p-1 shadow-black/50 shadow-lg outline-none data-focus:outline-none",
        props.className
      )
    }
  )
), DropdownMenuItemStyles = "w-full flex flex-row select-none items-center justify-start gap-2 py-1.5 pl-2 pr-6 truncate overflow-hidden rounded-lg hover:bg-zinc-950/10 focus:text-zinc-900 cursor-pointer transition-color duration-150 text-sm font-normal text-foreground";
forwardRef(
  (props, ref) => {
    const { className, ...buttonProps } = props;
    return /* @__PURE__ */ jsx(ft$1, { ref, children: /* @__PURE__ */ jsx(
      H$5,
      {
        as: "button",
        ...buttonProps,
        className: cn(DropdownMenuItemStyles, className)
      }
    ) });
  }
);
const DropdownMenuLinkItem = forwardRef(
  (props, ref) => /* @__PURE__ */ jsx(ft$1, { ref, children: /* @__PURE__ */ jsx("a", { ...props, className: cn(DropdownMenuItemStyles, props.className) }) })
);
function SettingsPanel() {
  return /* @__PURE__ */ jsxs(Panel, { children: [
    /* @__PURE__ */ jsx(PanelHeader, { title: "Settings" }),
    /* @__PURE__ */ jsx(PanelContent, { children: "Nothing to see :o" }),
    /* @__PURE__ */ jsx(PanelFooter, { children: /* @__PURE__ */ jsxs(DropdownMenu, { children: [
      /* @__PURE__ */ jsx(DropdownMenuButton, { children: /* @__PURE__ */ jsxs(Button, { glassy: !0, size: "sm", variant: "secondary", children: [
        /* @__PURE__ */ jsx(MessageCircleQuestionMark, { className: "mr-2 size-4" }),
        "Need help?"
      ] }) }),
      /* @__PURE__ */ jsxs(DropdownMenuContent, { children: [
        /* @__PURE__ */ jsx(
          DropdownMenuLinkItem,
          {
            href: "https://stagewise.io/docs",
            target: "_blank",
            children: "Read the docs"
          }
        ),
        /* @__PURE__ */ jsx(
          DropdownMenuLinkItem,
          {
            href: "https://discord.gg/gkdGsDYaKA",
            target: "_blank",
            children: "Join the community"
          }
        )
      ] })
    ] }) })
  ] });
}
var AgentErrorType;
(function(AgentErrorType2) {
  AgentErrorType2.INSUFFICIENT_CREDITS = "insufficient-credits-message", AgentErrorType2.PLAN_LIMITS_EXCEEDED = "plan-limits-exceeded", AgentErrorType2.AGENT_ERROR = "agent-error", AgentErrorType2.OTHER = "other";
})(AgentErrorType || (AgentErrorType = {}));
function dateParser(date) {
  const parsed = new Date(date);
  if (!Number.isNaN(parsed.valueOf()))
    return parsed;
  const parts = String(date).match(/\d+/g);
  if (parts == null || parts.length <= 2)
    return parsed;
  {
    const [firstP, secondP, ...restPs] = parts.map((x2) => parseInt(x2)), correctedParts = [firstP, secondP - 1, ...restPs];
    return new Date(Date.UTC(...correctedParts));
  }
}
const defaultFormatter = (value, _unit, suffix) => {
  const unit = value !== 1 ? _unit + "s" : _unit;
  return value + " " + unit + " " + suffix;
};
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
const MINUTE = 60, HOUR = MINUTE * 60, DAY = HOUR * 24, WEEK = DAY * 7, MONTH = DAY * 30, YEAR = DAY * 365, defaultNow = () => Date.now();
function TimeAgo({
  date,
  formatter,
  component = "time",
  live = !0,
  minPeriod = 0,
  maxPeriod = WEEK,
  title,
  now = defaultNow,
  ...passDownProps
}) {
  const [timeNow, setTimeNow] = useState(now());
  useEffect(() => {
    if (!live)
      return;
    const timeoutId = (() => {
      const then2 = dateParser(date).valueOf();
      if (!then2)
        return console.warn("[react-timeago] Invalid Date provided"), 0;
      const seconds2 = Math.round(Math.abs(timeNow - then2) / 1e3), unboundPeriod = seconds2 < MINUTE ? 1e3 : seconds2 < HOUR ? 1e3 * MINUTE : seconds2 < DAY ? 1e3 * HOUR : 1e3 * WEEK, period = Math.min(Math.max(unboundPeriod, minPeriod * 1e3), maxPeriod * 1e3);
      return period ? setTimeout(() => {
        setTimeNow(now());
      }, period) : 0;
    })();
    return () => {
      timeoutId && clearTimeout(timeoutId);
    };
  }, [date, live, maxPeriod, minPeriod, now, timeNow]), useEffect(() => {
    setTimeNow(now());
  }, [date]);
  const Komponent = component, then = dateParser(date).valueOf();
  if (!then)
    return null;
  const seconds = Math.round(Math.abs(timeNow - then) / 1e3), suffix = then < timeNow ? "ago" : "from now", [value, unit] = seconds < MINUTE ? [Math.round(seconds), "second"] : seconds < HOUR ? [Math.round(seconds / MINUTE), "minute"] : seconds < DAY ? [Math.round(seconds / HOUR), "hour"] : seconds < WEEK ? [Math.round(seconds / DAY), "day"] : seconds < MONTH ? [Math.round(seconds / WEEK), "week"] : seconds < YEAR ? [Math.round(seconds / MONTH), "month"] : [Math.round(seconds / YEAR), "year"], passDownTitle = typeof title > "u" ? typeof date == "string" ? date : dateParser(date).toISOString().substring(0, 16).replace("T", " ") : title, spreadProps = Komponent === "time" ? {
    ...passDownProps,
    dateTime: dateParser(date).toISOString()
  } : passDownProps, nextFormatter = (value2 = value2, unit2 = unit2, suffix2 = suffix2, epochMilliseconds = then, nextFormatter2 = defaultFormatter, now2 = now2) => defaultFormatter(value2, unit2, suffix2), effectiveFormatter = formatter || defaultFormatter;
  let content2;
  try {
    content2 = effectiveFormatter(value, unit, suffix, then, nextFormatter, now), content2 || (content2 = defaultFormatter(value, unit, suffix, then, nextFormatter, now));
  } catch (error2) {
    console.error("[react-timeago] Formatter threw an error:", error2), content2 = defaultFormatter(value, unit, suffix);
  }
  return /* @__PURE__ */ React.createElement(Komponent, _extends({}, spreadProps, {
    title: passDownTitle
  }), content2);
}
function stringify$1(values, options) {
  const settings = {};
  return (values[values.length - 1] === "" ? [...values, ""] : values).join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === !1 ? "" : " ")
  ).trim();
}
const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, emptyOptions$2 = {};
function name(name2, options) {
  return (emptyOptions$2.jsx ? nameReJsx : nameRe).test(name2);
}
const re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing == "object" ? thing.type === "text" ? empty$1(thing.value) : !1 : empty$1(thing);
}
function empty$1(value) {
  return value.replace(re, "") === "";
}
class Schema {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property, normal, space2) {
    this.normal = normal, this.property = property, space2 && (this.space = space2);
  }
}
Schema.prototype.normal = {};
Schema.prototype.property = {};
Schema.prototype.space = void 0;
function merge(definitions, space2) {
  const property = {}, normal = {};
  for (const definition2 of definitions)
    Object.assign(property, definition2.property), Object.assign(normal, definition2.normal);
  return new Schema(property, normal, space2);
}
function normalize$1(value) {
  return value.toLowerCase();
}
class Info {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property, attribute) {
    this.attribute = attribute, this.property = property;
  }
}
Info.prototype.attribute = "";
Info.prototype.booleanish = !1;
Info.prototype.boolean = !1;
Info.prototype.commaOrSpaceSeparated = !1;
Info.prototype.commaSeparated = !1;
Info.prototype.defined = !1;
Info.prototype.mustUseProperty = !1;
Info.prototype.number = !1;
Info.prototype.overloadedBoolean = !1;
Info.prototype.property = "";
Info.prototype.spaceSeparated = !1;
Info.prototype.space = void 0;
let powers = 0;
const boolean = increment(), booleanish = increment(), overloadedBoolean = increment(), number = increment(), spaceSeparated = increment(), commaSeparated = increment(), commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" })), checks = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types)
);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    if (super(property, attribute), mark(this, "space", space2), typeof mask == "number")
      for (; ++index2 < checks.length; ) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types[check]) === types[check]);
      }
  }
}
DefinedInfo.prototype.defined = !0;
function mark(values, key, value) {
  value && (values[key] = value);
}
function create(definition2) {
  const properties = {}, normals = {};
  for (const [property, value] of Object.entries(definition2.properties)) {
    const info = new DefinedInfo(
      property,
      definition2.transform(definition2.attributes || {}, property),
      value,
      definition2.space
    );
    definition2.mustUseProperty && definition2.mustUseProperty.includes(property) && (info.mustUseProperty = !0), properties[property] = info, normals[normalize$1(property)] = property, normals[normalize$1(info.attribute)] = property;
  }
  return new Schema(properties, normals, definition2.space);
}
const aria = create({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  },
  transform(_2, property) {
    return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
  }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
const html$2 = create({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: overloadedBoolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform
}), svg$1 = create({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform
}), xlink = create({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_2, property) {
    return "xlink:" + property.slice(5).toLowerCase();
  }
}), xmlns = create({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform
}), xml = create({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_2, property) {
    return "xml:" + property.slice(3).toLowerCase();
  }
}), hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, cap$1 = /[A-Z]/g, dash = /-[a-z]/g, valid = /^data[-\w.:]+$/i;
function find(schema, value) {
  const normal = normalize$1(value);
  let property = value, Type = Info;
  if (normal in schema.normal)
    return schema.property[schema.normal[normal]];
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap$1, kebab);
        dashes.charAt(0) !== "-" && (dashes = "-" + dashes), value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(property, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
const html$1 = merge([aria, html$2, xlink, xmlns, xml], "html"), svg = merge([aria, svg$1, xlink, xmlns, xml], "svg");
function stringify(values) {
  return values.join(" ").trim();
}
var cjs$1 = {}, inlineStyleParser, hasRequiredInlineStyleParser;
function requireInlineStyleParser() {
  if (hasRequiredInlineStyleParser) return inlineStyleParser;
  hasRequiredInlineStyleParser = 1;
  var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, NEWLINE_REGEX = /\n/g, WHITESPACE_REGEX = /^\s*/, PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, COLON_REGEX = /^:\s*/, VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, SEMICOLON_REGEX = /^[;\s]*/, TRIM_REGEX = /^\s+|\s+$/g, NEWLINE = `
`, FORWARD_SLASH = "/", ASTERISK = "*", EMPTY_STRING = "", TYPE_COMMENT = "comment", TYPE_DECLARATION = "declaration";
  inlineStyleParser = function(style, options) {
    if (typeof style != "string")
      throw new TypeError("First argument must be a string");
    if (!style) return [];
    options = options || {};
    var lineno = 1, column = 1;
    function updatePosition(str) {
      var lines = str.match(NEWLINE_REGEX);
      lines && (lineno += lines.length);
      var i2 = str.lastIndexOf(NEWLINE);
      column = ~i2 ? str.length - i2 : column + str.length;
    }
    function position2() {
      var start = { line: lineno, column };
      return function(node2) {
        return node2.position = new Position(start), whitespace2(), node2;
      };
    }
    function Position(start) {
      this.start = start, this.end = { line: lineno, column }, this.source = options.source;
    }
    Position.prototype.content = style;
    function error2(msg) {
      var err = new Error(
        options.source + ":" + lineno + ":" + column + ": " + msg
      );
      if (err.reason = msg, err.filename = options.source, err.line = lineno, err.column = column, err.source = style, !options.silent) throw err;
    }
    function match(re2) {
      var m2 = re2.exec(style);
      if (m2) {
        var str = m2[0];
        return updatePosition(str), style = style.slice(str.length), m2;
      }
    }
    function whitespace2() {
      match(WHITESPACE_REGEX);
    }
    function comments(rules) {
      var c2;
      for (rules = rules || []; c2 = comment(); )
        c2 !== !1 && rules.push(c2);
      return rules;
    }
    function comment() {
      var pos = position2();
      if (!(FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1))) {
        for (var i2 = 2; EMPTY_STRING != style.charAt(i2) && (ASTERISK != style.charAt(i2) || FORWARD_SLASH != style.charAt(i2 + 1)); )
          ++i2;
        if (i2 += 2, EMPTY_STRING === style.charAt(i2 - 1))
          return error2("End of comment missing");
        var str = style.slice(2, i2 - 2);
        return column += 2, updatePosition(str), style = style.slice(i2), column += 2, pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
    }
    function declaration() {
      var pos = position2(), prop = match(PROPERTY_REGEX);
      if (prop) {
        if (comment(), !match(COLON_REGEX)) return error2("property missing ':'");
        var val = match(VALUE_REGEX), ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        return match(SEMICOLON_REGEX), ret;
      }
    }
    function declarations() {
      var decls = [];
      comments(decls);
      for (var decl; decl = declaration(); )
        decl !== !1 && (decls.push(decl), comments(decls));
      return decls;
    }
    return whitespace2(), declarations();
  };
  function trim(str) {
    return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
  }
  return inlineStyleParser;
}
var hasRequiredCjs$1;
function requireCjs$1() {
  if (hasRequiredCjs$1) return cjs$1;
  hasRequiredCjs$1 = 1;
  var __importDefault = cjs$1 && cjs$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(cjs$1, "__esModule", { value: !0 }), cjs$1.default = StyleToObject;
  var inline_style_parser_1 = __importDefault(requireInlineStyleParser());
  function StyleToObject(style, iterator) {
    var styleObject = null;
    if (!style || typeof style != "string")
      return styleObject;
    var declarations = (0, inline_style_parser_1.default)(style), hasIterator = typeof iterator == "function";
    return declarations.forEach(function(declaration) {
      if (declaration.type === "declaration") {
        var property = declaration.property, value = declaration.value;
        hasIterator ? iterator(property, value, declaration) : value && (styleObject = styleObject || {}, styleObject[property] = value);
      }
    }), styleObject;
  }
  return cjs$1;
}
var utilities = {}, hasRequiredUtilities;
function requireUtilities() {
  if (hasRequiredUtilities) return utilities;
  hasRequiredUtilities = 1, Object.defineProperty(utilities, "__esModule", { value: !0 }), utilities.camelCase = void 0;
  var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/, HYPHEN_REGEX = /-([a-z])/g, NO_HYPHEN_REGEX = /^[^-]+$/, VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/, MS_VENDOR_PREFIX_REGEX = /^-(ms)-/, skipCamelCase = function(property) {
    return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
  }, capitalize = function(match, character) {
    return character.toUpperCase();
  }, trimHyphen = function(match, prefix) {
    return "".concat(prefix, "-");
  }, camelCase = function(property, options) {
    return options === void 0 && (options = {}), skipCamelCase(property) ? property : (property = property.toLowerCase(), options.reactCompat ? property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen) : property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen), property.replace(HYPHEN_REGEX, capitalize));
  };
  return utilities.camelCase = camelCase, utilities;
}
var cjs, hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var __importDefault = cjs && cjs.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }, style_to_object_1 = __importDefault(requireCjs$1()), utilities_1 = requireUtilities();
  function StyleToJS(style, options) {
    var output = {};
    return !style || typeof style != "string" || (0, style_to_object_1.default)(style, function(property, value) {
      property && value && (output[(0, utilities_1.camelCase)(property, options)] = value);
    }), output;
  }
  return StyleToJS.default = StyleToJS, cjs = StyleToJS, cjs;
}
var cjsExports = requireCjs();
const styleToJs = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports), pointEnd = point$2("end"), pointStart = point$2("start");
function point$2(type) {
  return point2;
  function point2(node2) {
    const point3 = node2 && node2.position && node2.position[type] || {};
    if (typeof point3.line == "number" && point3.line > 0 && typeof point3.column == "number" && point3.column > 0)
      return {
        line: point3.line,
        column: point3.column,
        offset: typeof point3.offset == "number" && point3.offset > -1 ? point3.offset : void 0
      };
  }
}
function position$1(node2) {
  const start = pointStart(node2), end = pointEnd(node2);
  if (start && end)
    return { start, end };
}
function stringifyPosition(value) {
  return !value || typeof value != "object" ? "" : "position" in value || "type" in value ? position(value.position) : "start" in value || "end" in value ? position(value) : "line" in value || "column" in value ? point$1(value) : "";
}
function point$1(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index(value) {
  return value && typeof value == "number" ? value : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super(), typeof optionsOrParentOrPlace == "string" && (origin = optionsOrParentOrPlace, optionsOrParentOrPlace = void 0);
    let reason = "", options = {}, legacyCause = !1;
    if (optionsOrParentOrPlace && ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace ? options = { place: optionsOrParentOrPlace } : "start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace ? options = { place: optionsOrParentOrPlace } : "type" in optionsOrParentOrPlace ? options = {
      ancestors: [optionsOrParentOrPlace],
      place: optionsOrParentOrPlace.position
    } : options = { ...optionsOrParentOrPlace }), typeof causeOrReason == "string" ? reason = causeOrReason : !options.cause && causeOrReason && (legacyCause = !0, reason = causeOrReason.message, options.cause = causeOrReason), !options.ruleId && !options.source && typeof origin == "string") {
      const index2 = origin.indexOf(":");
      index2 === -1 ? options.ruleId = origin : (options.source = origin.slice(0, index2), options.ruleId = origin.slice(index2 + 1));
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      parent && (options.place = parent.position);
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0, this.cause = options.cause || void 0, this.column = start ? start.column : void 0, this.fatal = void 0, this.file, this.message = reason, this.line = start ? start.line : void 0, this.name = stringifyPosition(options.place) || "1:1", this.place = options.place || void 0, this.reason = this.message, this.ruleId = options.ruleId || void 0, this.source = options.source || void 0, this.stack = legacyCause && options.cause && typeof options.cause.stack == "string" ? options.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const own$3 = {}.hasOwnProperty, emptyMap = /* @__PURE__ */ new Map(), cap = /[A-Z]/g, tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), tableCellElement = /* @__PURE__ */ new Set(["td", "th"]), docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
  if (!options || options.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const filePath = options.filePath || void 0;
  let create2;
  if (options.development) {
    if (typeof options.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    create2 = developmentCreate(filePath, options.jsxDEV);
  } else {
    if (typeof options.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof options.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    create2 = productionCreate(filePath, options.jsx, options.jsxs);
  }
  const state = {
    Fragment: options.Fragment,
    ancestors: [],
    components: options.components || {},
    create: create2,
    elementAttributeNameCase: options.elementAttributeNameCase || "react",
    evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
    filePath,
    ignoreInvalidStyle: options.ignoreInvalidStyle || !1,
    passKeys: options.passKeys !== !1,
    passNode: options.passNode || !1,
    schema: options.space === "svg" ? svg : html$1,
    stylePropertyNameCase: options.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: options.tableCellAlignToStyle !== !1
  }, result = one$1(state, tree, void 0);
  return result && typeof result != "string" ? result : state.create(
    tree,
    state.Fragment,
    { children: result || void 0 },
    void 0
  );
}
function one$1(state, node2, key) {
  if (node2.type === "element")
    return element$1(state, node2, key);
  if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression")
    return mdxExpression(state, node2);
  if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement")
    return mdxJsxElement(state, node2, key);
  if (node2.type === "mdxjsEsm")
    return mdxEsm(state, node2);
  if (node2.type === "root")
    return root$1(state, node2, key);
  if (node2.type === "text")
    return text$3(state, node2);
}
function element$1(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html" && (schema = svg, state.schema = schema), state.ancestors.push(node2);
  const type = findComponentFromName(state, node2.tagName, !1), props = createElementProps(state, node2);
  let children = createChildren(state, node2);
  return tableElements.has(node2.tagName) && (children = children.filter(function(child) {
    return typeof child == "string" ? !whitespace(child) : !0;
  })), addNode(state, props, type, node2), addChildren(props, children), state.ancestors.pop(), state.schema = parentSchema, state.create(node2, type, props, key);
}
function mdxExpression(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    const expression = node2.data.estree.body[0];
    return expression.type, /** @type {Child | undefined} */
    state.evaluater.evaluateExpression(expression.expression);
  }
  crashEstree(state, node2.position);
}
function mdxEsm(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater)
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateProgram(node2.data.estree)
    );
  crashEstree(state, node2.position);
}
function mdxJsxElement(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  node2.name === "svg" && parentSchema.space === "html" && (schema = svg, state.schema = schema), state.ancestors.push(node2);
  const type = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, !0), props = createJsxElementProps(state, node2), children = createChildren(state, node2);
  return addNode(state, props, type, node2), addChildren(props, children), state.ancestors.pop(), state.schema = parentSchema, state.create(node2, type, props, key);
}
function root$1(state, node2, key) {
  const props = {};
  return addChildren(props, createChildren(state, node2)), state.create(node2, state.Fragment, props, key);
}
function text$3(_2, node2) {
  return node2.value;
}
function addNode(state, props, type, node2) {
  typeof type != "string" && type !== state.Fragment && state.passNode && (props.node = node2);
}
function addChildren(props, children) {
  if (children.length > 0) {
    const value = children.length > 1 ? children : children[0];
    value && (props.children = value);
  }
}
function productionCreate(_2, jsx2, jsxs2) {
  return create2;
  function create2(_3, type, props, key) {
    const fn = Array.isArray(props.children) ? jsxs2 : jsx2;
    return key ? fn(type, props, key) : fn(type, props);
  }
}
function developmentCreate(filePath, jsxDEV) {
  return create2;
  function create2(node2, type, props, key) {
    const isStaticChildren = Array.isArray(props.children), point2 = pointStart(node2);
    return jsxDEV(
      type,
      props,
      key,
      isStaticChildren,
      {
        columnNumber: point2 ? point2.column - 1 : void 0,
        fileName: filePath,
        lineNumber: point2 ? point2.line : void 0
      },
      void 0
    );
  }
}
function createElementProps(state, node2) {
  const props = {};
  let alignValue, prop;
  for (prop in node2.properties)
    if (prop !== "children" && own$3.call(node2.properties, prop)) {
      const result = createProperty(state, prop, node2.properties[prop]);
      if (result) {
        const [key, value] = result;
        state.tableCellAlignToStyle && key === "align" && typeof value == "string" && tableCellElement.has(node2.tagName) ? alignValue = value : props[key] = value;
      }
    }
  if (alignValue) {
    const style = (
      /** @type {Style} */
      props.style || (props.style = {})
    );
    style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
  }
  return props;
}
function createJsxElementProps(state, node2) {
  const props = {};
  for (const attribute of node2.attributes)
    if (attribute.type === "mdxJsxExpressionAttribute")
      if (attribute.data && attribute.data.estree && state.evaluater) {
        const expression = attribute.data.estree.body[0];
        expression.type;
        const objectExpression = expression.expression;
        objectExpression.type;
        const property = objectExpression.properties[0];
        property.type, Object.assign(
          props,
          state.evaluater.evaluateExpression(property.argument)
        );
      } else
        crashEstree(state, node2.position);
    else {
      const name2 = attribute.name;
      let value;
      if (attribute.value && typeof attribute.value == "object")
        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
          const expression = attribute.value.data.estree.body[0];
          expression.type, value = state.evaluater.evaluateExpression(expression.expression);
        } else
          crashEstree(state, node2.position);
      else
        value = attribute.value === null ? !0 : attribute.value;
      props[name2] = /** @type {Props[keyof Props]} */
      value;
    }
  return props;
}
function createChildren(state, node2) {
  const children = [];
  let index2 = -1;
  const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  for (; ++index2 < node2.children.length; ) {
    const child = node2.children[index2];
    let key;
    if (state.passKeys) {
      const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
      if (name2) {
        const count2 = countsByName.get(name2) || 0;
        key = name2 + "-" + count2, countsByName.set(name2, count2 + 1);
      }
    }
    const result = one$1(state, child, key);
    result !== void 0 && children.push(result);
  }
  return children;
}
function createProperty(state, prop, value) {
  const info = find(state.schema, prop);
  if (!(value == null || typeof value == "number" && Number.isNaN(value))) {
    if (Array.isArray(value) && (value = info.commaSeparated ? stringify$1(value) : stringify(value)), info.property === "style") {
      let styleObject = typeof value == "object" ? value : parseStyle(state, String(value));
      return state.stylePropertyNameCase === "css" && (styleObject = transformStylesToCssCasing(styleObject)), ["style", styleObject];
    }
    return [
      state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
      value
    ];
  }
}
function parseStyle(state, value) {
  try {
    return styleToJs(value, { reactCompat: !0 });
  } catch (error2) {
    if (state.ignoreInvalidStyle)
      return {};
    const cause = (
      /** @type {Error} */
      error2
    ), message = new VFileMessage("Cannot parse `style` attribute", {
      ancestors: state.ancestors,
      cause,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw message.file = state.filePath || void 0, message.url = docs + "#cannot-parse-style-attribute", message;
  }
}
function findComponentFromName(state, name$1, allowExpression) {
  let result;
  if (!allowExpression)
    result = { type: "Literal", value: name$1 };
  else if (name$1.includes(".")) {
    const identifiers = name$1.split(".");
    let index2 = -1, node2;
    for (; ++index2 < identifiers.length; ) {
      const prop = name(identifiers[index2]) ? { type: "Identifier", name: identifiers[index2] } : { type: "Literal", value: identifiers[index2] };
      node2 = node2 ? {
        type: "MemberExpression",
        object: node2,
        property: prop,
        computed: !!(index2 && prop.type === "Literal"),
        optional: !1
      } : prop;
    }
    result = node2;
  } else
    result = name(name$1) && !/^[a-z]/.test(name$1) ? { type: "Identifier", name: name$1 } : { type: "Literal", value: name$1 };
  if (result.type === "Literal") {
    const name2 = (
      /** @type {string | number} */
      result.value
    );
    return own$3.call(state.components, name2) ? state.components[name2] : name2;
  }
  if (state.evaluater)
    return state.evaluater.evaluateExpression(result);
  crashEstree(state);
}
function crashEstree(state, place) {
  const message = new VFileMessage(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: state.ancestors,
      place,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw message.file = state.filePath || void 0, message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater", message;
}
function transformStylesToCssCasing(domCasing) {
  const cssCasing = {};
  let from;
  for (from in domCasing)
    own$3.call(domCasing, from) && (cssCasing[transformStyleToCssCasing(from)] = domCasing[from]);
  return cssCasing;
}
function transformStyleToCssCasing(from) {
  let to2 = from.replace(cap, toDash);
  return to2.slice(0, 3) === "ms-" && (to2 = "-" + to2), to2;
}
function toDash($0) {
  return "-" + $0.toLowerCase();
}
const urlAttributes = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, emptyOptions$1 = {};
function toString$1(value, options) {
  const settings = emptyOptions$1, includeImageAlt = typeof settings.includeImageAlt == "boolean" ? settings.includeImageAlt : !0, includeHtml = typeof settings.includeHtml == "boolean" ? settings.includeHtml : !0;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value)
      return value.type === "html" && !includeHtml ? "" : value.value;
    if (includeImageAlt && "alt" in value && value.alt)
      return value.alt;
    if ("children" in value)
      return all(value.children, includeImageAlt, includeHtml);
  }
  return Array.isArray(value) ? all(value, includeImageAlt, includeHtml) : "";
}
function all(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  for (; ++index2 < values.length; )
    result[index2] = one(values[index2], includeImageAlt, includeHtml);
  return result.join("");
}
function node(value) {
  return !!(value && typeof value == "object");
}
const element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const character = element.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value !== "semi" || character === characterReference2 ? !1 : character
  );
}
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0, parameters;
  if (start < 0 ? start = -start > end ? 0 : end + start : start = start > end ? end : start, remove = remove > 0 ? remove : 0, items.length < 1e4)
    parameters = Array.from(items), parameters.unshift(start, remove), list2.splice(...parameters);
  else
    for (remove && list2.splice(start, remove); chunkStart < items.length; )
      parameters = items.slice(chunkStart, chunkStart + 1e4), parameters.unshift(start, 0), list2.splice(...parameters), chunkStart += 1e4, start += 1e4;
}
function push(list2, items) {
  return list2.length > 0 ? (splice(list2, list2.length, 0, items), list2) : items;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  for (; ++index2 < extensions.length; )
    syntaxExtension(all2, extensions[index2]);
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const left = (hasOwnProperty.call(all2, hook) ? all2[hook] : void 0) || (all2[hook] = {}), right = extension2[hook];
    let code2;
    if (right)
      for (code2 in right) {
        hasOwnProperty.call(left, code2) || (left[code2] = []);
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  for (; ++index2 < list2.length; )
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  splice(existing, 0, 0, before);
}
function decodeNumericCharacterReference(value, base) {
  const code2 = Number.parseInt(value, base);
  return (
    // C0 except for HT, LF, FF, CR, space.
    code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
    code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code2 > 1114111 ? "" : String.fromCodePoint(code2)
  );
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const asciiAlpha = regexCheck(/[A-Za-z]/), asciiAlphanumeric = regexCheck(/[\dA-Za-z]/), asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < 32 || code2 === 127)
  );
}
const asciiDigit = regexCheck(/\d/), asciiHexDigit = regexCheck(/[\dA-Fa-f]/), asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u")), unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
  }
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1, start = 0, skip = 0;
  for (; ++index2 < value.length; ) {
    const code2 = value.charCodeAt(index2);
    let replace = "";
    if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2)))
      skip = 2;
    else if (code2 < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2)) || (replace = String.fromCharCode(code2));
    else if (code2 > 55295 && code2 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      code2 < 56320 && next > 56319 && next < 57344 ? (replace = String.fromCharCode(code2, next), skip = 1) : replace = "";
    } else
      replace = String.fromCharCode(code2);
    replace && (result.push(value.slice(start, index2), encodeURIComponent(replace)), start = index2 + skip + 1, replace = ""), skip && (index2 += skip, skip = 0);
  }
  return result.join("") + value.slice(start);
}
function factorySpace(effects, ok2, type, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size2 = 0;
  return start;
  function start(code2) {
    return markdownSpace(code2) ? (effects.enter(type), prefix(code2)) : ok2(code2);
  }
  function prefix(code2) {
    return markdownSpace(code2) && size2++ < limit ? (effects.consume(code2), prefix) : (effects.exit(type), ok2(code2));
  }
}
const content$1 = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    return effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    return effects.enter("paragraph"), lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    return previous2 && (previous2.next = token), previous2 = token, data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText"), effects.exit("paragraph"), effects.consume(code2);
      return;
    }
    return markdownLineEnding(code2) ? (effects.consume(code2), effects.exit("chunkText"), lineStart) : (effects.consume(code2), data);
  }
}
const document$2 = {
  tokenize: initializeDocument
}, containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this, stack = [];
  let continued = 0, childFlow, childToken, lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      return self2.containerState = item[1], effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    if (continued++, self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0, childFlow && closeFlow();
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits, point2;
      for (; indexBeforeFlow--; )
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      for (; index2 < self2.events.length; )
        self2.events[index2][1].end = {
          ...point2
        }, index2++;
      return splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits)), self2.events.length = index2, checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow)
        return documentContinued(code2);
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete)
        return flowStart(code2);
      self2.interrupt = !!(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    return self2.containerState = {}, effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
  }
  function thereIsANewContainer(code2) {
    return childFlow && closeFlow(), exitContainers(continued), documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    return self2.parser.lazy[self2.now().line] = continued !== stack.length, lineStartOffset = self2.now().offset, flowStart(code2);
  }
  function documentContinued(code2) {
    return self2.containerState = {}, effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    return continued++, stack.push([self2.currentConstruct, self2.containerState]), documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      childFlow && closeFlow(), exitContainers(0), effects.consume(code2);
      return;
    }
    return childFlow = childFlow || self2.parser.flow(self2.now()), effects.enter("chunkFlow", {
      _tokenizer: childFlow,
      contentType: "flow",
      previous: childToken
    }), flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), !0), exitContainers(0), effects.consume(code2);
      return;
    }
    return markdownLineEnding(code2) ? (effects.consume(code2), writeToChild(effects.exit("chunkFlow")), continued = 0, self2.interrupt = void 0, start) : (effects.consume(code2), flowContinue);
  }
  function writeToChild(token, endOfFile) {
    const stream = self2.sliceStream(token);
    if (endOfFile && stream.push(null), token.previous = childToken, childToken && (childToken.next = token), childToken = token, childFlow.defineSkip(token.start), childFlow.write(stream), self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      for (; index2--; )
        if (
          // The token starts before the line ending
          childFlow.events[index2][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index2][1].end || // or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        )
          return;
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits, seen, point2;
      for (; indexBeforeFlow--; )
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = !0;
        }
      for (exitContainers(continued), index2 = indexBeforeExits; index2 < self2.events.length; )
        self2.events[index2][1].end = {
          ...point2
        }, index2++;
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits)), self2.events.length = index2;
    }
  }
  function exitContainers(size2) {
    let index2 = stack.length;
    for (; index2-- > size2; ) {
      const entry = stack[index2];
      self2.containerState = entry[1], entry[0].exit.call(self2, effects);
    }
    stack.length = size2;
  }
  function closeFlow() {
    childFlow.write([null]), childToken = void 0, childFlow = void 0, self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2))
    return 1;
  if (unicodePunctuation(code2))
    return 2;
}
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  for (; ++index2 < constructs2.length; ) {
    const resolve = constructs2[index2].resolveAll;
    resolve && !called.includes(resolve) && (events = resolve(events, context), called.push(resolve));
  }
  return events;
}
const attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1, open, group, text2, openingSequence, closingSequence, use, nextEvents, offset2;
  for (; ++index2 < events.length; )
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      for (open = index2; open--; )
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3))
            continue;
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = {
            ...events[open][1].end
          }, end = {
            ...events[index2][1].start
          };
          movePoint(start, -use), movePoint(end, use), openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: {
              ...events[open][1].end
            }
          }, closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...events[index2][1].start
            },
            end
          }, text2 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: {
              ...events[open][1].end
            },
            end: {
              ...events[index2][1].start
            }
          }, group = {
            type: use > 1 ? "strong" : "emphasis",
            start: {
              ...openingSequence.start
            },
            end: {
              ...closingSequence.end
            }
          }, events[open][1].end = {
            ...openingSequence.start
          }, events[index2][1].start = {
            ...closingSequence.end
          }, nextEvents = [], events[open][1].end.offset - events[open][1].start.offset && (nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]])), nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text2, context]]), nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context)), nextEvents = push(nextEvents, [["exit", text2, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]), events[index2][1].end.offset - events[index2][1].start.offset ? (offset2 = 2, nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]])) : offset2 = 0, splice(events, open - 1, index2 - open + 3, nextEvents), index2 = open + nextEvents.length - offset2 - 2;
          break;
        }
    }
  for (index2 = -1; ++index2 < events.length; )
    events[index2][1].type === "attentionSequence" && (events[index2][1].type = "data");
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null, previous2 = this.previous, before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code2) {
    return marker = code2, effects.enter("attentionSequence"), inside(code2);
  }
  function inside(code2) {
    if (code2 === marker)
      return effects.consume(code2), inside;
    const token = effects.exit("attentionSequence"), after = classifyCharacter(code2), open = !after || after === 2 && before || attentionMarkers2.includes(code2), close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    return token._open = !!(marker === 42 ? open : open && (before || !close)), token._close = !!(marker === 42 ? close : close && (after || !open)), ok2(code2);
  }
}
function movePoint(point2, offset2) {
  point2.column += offset2, point2.offset += offset2, point2._bufferIndex += offset2;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size2 = 0;
  return start;
  function start(code2) {
    return effects.enter("autolink"), effects.enter("autolinkMarker"), effects.consume(code2), effects.exit("autolinkMarker"), effects.enter("autolinkProtocol"), open;
  }
  function open(code2) {
    return asciiAlpha(code2) ? (effects.consume(code2), schemeOrEmailAtext) : code2 === 64 ? nok(code2) : emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2) ? (size2 = 1, schemeInsideOrEmailAtext(code2)) : emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    return code2 === 58 ? (effects.consume(code2), size2 = 0, urlInside) : (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size2++ < 32 ? (effects.consume(code2), schemeInsideOrEmailAtext) : (size2 = 0, emailAtext(code2));
  }
  function urlInside(code2) {
    return code2 === 62 ? (effects.exit("autolinkProtocol"), effects.enter("autolinkMarker"), effects.consume(code2), effects.exit("autolinkMarker"), effects.exit("autolink"), ok2) : code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2) ? nok(code2) : (effects.consume(code2), urlInside);
  }
  function emailAtext(code2) {
    return code2 === 64 ? (effects.consume(code2), emailAtSignOrDot) : asciiAtext(code2) ? (effects.consume(code2), emailAtext) : nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    return code2 === 46 ? (effects.consume(code2), size2 = 0, emailAtSignOrDot) : code2 === 62 ? (effects.exit("autolinkProtocol").type = "autolinkEmail", effects.enter("autolinkMarker"), effects.consume(code2), effects.exit("autolinkMarker"), effects.exit("autolink"), ok2) : emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size2++ < 63) {
      const next = code2 === 45 ? emailValue : emailLabel;
      return effects.consume(code2), next;
    }
    return nok(code2);
  }
}
const blankLine = {
  partial: !0,
  tokenize: tokenizeBlankLine
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const blockQuote = {
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      return state.open || (effects.enter("blockQuote", {
        _container: !0
      }), state.open = !0), effects.enter("blockQuotePrefix"), effects.enter("blockQuoteMarker"), effects.consume(code2), effects.exit("blockQuoteMarker"), after;
    }
    return nok(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? (effects.enter("blockQuotePrefixWhitespace"), effects.consume(code2), effects.exit("blockQuotePrefixWhitespace"), effects.exit("blockQuotePrefix"), ok2) : (effects.exit("blockQuotePrefix"), ok2(code2));
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    return markdownSpace(code2) ? factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    return effects.enter("characterEscape"), effects.enter("escapeMarker"), effects.consume(code2), effects.exit("escapeMarker"), inside;
  }
  function inside(code2) {
    return asciiPunctuation(code2) ? (effects.enter("characterEscapeValue"), effects.consume(code2), effects.exit("characterEscapeValue"), effects.exit("characterEscape"), ok2) : nok(code2);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size2 = 0, max2, test;
  return start;
  function start(code2) {
    return effects.enter("characterReference"), effects.enter("characterReferenceMarker"), effects.consume(code2), effects.exit("characterReferenceMarker"), open;
  }
  function open(code2) {
    return code2 === 35 ? (effects.enter("characterReferenceMarkerNumeric"), effects.consume(code2), effects.exit("characterReferenceMarkerNumeric"), numeric) : (effects.enter("characterReferenceValue"), max2 = 31, test = asciiAlphanumeric, value(code2));
  }
  function numeric(code2) {
    return code2 === 88 || code2 === 120 ? (effects.enter("characterReferenceMarkerHexadecimal"), effects.consume(code2), effects.exit("characterReferenceMarkerHexadecimal"), effects.enter("characterReferenceValue"), max2 = 6, test = asciiHexDigit, value) : (effects.enter("characterReferenceValue"), max2 = 7, test = asciiDigit, value(code2));
  }
  function value(code2) {
    if (code2 === 59 && size2) {
      const token = effects.exit("characterReferenceValue");
      return test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token)) ? nok(code2) : (effects.enter("characterReferenceMarker"), effects.consume(code2), effects.exit("characterReferenceMarker"), effects.exit("characterReference"), ok2);
    }
    return test(code2) && size2++ < max2 ? (effects.consume(code2), value) : nok(code2);
  }
}
const nonLazyContinuation = {
  partial: !0,
  tokenize: tokenizeNonLazyContinuation
}, codeFenced = {
  concrete: !0,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this, closeStart = {
    partial: !0,
    tokenize: tokenizeCloseStart
  };
  let initialPrefix = 0, sizeOpen = 0, marker;
  return start;
  function start(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    const tail = self2.events[self2.events.length - 1];
    return initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], !0).length : 0, marker = code2, effects.enter("codeFenced"), effects.enter("codeFencedFence"), effects.enter("codeFencedFenceSequence"), sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    return code2 === marker ? (sizeOpen++, effects.consume(code2), sequenceOpen) : sizeOpen < 3 ? nok(code2) : (effects.exit("codeFencedFenceSequence"), markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2));
  }
  function infoBefore(code2) {
    return code2 === null || markdownLineEnding(code2) ? (effects.exit("codeFencedFence"), self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2)) : (effects.enter("codeFencedFenceInfo"), effects.enter("chunkString", {
      contentType: "string"
    }), info(code2));
  }
  function info(code2) {
    return code2 === null || markdownLineEnding(code2) ? (effects.exit("chunkString"), effects.exit("codeFencedFenceInfo"), infoBefore(code2)) : markdownSpace(code2) ? (effects.exit("chunkString"), effects.exit("codeFencedFenceInfo"), factorySpace(effects, metaBefore, "whitespace")(code2)) : code2 === 96 && code2 === marker ? nok(code2) : (effects.consume(code2), info);
  }
  function metaBefore(code2) {
    return code2 === null || markdownLineEnding(code2) ? infoBefore(code2) : (effects.enter("codeFencedFenceMeta"), effects.enter("chunkString", {
      contentType: "string"
    }), meta(code2));
  }
  function meta(code2) {
    return code2 === null || markdownLineEnding(code2) ? (effects.exit("chunkString"), effects.exit("codeFencedFenceMeta"), infoBefore(code2)) : code2 === 96 && code2 === marker ? nok(code2) : (effects.consume(code2), meta);
  }
  function atNonLazyBreak(code2) {
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    return effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    return code2 === null || markdownLineEnding(code2) ? effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2) : (effects.enter("codeFlowValue"), contentChunk(code2));
  }
  function contentChunk(code2) {
    return code2 === null || markdownLineEnding(code2) ? (effects.exit("codeFlowValue"), beforeContentChunk(code2)) : (effects.consume(code2), contentChunk);
  }
  function after(code2) {
    return effects.exit("codeFenced"), ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size2 = 0;
    return startBefore;
    function startBefore(code2) {
      return effects2.enter("lineEnding"), effects2.consume(code2), effects2.exit("lineEnding"), start2;
    }
    function start2(code2) {
      return effects2.enter("codeFencedFence"), markdownSpace(code2) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      return code2 === marker ? (effects2.enter("codeFencedFenceSequence"), sequenceClose(code2)) : nok2(code2);
    }
    function sequenceClose(code2) {
      return code2 === marker ? (size2++, effects2.consume(code2), sequenceClose) : size2 >= sizeOpen ? (effects2.exit("codeFencedFenceSequence"), markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2)) : nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      return code2 === null || markdownLineEnding(code2) ? (effects2.exit("codeFencedFence"), ok3(code2)) : nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    return code2 === null ? nok(code2) : (effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), lineStart);
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
}, furtherStart = {
  partial: !0,
  tokenize: tokenizeFurtherStart
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    return effects.enter("codeIndented"), factorySpace(effects, afterPrefix, "linePrefix", 5)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], !0).length >= 4 ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    return code2 === null ? after(code2) : markdownLineEnding(code2) ? effects.attempt(furtherStart, atBreak, after)(code2) : (effects.enter("codeFlowValue"), inside(code2));
  }
  function inside(code2) {
    return code2 === null || markdownLineEnding(code2) ? (effects.exit("codeFlowValue"), atBreak(code2)) : (effects.consume(code2), inside);
  }
  function after(code2) {
    return effects.exit("codeIndented"), ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : markdownLineEnding(code2) ? (effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), furtherStart2) : factorySpace(effects, afterPrefix, "linePrefix", 5)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], !0).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}
const codeText = {
  name: "codeText",
  previous,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4, headEnterIndex = 3, index2, enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    for (index2 = headEnterIndex; ++index2 < tailExitIndex; )
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding", events[tailExitIndex][1].type = "codeTextPadding", headEnterIndex += 2, tailExitIndex -= 2;
        break;
      }
  }
  for (index2 = headEnterIndex - 1, tailExitIndex++; ++index2 <= tailExitIndex; )
    enter === void 0 ? index2 !== tailExitIndex && events[index2][1].type !== "lineEnding" && (enter = index2) : (index2 === tailExitIndex || events[index2][1].type === "lineEnding") && (events[enter][1].type = "codeTextData", index2 !== enter + 2 && (events[enter][1].end = events[index2 - 1][1].end, events.splice(enter + 2, index2 - enter - 2), tailExitIndex -= index2 - enter - 2, index2 = enter + 2), enter = void 0);
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  let sizeOpen = 0, size2, token;
  return start;
  function start(code2) {
    return effects.enter("codeText"), effects.enter("codeTextSequence"), sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    return code2 === 96 ? (effects.consume(code2), sizeOpen++, sequenceOpen) : (effects.exit("codeTextSequence"), between(code2));
  }
  function between(code2) {
    return code2 === null ? nok(code2) : code2 === 32 ? (effects.enter("space"), effects.consume(code2), effects.exit("space"), between) : code2 === 96 ? (token = effects.enter("codeTextSequence"), size2 = 0, sequenceClose(code2)) : markdownLineEnding(code2) ? (effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), between) : (effects.enter("codeTextData"), data(code2));
  }
  function data(code2) {
    return code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2) ? (effects.exit("codeTextData"), between(code2)) : (effects.consume(code2), data);
  }
  function sequenceClose(code2) {
    return code2 === 96 ? (effects.consume(code2), size2++, sequenceClose) : size2 === sizeOpen ? (effects.exit("codeTextSequence"), effects.exit("codeText"), ok2(code2)) : (token.type = "codeTextData", data(code2));
  }
}
class SpliceBuffer {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return index2 < this.left.length ? this.left[index2] : this.right[this.right.length - index2 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start, end) {
    const stop = end ?? Number.POSITIVE_INFINITY;
    return stop < this.left.length ? this.left.slice(start, stop) : start > this.left.length ? this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse() : this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start, deleteCount, items) {
    const count2 = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(this.right.length - count2, Number.POSITIVE_INFINITY);
    return items && chunkedPush(this.left, items), removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY), chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0), this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0), chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n2) {
    if (!(n2 === this.left.length || n2 > this.left.length && this.right.length === 0 || n2 < 0 && this.left.length === 0))
      if (n2 < this.left.length) {
        const removed = this.left.splice(n2, Number.POSITIVE_INFINITY);
        chunkedPush(this.right, removed.reverse());
      } else {
        const removed = this.right.splice(this.left.length + this.right.length - n2, Number.POSITIVE_INFINITY);
        chunkedPush(this.left, removed.reverse());
      }
  }
}
function chunkedPush(list2, right) {
  let chunkStart = 0;
  if (right.length < 1e4)
    list2.push(...right);
  else
    for (; chunkStart < right.length; )
      list2.push(...right.slice(chunkStart, chunkStart + 1e4)), chunkStart += 1e4;
}
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1, event, lineIndex, otherIndex, otherEvent, parameters, subevents, more;
  const events = new SpliceBuffer(eventsArray);
  for (; ++index2 < events.length; ) {
    for (; index2 in jumps; )
      index2 = jumps[index2];
    if (event = events.get(index2), index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix" && (subevents = event[1]._tokenizer.events, otherIndex = 0, otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank" && (otherIndex += 2), otherIndex < subevents.length && subevents[otherIndex][1].type === "content"))
      for (; ++otherIndex < subevents.length && subevents[otherIndex][1].type !== "content"; )
        subevents[otherIndex][1].type === "chunkText" && (subevents[otherIndex][1]._isInFirstContentOfListItem = !0, otherIndex++);
    if (event[0] === "enter")
      event[1].contentType && (Object.assign(jumps, subcontent(events, index2)), index2 = jumps[index2], more = !0);
    else if (event[1]._container) {
      for (otherIndex = index2, lineIndex = void 0; otherIndex--; )
        if (otherEvent = events.get(otherIndex), otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank")
          otherEvent[0] === "enter" && (lineIndex && (events.get(lineIndex)[1].type = "lineEndingBlank"), otherEvent[1].type = "lineEnding", lineIndex = otherIndex);
        else if (!(otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent")) break;
      lineIndex && (event[1].end = {
        ...events.get(lineIndex)[1].start
      }, parameters = events.slice(lineIndex, index2), parameters.unshift(event), events.splice(lineIndex, index2 - lineIndex + 1, parameters));
    }
  }
  return splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0)), !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1], context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  let tokenizer = token._tokenizer;
  tokenizer || (tokenizer = context.parser[token.contentType](token.start), token._contentTypeTextTrailing && (tokenizer._contentTypeTextTrailing = !0));
  const childEvents = tokenizer.events, jumps = [], gaps = {};
  let stream, previous2, index2 = -1, current = token, adjust = 0, start = 0;
  const breaks = [start];
  for (; current; ) {
    for (; events.get(++startPosition)[1] !== current; )
      ;
    startPositions.push(startPosition), current._tokenizer || (stream = context.sliceStream(current), current.next || stream.push(null), previous2 && tokenizer.defineSkip(current.start), current._isInFirstContentOfListItem && (tokenizer._gfmTasklistFirstContentOfListItem = !0), tokenizer.write(stream), current._isInFirstContentOfListItem && (tokenizer._gfmTasklistFirstContentOfListItem = void 0)), previous2 = current, current = current.next;
  }
  for (current = token; ++index2 < childEvents.length; )
    // Find a void token that includes a break.
    childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line && (start = index2 + 1, breaks.push(start), current._tokenizer = void 0, current.previous = void 0, current = current.next);
  for (tokenizer.events = [], current ? (current._tokenizer = void 0, current.previous = void 0) : breaks.pop(), index2 = breaks.length; index2--; ) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]), start2 = startPositions.pop();
    jumps.push([start2, start2 + slice.length - 1]), events.splice(start2, 2, slice);
  }
  for (jumps.reverse(), index2 = -1; ++index2 < jumps.length; )
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1], adjust += jumps[index2][1] - jumps[index2][0] - 1;
  return gaps;
}
const content = {
  resolve: resolveContent,
  tokenize: tokenizeContent
}, continuationConstruct = {
  partial: !0,
  tokenize: tokenizeContinuation
};
function resolveContent(events) {
  return subtokenize(events), events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    return effects.enter("content"), previous2 = effects.enter("chunkContent", {
      contentType: "content"
    }), chunkInside(code2);
  }
  function chunkInside(code2) {
    return code2 === null ? contentEnd(code2) : markdownLineEnding(code2) ? effects.check(continuationConstruct, contentContinue, contentEnd)(code2) : (effects.consume(code2), chunkInside);
  }
  function contentEnd(code2) {
    return effects.exit("chunkContent"), effects.exit("content"), ok2(code2);
  }
  function contentContinue(code2) {
    return effects.consume(code2), effects.exit("chunkContent"), previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    }), previous2 = previous2.next, chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    return effects.exit("chunkContent"), effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2))
      return nok(code2);
    const tail = self2.events[self2.events.length - 1];
    return !self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], !0).length >= 4 ? ok2(code2) : effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    return code2 === 60 ? (effects.enter(type), effects.enter(literalType), effects.enter(literalMarkerType), effects.consume(code2), effects.exit(literalMarkerType), enclosedBefore) : code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2) ? nok(code2) : (effects.enter(type), effects.enter(rawType), effects.enter(stringType), effects.enter("chunkString", {
      contentType: "string"
    }), raw(code2));
  }
  function enclosedBefore(code2) {
    return code2 === 62 ? (effects.enter(literalMarkerType), effects.consume(code2), effects.exit(literalMarkerType), effects.exit(literalType), effects.exit(type), ok2) : (effects.enter(stringType), effects.enter("chunkString", {
      contentType: "string"
    }), enclosed(code2));
  }
  function enclosed(code2) {
    return code2 === 62 ? (effects.exit("chunkString"), effects.exit(stringType), enclosedBefore(code2)) : code2 === null || code2 === 60 || markdownLineEnding(code2) ? nok(code2) : (effects.consume(code2), code2 === 92 ? enclosedEscape : enclosed);
  }
  function enclosedEscape(code2) {
    return code2 === 60 || code2 === 62 || code2 === 92 ? (effects.consume(code2), enclosed) : enclosed(code2);
  }
  function raw(code2) {
    return !balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2)) ? (effects.exit("chunkString"), effects.exit(stringType), effects.exit(rawType), effects.exit(type), ok2(code2)) : balance < limit && code2 === 40 ? (effects.consume(code2), balance++, raw) : code2 === 41 ? (effects.consume(code2), balance--, raw) : code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2) ? nok(code2) : (effects.consume(code2), code2 === 92 ? rawEscape : raw);
  }
  function rawEscape(code2) {
    return code2 === 40 || code2 === 41 || code2 === 92 ? (effects.consume(code2), raw) : raw(code2);
  }
}
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self2 = this;
  let size2 = 0, seen;
  return start;
  function start(code2) {
    return effects.enter(type), effects.enter(markerType), effects.consume(code2), effects.exit(markerType), effects.enter(stringType), atBreak;
  }
  function atBreak(code2) {
    return size2 > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === 94 && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : code2 === 93 ? (effects.exit(stringType), effects.enter(markerType), effects.consume(code2), effects.exit(markerType), effects.exit(type), ok2) : markdownLineEnding(code2) ? (effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), atBreak) : (effects.enter("chunkString", {
      contentType: "string"
    }), labelInside(code2));
  }
  function labelInside(code2) {
    return code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size2++ > 999 ? (effects.exit("chunkString"), atBreak(code2)) : (effects.consume(code2), seen || (seen = !markdownSpace(code2)), code2 === 92 ? labelEscape : labelInside);
  }
  function labelEscape(code2) {
    return code2 === 91 || code2 === 92 || code2 === 93 ? (effects.consume(code2), size2++, labelInside) : labelInside(code2);
  }
}
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    return code2 === 34 || code2 === 39 || code2 === 40 ? (effects.enter(type), effects.enter(markerType), effects.consume(code2), effects.exit(markerType), marker = code2 === 40 ? 41 : code2, begin) : nok(code2);
  }
  function begin(code2) {
    return code2 === marker ? (effects.enter(markerType), effects.consume(code2), effects.exit(markerType), effects.exit(type), ok2) : (effects.enter(stringType), atBreak(code2));
  }
  function atBreak(code2) {
    return code2 === marker ? (effects.exit(stringType), begin(marker)) : code2 === null ? nok(code2) : markdownLineEnding(code2) ? (effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), factorySpace(effects, atBreak, "linePrefix")) : (effects.enter("chunkString", {
      contentType: "string"
    }), inside(code2));
  }
  function inside(code2) {
    return code2 === marker || code2 === null || markdownLineEnding(code2) ? (effects.exit("chunkString"), atBreak(code2)) : (effects.consume(code2), code2 === 92 ? escape : inside);
  }
  function escape(code2) {
    return code2 === marker || code2 === 92 ? (effects.consume(code2), inside) : inside(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    return markdownLineEnding(code2) ? (effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), seen = !0, start) : markdownSpace(code2) ? factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code2) : ok2(code2);
  }
}
const definition = {
  name: "definition",
  tokenize: tokenizeDefinition
}, titleBefore = {
  partial: !0,
  tokenize: tokenizeTitleBefore
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code2) {
    return effects.enter("definition"), before(code2);
  }
  function before(code2) {
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code2);
  }
  function labelAfter(code2) {
    return identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)), code2 === 58 ? (effects.enter("definitionMarker"), effects.consume(code2), effects.exit("definitionMarker"), markerAfter) : nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? (effects.exit("definition"), self2.parser.defined.push(identifier), ok2(code2)) : nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    return effects.enter("hardBreakEscape"), effects.consume(code2), after;
  }
  function after(code2) {
    return markdownLineEnding(code2) ? (effects.exit("hardBreakEscape"), ok2(code2)) : nok(code2);
  }
}
const headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2, contentStart = 3, content2, text2;
  return events[contentStart][1].type === "whitespace" && (contentStart += 2), contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace" && (contentEnd -= 2), events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace") && (contentEnd -= contentStart + 1 === contentEnd ? 2 : 4), contentEnd > contentStart && (content2 = {
    type: "atxHeadingText",
    start: events[contentStart][1].start,
    end: events[contentEnd][1].end
  }, text2 = {
    type: "chunkText",
    start: events[contentStart][1].start,
    end: events[contentEnd][1].end,
    contentType: "text"
  }, splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content2, context], ["enter", text2, context], ["exit", text2, context], ["exit", content2, context]])), events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size2 = 0;
  return start;
  function start(code2) {
    return effects.enter("atxHeading"), before(code2);
  }
  function before(code2) {
    return effects.enter("atxHeadingSequence"), sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    return code2 === 35 && size2++ < 6 ? (effects.consume(code2), sequenceOpen) : code2 === null || markdownLineEndingOrSpace(code2) ? (effects.exit("atxHeadingSequence"), atBreak(code2)) : nok(code2);
  }
  function atBreak(code2) {
    return code2 === 35 ? (effects.enter("atxHeadingSequence"), sequenceFurther(code2)) : code2 === null || markdownLineEnding(code2) ? (effects.exit("atxHeading"), ok2(code2)) : markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : (effects.enter("atxHeadingText"), data(code2));
  }
  function sequenceFurther(code2) {
    return code2 === 35 ? (effects.consume(code2), sequenceFurther) : (effects.exit("atxHeadingSequence"), atBreak(code2));
  }
  function data(code2) {
    return code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2) ? (effects.exit("atxHeadingText"), atBreak(code2)) : (effects.consume(code2), data);
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], htmlRawNames = ["pre", "script", "style", "textarea"], htmlFlow = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
}, blankLineBefore = {
  partial: !0,
  tokenize: tokenizeBlankLineBefore
}, nonLazyContinuationStart = {
  partial: !0,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  for (; index2-- && !(events[index2][0] === "enter" && events[index2][1].type === "htmlFlow"); )
    ;
  return index2 > 1 && events[index2 - 2][1].type === "linePrefix" && (events[index2][1].start = events[index2 - 2][1].start, events[index2 + 1][1].start = events[index2 - 2][1].start, events.splice(index2 - 2, 2)), events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker, closingTag, buffer, index2, markerB;
  return start;
  function start(code2) {
    return before(code2);
  }
  function before(code2) {
    return effects.enter("htmlFlow"), effects.enter("htmlFlowData"), effects.consume(code2), open;
  }
  function open(code2) {
    return code2 === 33 ? (effects.consume(code2), declarationOpen) : code2 === 47 ? (effects.consume(code2), closingTag = !0, tagCloseStart) : code2 === 63 ? (effects.consume(code2), marker = 3, self2.interrupt ? ok2 : continuationDeclarationInside) : asciiAlpha(code2) ? (effects.consume(code2), buffer = String.fromCharCode(code2), tagName) : nok(code2);
  }
  function declarationOpen(code2) {
    return code2 === 45 ? (effects.consume(code2), marker = 2, commentOpenInside) : code2 === 91 ? (effects.consume(code2), marker = 5, index2 = 0, cdataOpenInside) : asciiAlpha(code2) ? (effects.consume(code2), marker = 4, self2.interrupt ? ok2 : continuationDeclarationInside) : nok(code2);
  }
  function commentOpenInside(code2) {
    return code2 === 45 ? (effects.consume(code2), self2.interrupt ? ok2 : continuationDeclarationInside) : nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    return code2 === value.charCodeAt(index2++) ? (effects.consume(code2), index2 === value.length ? self2.interrupt ? ok2 : continuation : cdataOpenInside) : nok(code2);
  }
  function tagCloseStart(code2) {
    return asciiAlpha(code2) ? (effects.consume(code2), buffer = String.fromCharCode(code2), tagName) : nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === 47, name2 = buffer.toLowerCase();
      return !slash && !closingTag && htmlRawNames.includes(name2) ? (marker = 1, self2.interrupt ? ok2(code2) : continuation(code2)) : htmlBlockNames.includes(buffer.toLowerCase()) ? (marker = 6, slash ? (effects.consume(code2), basicSelfClosing) : self2.interrupt ? ok2(code2) : continuation(code2)) : (marker = 7, self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2));
    }
    return code2 === 45 || asciiAlphanumeric(code2) ? (effects.consume(code2), buffer += String.fromCharCode(code2), tagName) : nok(code2);
  }
  function basicSelfClosing(code2) {
    return code2 === 62 ? (effects.consume(code2), self2.interrupt ? ok2 : continuation) : nok(code2);
  }
  function completeClosingTagAfter(code2) {
    return markdownSpace(code2) ? (effects.consume(code2), completeClosingTagAfter) : completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    return code2 === 47 ? (effects.consume(code2), completeEnd) : code2 === 58 || code2 === 95 || asciiAlpha(code2) ? (effects.consume(code2), completeAttributeName) : markdownSpace(code2) ? (effects.consume(code2), completeAttributeNameBefore) : completeEnd(code2);
  }
  function completeAttributeName(code2) {
    return code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2) ? (effects.consume(code2), completeAttributeName) : completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    return code2 === 61 ? (effects.consume(code2), completeAttributeValueBefore) : markdownSpace(code2) ? (effects.consume(code2), completeAttributeNameAfter) : completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    return code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 ? nok(code2) : code2 === 34 || code2 === 39 ? (effects.consume(code2), markerB = code2, completeAttributeValueQuoted) : markdownSpace(code2) ? (effects.consume(code2), completeAttributeValueBefore) : completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    return code2 === markerB ? (effects.consume(code2), markerB = null, completeAttributeValueQuotedAfter) : code2 === null || markdownLineEnding(code2) ? nok(code2) : (effects.consume(code2), completeAttributeValueQuoted);
  }
  function completeAttributeValueUnquoted(code2) {
    return code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2) ? completeAttributeNameAfter(code2) : (effects.consume(code2), completeAttributeValueUnquoted);
  }
  function completeAttributeValueQuotedAfter(code2) {
    return code2 === 47 || code2 === 62 || markdownSpace(code2) ? completeAttributeNameBefore(code2) : nok(code2);
  }
  function completeEnd(code2) {
    return code2 === 62 ? (effects.consume(code2), completeAfter) : nok(code2);
  }
  function completeAfter(code2) {
    return code2 === null || markdownLineEnding(code2) ? continuation(code2) : markdownSpace(code2) ? (effects.consume(code2), completeAfter) : nok(code2);
  }
  function continuation(code2) {
    return code2 === 45 && marker === 2 ? (effects.consume(code2), continuationCommentInside) : code2 === 60 && marker === 1 ? (effects.consume(code2), continuationRawTagOpen) : code2 === 62 && marker === 4 ? (effects.consume(code2), continuationClose) : code2 === 63 && marker === 3 ? (effects.consume(code2), continuationDeclarationInside) : code2 === 93 && marker === 5 ? (effects.consume(code2), continuationCdataInside) : markdownLineEnding(code2) && (marker === 6 || marker === 7) ? (effects.exit("htmlFlowData"), effects.check(blankLineBefore, continuationAfter, continuationStart)(code2)) : code2 === null || markdownLineEnding(code2) ? (effects.exit("htmlFlowData"), continuationStart(code2)) : (effects.consume(code2), continuation);
  }
  function continuationStart(code2) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code2);
  }
  function continuationStartNonLazy(code2) {
    return effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), continuationBefore;
  }
  function continuationBefore(code2) {
    return code2 === null || markdownLineEnding(code2) ? continuationStart(code2) : (effects.enter("htmlFlowData"), continuation(code2));
  }
  function continuationCommentInside(code2) {
    return code2 === 45 ? (effects.consume(code2), continuationDeclarationInside) : continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    return code2 === 47 ? (effects.consume(code2), buffer = "", continuationRawEndTag) : continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62) {
      const name2 = buffer.toLowerCase();
      return htmlRawNames.includes(name2) ? (effects.consume(code2), continuationClose) : continuation(code2);
    }
    return asciiAlpha(code2) && buffer.length < 8 ? (effects.consume(code2), buffer += String.fromCharCode(code2), continuationRawEndTag) : continuation(code2);
  }
  function continuationCdataInside(code2) {
    return code2 === 93 ? (effects.consume(code2), continuationDeclarationInside) : continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    return code2 === 62 ? (effects.consume(code2), continuationClose) : code2 === 45 && marker === 2 ? (effects.consume(code2), continuationDeclarationInside) : continuation(code2);
  }
  function continuationClose(code2) {
    return code2 === null || markdownLineEnding(code2) ? (effects.exit("htmlFlowData"), continuationAfter(code2)) : (effects.consume(code2), continuationClose);
  }
  function continuationAfter(code2) {
    return effects.exit("htmlFlow"), ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    return markdownLineEnding(code2) ? (effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), after) : nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start;
  function start(code2) {
    return effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), effects.attempt(blankLine, ok2, nok);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker, index2, returnState;
  return start;
  function start(code2) {
    return effects.enter("htmlText"), effects.enter("htmlTextData"), effects.consume(code2), open;
  }
  function open(code2) {
    return code2 === 33 ? (effects.consume(code2), declarationOpen) : code2 === 47 ? (effects.consume(code2), tagCloseStart) : code2 === 63 ? (effects.consume(code2), instruction) : asciiAlpha(code2) ? (effects.consume(code2), tagOpen) : nok(code2);
  }
  function declarationOpen(code2) {
    return code2 === 45 ? (effects.consume(code2), commentOpenInside) : code2 === 91 ? (effects.consume(code2), index2 = 0, cdataOpenInside) : asciiAlpha(code2) ? (effects.consume(code2), declaration) : nok(code2);
  }
  function commentOpenInside(code2) {
    return code2 === 45 ? (effects.consume(code2), commentEnd) : nok(code2);
  }
  function comment(code2) {
    return code2 === null ? nok(code2) : code2 === 45 ? (effects.consume(code2), commentClose) : markdownLineEnding(code2) ? (returnState = comment, lineEndingBefore(code2)) : (effects.consume(code2), comment);
  }
  function commentClose(code2) {
    return code2 === 45 ? (effects.consume(code2), commentEnd) : comment(code2);
  }
  function commentEnd(code2) {
    return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    return code2 === value.charCodeAt(index2++) ? (effects.consume(code2), index2 === value.length ? cdata : cdataOpenInside) : nok(code2);
  }
  function cdata(code2) {
    return code2 === null ? nok(code2) : code2 === 93 ? (effects.consume(code2), cdataClose) : markdownLineEnding(code2) ? (returnState = cdata, lineEndingBefore(code2)) : (effects.consume(code2), cdata);
  }
  function cdataClose(code2) {
    return code2 === 93 ? (effects.consume(code2), cdataEnd) : cdata(code2);
  }
  function cdataEnd(code2) {
    return code2 === 62 ? end(code2) : code2 === 93 ? (effects.consume(code2), cdataEnd) : cdata(code2);
  }
  function declaration(code2) {
    return code2 === null || code2 === 62 ? end(code2) : markdownLineEnding(code2) ? (returnState = declaration, lineEndingBefore(code2)) : (effects.consume(code2), declaration);
  }
  function instruction(code2) {
    return code2 === null ? nok(code2) : code2 === 63 ? (effects.consume(code2), instructionClose) : markdownLineEnding(code2) ? (returnState = instruction, lineEndingBefore(code2)) : (effects.consume(code2), instruction);
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    return asciiAlpha(code2) ? (effects.consume(code2), tagClose) : nok(code2);
  }
  function tagClose(code2) {
    return code2 === 45 || asciiAlphanumeric(code2) ? (effects.consume(code2), tagClose) : tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    return markdownLineEnding(code2) ? (returnState = tagCloseBetween, lineEndingBefore(code2)) : markdownSpace(code2) ? (effects.consume(code2), tagCloseBetween) : end(code2);
  }
  function tagOpen(code2) {
    return code2 === 45 || asciiAlphanumeric(code2) ? (effects.consume(code2), tagOpen) : code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2) ? tagOpenBetween(code2) : nok(code2);
  }
  function tagOpenBetween(code2) {
    return code2 === 47 ? (effects.consume(code2), end) : code2 === 58 || code2 === 95 || asciiAlpha(code2) ? (effects.consume(code2), tagOpenAttributeName) : markdownLineEnding(code2) ? (returnState = tagOpenBetween, lineEndingBefore(code2)) : markdownSpace(code2) ? (effects.consume(code2), tagOpenBetween) : end(code2);
  }
  function tagOpenAttributeName(code2) {
    return code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2) ? (effects.consume(code2), tagOpenAttributeName) : tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    return code2 === 61 ? (effects.consume(code2), tagOpenAttributeValueBefore) : markdownLineEnding(code2) ? (returnState = tagOpenAttributeNameAfter, lineEndingBefore(code2)) : markdownSpace(code2) ? (effects.consume(code2), tagOpenAttributeNameAfter) : tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    return code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 ? nok(code2) : code2 === 34 || code2 === 39 ? (effects.consume(code2), marker = code2, tagOpenAttributeValueQuoted) : markdownLineEnding(code2) ? (returnState = tagOpenAttributeValueBefore, lineEndingBefore(code2)) : markdownSpace(code2) ? (effects.consume(code2), tagOpenAttributeValueBefore) : (effects.consume(code2), tagOpenAttributeValueUnquoted);
  }
  function tagOpenAttributeValueQuoted(code2) {
    return code2 === marker ? (effects.consume(code2), marker = void 0, tagOpenAttributeValueQuotedAfter) : code2 === null ? nok(code2) : markdownLineEnding(code2) ? (returnState = tagOpenAttributeValueQuoted, lineEndingBefore(code2)) : (effects.consume(code2), tagOpenAttributeValueQuoted);
  }
  function tagOpenAttributeValueUnquoted(code2) {
    return code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96 ? nok(code2) : code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2) ? tagOpenBetween(code2) : (effects.consume(code2), tagOpenAttributeValueUnquoted);
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    return code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2) ? tagOpenBetween(code2) : nok(code2);
  }
  function end(code2) {
    return code2 === 62 ? (effects.consume(code2), effects.exit("htmlTextData"), effects.exit("htmlText"), ok2) : nok(code2);
  }
  function lineEndingBefore(code2) {
    return effects.exit("htmlTextData"), effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    return effects.enter("htmlTextData"), returnState(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
}, resourceConstruct = {
  tokenize: tokenizeResource
}, referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
}, referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  const newEvents = [];
  for (; ++index2 < events.length; ) {
    const token = events[index2][1];
    if (newEvents.push(events[index2]), token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      const offset2 = token.type === "labelImage" ? 4 : 2;
      token.type = "data", index2 += offset2;
    }
  }
  return events.length !== newEvents.length && splice(events, 0, events.length, newEvents), events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length, offset2 = 0, token, open, close, media;
  for (; index2--; )
    if (token = events[index2][1], open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive)
        break;
      events[index2][0] === "enter" && token.type === "labelLink" && (token._inactive = !0);
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced && (open = index2, token.type !== "labelLink")) {
        offset2 = 2;
        break;
      }
    } else token.type === "labelEnd" && (close = index2);
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: {
      ...events[open][1].start
    },
    end: {
      ...events[events.length - 1][1].end
    }
  }, label = {
    type: "label",
    start: {
      ...events[open][1].start
    },
    end: {
      ...events[close][1].end
    }
  }, text2 = {
    type: "labelText",
    start: {
      ...events[open + offset2 + 2][1].end
    },
    end: {
      ...events[close - 2][1].start
    }
  };
  return media = [["enter", group, context], ["enter", label, context]], media = push(media, events.slice(open + 1, open + offset2 + 3)), media = push(media, [["enter", text2, context]]), media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset2 + 4, close - 3), context)), media = push(media, [["exit", text2, context], events[close - 2], events[close - 1], ["exit", label, context]]), media = push(media, events.slice(close + 1)), media = push(media, [["exit", group, context]]), splice(events, open, events.length, media), events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length, labelStart, defined;
  for (; index2--; )
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  return start;
  function start(code2) {
    return labelStart ? labelStart._inactive ? labelEndNok(code2) : (defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    }))), effects.enter("labelEnd"), effects.enter("labelMarker"), effects.consume(code2), effects.exit("labelMarker"), effects.exit("labelEnd"), after) : nok(code2);
  }
  function after(code2) {
    return code2 === 40 ? effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code2) : code2 === 91 ? effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code2) : defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    return labelStart._balanced = !0, nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    return effects.enter("resource"), effects.enter("resourceMarker"), effects.consume(code2), effects.exit("resourceMarker"), resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    return code2 === 41 ? resourceEnd(code2) : factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    return code2 === 34 || code2 === 39 || code2 === 40 ? factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2) : resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    return code2 === 41 ? (effects.enter("resourceMarker"), effects.consume(code2), effects.exit("resourceMarker"), effects.exit("resource"), ok2) : nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    return effects.enter("reference"), effects.enter("referenceMarker"), effects.consume(code2), effects.exit("referenceMarker"), referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    return code2 === 93 ? (effects.enter("referenceMarker"), effects.consume(code2), effects.exit("referenceMarker"), effects.exit("reference"), ok2) : nok(code2);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    return effects.enter("labelImage"), effects.enter("labelImageMarker"), effects.consume(code2), effects.exit("labelImageMarker"), open;
  }
  function open(code2) {
    return code2 === 91 ? (effects.enter("labelMarker"), effects.consume(code2), effects.exit("labelMarker"), effects.exit("labelImage"), after) : nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    return effects.enter("labelLink"), effects.enter("labelMarker"), effects.consume(code2), effects.exit("labelMarker"), effects.exit("labelLink"), after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    return effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), factorySpace(effects, ok2, "linePrefix");
  }
}
const thematicBreak$1 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size2 = 0, marker;
  return start;
  function start(code2) {
    return effects.enter("thematicBreak"), before(code2);
  }
  function before(code2) {
    return marker = code2, atBreak(code2);
  }
  function atBreak(code2) {
    return code2 === marker ? (effects.enter("thematicBreakSequence"), sequence(code2)) : size2 >= 3 && (code2 === null || markdownLineEnding(code2)) ? (effects.exit("thematicBreak"), ok2(code2)) : nok(code2);
  }
  function sequence(code2) {
    return code2 === marker ? (effects.consume(code2), size2++, sequence) : (effects.exit("thematicBreakSequence"), markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2));
  }
}
const list$1 = {
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
}, listItemPrefixWhitespaceConstruct = {
  partial: !0,
  tokenize: tokenizeListItemPrefixWhitespace
}, indentConstruct = {
  partial: !0,
  tokenize: tokenizeIndent
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this, tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], !0).length : 0, size2 = 0;
  return start;
  function start(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (self2.containerState.type || (self2.containerState.type = kind, effects.enter(kind, {
        _container: !0
      })), kind === "listUnordered")
        return effects.enter("listItemPrefix"), code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
      if (!self2.interrupt || code2 === 49)
        return effects.enter("listItemPrefix"), effects.enter("listItemValue"), inside(code2);
    }
    return nok(code2);
  }
  function inside(code2) {
    return asciiDigit(code2) && ++size2 < 10 ? (effects.consume(code2), inside) : (!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46) ? (effects.exit("listItemValue"), atMarker(code2)) : nok(code2);
  }
  function atMarker(code2) {
    return effects.enter("listItemMarker"), effects.consume(code2), effects.exit("listItemMarker"), self2.containerState.marker = self2.containerState.marker || code2, effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
    );
  }
  function onBlank(code2) {
    return self2.containerState.initialBlankLine = !0, initialSize++, endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    return markdownSpace(code2) ? (effects.enter("listItemPrefixWhitespace"), effects.consume(code2), effects.exit("listItemPrefixWhitespace"), endOfPrefix) : nok(code2);
  }
  function endOfPrefix(code2) {
    return self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), !0).length, ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  return self2.containerState._closeFlow = void 0, effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    return self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine, factorySpace(effects, ok2, "listItemIndent", self2.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    return self2.containerState.furtherBlankLines || !markdownSpace(code2) ? (self2.containerState.furtherBlankLines = void 0, self2.containerState.initialBlankLine = void 0, notInCurrentItem(code2)) : (self2.containerState.furtherBlankLines = void 0, self2.containerState.initialBlankLine = void 0, effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2));
  }
  function notInCurrentItem(code2) {
    return self2.containerState._closeFlow = !0, self2.interrupt = void 0, factorySpace(effects, effects.attempt(list$1, ok2, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], !0).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length, content2, text2, definition2;
  for (; index2--; )
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      events[index2][1].type === "paragraph" && (text2 = index2);
    } else
      events[index2][1].type === "content" && events.splice(index2, 1), !definition2 && events[index2][1].type === "definition" && (definition2 = index2);
  const heading2 = {
    type: "setextHeading",
    start: {
      ...events[content2][1].start
    },
    end: {
      ...events[events.length - 1][1].end
    }
  };
  return events[text2][1].type = "setextHeadingText", definition2 ? (events.splice(text2, 0, ["enter", heading2, context]), events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]), events[content2][1].end = {
    ...events[definition2][1].end
  }) : events[content2][1] = heading2, events.push(["exit", heading2, context]), events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code2) {
    let index2 = self2.events.length, paragraph2;
    for (; index2--; )
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    return !self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2) ? (effects.enter("setextHeadingLine"), marker = code2, before(code2)) : nok(code2);
  }
  function before(code2) {
    return effects.enter("setextHeadingLineSequence"), inside(code2);
  }
  function inside(code2) {
    return code2 === marker ? (effects.consume(code2), inside) : (effects.exit("setextHeadingLineSequence"), markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2));
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? (effects.exit("setextHeadingLine"), ok2(code2)) : nok(code2);
  }
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this, initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content, afterConstruct)), "linePrefix"))
  );
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    return effects.enter("lineEndingBlank"), effects.consume(code2), effects.exit("lineEndingBlank"), self2.currentConstruct = void 0, initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    return effects.enter("lineEnding"), effects.consume(code2), effects.exit("lineEnding"), self2.currentConstruct = void 0, initial;
  }
}
const resolver = {
  resolveAll: createResolver()
}, string$1 = initializeFactory("string"), text$2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this, constructs2 = this.parser.constructs[field], text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text2(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      return effects.enter("data"), effects.consume(code2), data;
    }
    function data(code2) {
      return atBreak(code2) ? (effects.exit("data"), text2(code2)) : (effects.consume(code2), data);
    }
    function atBreak(code2) {
      if (code2 === null)
        return !0;
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2)
        for (; ++index2 < list2.length; ) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous))
            return !0;
        }
      return !1;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1, enter;
    for (; ++index2 <= events.length; )
      enter === void 0 ? events[index2] && events[index2][1].type === "data" && (enter = index2, index2++) : (!events[index2] || events[index2][1].type !== "data") && (index2 !== enter + 2 && (events[enter][1].end = events[index2 - 1][1].end, events.splice(enter + 2, index2 - enter - 2), index2 = enter + 2), enter = void 0);
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  for (; ++eventIndex <= events.length; )
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1], chunks = context.sliceStream(data);
      let index2 = chunks.length, bufferIndex = -1, size2 = 0, tabs;
      for (; index2--; ) {
        const chunk = chunks[index2];
        if (typeof chunk == "string") {
          for (bufferIndex = chunk.length; chunk.charCodeAt(bufferIndex - 1) === 32; )
            size2++, bufferIndex--;
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === -2)
          tabs = !0, size2++;
        else if (chunk !== -1) {
          index2++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length && (size2 = 0), size2) {
        const token = {
          type: eventIndex === events.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index2,
            line: data.end.line,
            column: data.end.column - size2,
            offset: data.end.offset - size2
          },
          end: {
            ...data.end
          }
        };
        data.end = {
          ...token.start
        }, data.start.offset === data.end.offset ? Object.assign(data, token) : (events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]), eventIndex += 2);
      }
      eventIndex++;
    }
  return events;
}
const document$1 = {
  42: list$1,
  43: list$1,
  45: list$1,
  48: list$1,
  49: list$1,
  50: list$1,
  51: list$1,
  52: list$1,
  53: list$1,
  54: list$1,
  55: list$1,
  56: list$1,
  57: list$1,
  62: blockQuote
}, contentInitial = {
  91: definition
}, flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  32: codeIndented
}, flow = {
  35: headingAtx,
  42: thematicBreak$1,
  45: [setextUnderline, thematicBreak$1],
  60: htmlFlow,
  61: setextUnderline,
  95: thematicBreak$1,
  96: codeFenced,
  126: codeFenced
}, string = {
  38: characterReference,
  92: characterEscape
}, text$1 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  33: labelStartImage,
  38: characterReference,
  42: attention,
  60: [autolink, htmlText],
  91: labelStartLink,
  92: [hardBreakEscape, characterEscape],
  93: labelEnd,
  95: attention,
  96: codeText
}, insideSpan = {
  null: [attention, resolver]
}, attentionMarkers = {
  null: [42, 95]
}, disable = {
  null: []
}, defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$1
}, Symbol.toStringTag, { value: "Module" }));
function createTokenizer(parser, initialize, from) {
  let point2 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {}, resolveAllConstructs = [];
  let chunks = [], stack = [];
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit2,
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: !0
    })
  }, context = {
    code: null,
    containerState: {},
    defineSkip,
    events: [],
    now,
    parser,
    previous: null,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  return initialize.resolveAll && resolveAllConstructs.push(initialize), context;
  function write(slice) {
    return chunks = push(chunks, slice), main(), chunks[chunks.length - 1] !== null ? [] : (addResult(initialize, 0), context.events = resolveAll(resolveAllConstructs, context.events, context), context.events);
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const {
      _bufferIndex,
      _index,
      line,
      column,
      offset: offset2
    } = point2;
    return {
      _bufferIndex,
      _index,
      line,
      column,
      offset: offset2
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column, accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    for (; point2._index < chunks.length; ) {
      const chunk = chunks[point2._index];
      if (typeof chunk == "string")
        for (chunkIndex = point2._index, point2._bufferIndex < 0 && (point2._bufferIndex = 0); point2._index === chunkIndex && point2._bufferIndex < chunk.length; )
          go(chunk.charCodeAt(point2._bufferIndex));
      else
        go(chunk);
    }
  }
  function go(code2) {
    state = state(code2);
  }
  function consume(code2) {
    markdownLineEnding(code2) ? (point2.line++, point2.column = 1, point2.offset += code2 === -3 ? 2 : 1, accountForPotentialSkip()) : code2 !== -1 && (point2.column++, point2.offset++), point2._bufferIndex < 0 ? point2._index++ : (point2._bufferIndex++, point2._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    chunks[point2._index].length && (point2._bufferIndex = -1, point2._index++)), context.previous = code2;
  }
  function enter(type, fields) {
    const token = fields || {};
    return token.type = type, token.start = now(), context.events.push(["enter", token, context]), stack.push(token), token;
  }
  function exit2(type) {
    const token = stack.pop();
    return token.end = now(), context.events.push(["exit", token, context]), token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs, constructIndex, currentConstruct, info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code2) {
          const left = code2 !== null && map[code2], all2 = code2 !== null && map.null, list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        return listOfConstructs = list2, constructIndex = 0, list2.length === 0 ? bogusState : handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          return info = store(), currentConstruct = construct, construct.partial || (context.currentConstruct = construct), construct.name && context.parser.constructs.disable.null.includes(construct.name) ? nok() : construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok2,
            nok
          )(code2);
        }
      }
      function ok2(code2) {
        return onreturn(currentConstruct, info), returnState;
      }
      function nok(code2) {
        return info.restore(), ++constructIndex < listOfConstructs.length ? handleConstruct(listOfConstructs[constructIndex]) : bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    construct.resolveAll && !resolveAllConstructs.includes(construct) && resolveAllConstructs.push(construct), construct.resolve && splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context)), construct.resolveTo && (context.events = construct.resolveTo(context.events, context));
  }
  function store() {
    const startPoint = now(), startPrevious = context.previous, startCurrentConstruct = context.currentConstruct, startEventsIndex = context.events.length, startStack = Array.from(stack);
    return {
      from: startEventsIndex,
      restore
    };
    function restore() {
      point2 = startPoint, context.previous = startPrevious, context.currentConstruct = startCurrentConstruct, context.events.length = startEventsIndex, stack = startStack, accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    point2.line in columnStart && point2.column < 2 && (point2.column = columnStart[point2.line], point2.offset += columnStart[point2.line] - 1);
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index, startBufferIndex = token.start._bufferIndex, endIndex = token.end._index, endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex)
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  else {
    if (view = chunks.slice(startIndex, endIndex), startBufferIndex > -1) {
      const head = view[0];
      typeof head == "string" ? view[0] = head.slice(startBufferIndex) : view.shift();
    }
    endBufferIndex > 0 && view.push(chunks[endIndex].slice(0, endBufferIndex));
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  for (; ++index2 < chunks.length; ) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk == "string")
      value = chunk;
    else switch (chunk) {
      case -5: {
        value = "\r";
        break;
      }
      case -4: {
        value = `
`;
        break;
      }
      case -3: {
        value = `\r
`;
        break;
      }
      case -2: {
        value = expandTabs ? " " : "	";
        break;
      }
      case -1: {
        if (!expandTabs && atTab) continue;
        value = " ";
        break;
      }
      default:
        value = String.fromCharCode(chunk);
    }
    atTab = chunk === -2, result.push(value);
  }
  return result.join("");
}
function parse(options) {
  const parser = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      combineExtensions([defaultConstructs, ...(options || {}).extensions || []])
    ),
    content: create2(content$1),
    defined: [],
    document: create2(document$2),
    flow: create2(flow$1),
    lazy: {},
    string: create2(string$1),
    text: create2(text$2)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}
function postprocess(events) {
  for (; !subtokenize(events); )
    ;
  return events;
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1, buffer = "", start = !0, atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match, next, startPosition, endPosition, code2;
    for (value = buffer + (typeof value == "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value)), startPosition = 0, buffer = "", start && (value.charCodeAt(0) === 65279 && startPosition++, start = void 0); startPosition < value.length; ) {
      if (search.lastIndex = startPosition, match = search.exec(value), endPosition = match && match.index !== void 0 ? match.index : value.length, code2 = value.charCodeAt(endPosition), !match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn)
        chunks.push(-3), atCarriageReturn = void 0;
      else
        switch (atCarriageReturn && (chunks.push(-5), atCarriageReturn = void 0), startPosition < endPosition && (chunks.push(value.slice(startPosition, endPosition)), column += endPosition - startPosition), code2) {
          case 0: {
            chunks.push(65533), column++;
            break;
          }
          case 9: {
            for (next = Math.ceil(column / 4) * 4, chunks.push(-2); column++ < next; ) chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4), column = 1;
            break;
          }
          default:
            atCarriageReturn = !0, column = 1;
        }
      startPosition = endPosition + 1;
    }
    return end && (atCarriageReturn && chunks.push(-5), buffer && chunks.push(buffer), chunks.push(null)), chunks;
  }
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1)
    return $1;
  if ($2.charCodeAt(0) === 35) {
    const head2 = $2.charCodeAt(1), hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}
const own$2 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  return typeof encoding != "string" && (options = encoding, encoding = void 0), compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, !0))));
}
function compiler(options) {
  const config2 = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config2, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config: config2,
      enter,
      exit: exit2,
      buffer,
      resume,
      data
    }, listStack = [];
    let index2 = -1;
    for (; ++index2 < events.length; )
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered")
        if (events[index2][0] === "enter")
          listStack.push(index2);
        else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
    for (index2 = -1; ++index2 < events.length; ) {
      const handler = config2[events[index2][0]];
      own$2.call(handler, events[index2][1].type) && handler[events[index2][1].type].call(Object.assign({
        sliceSerialize: events[index2][2].sliceSerialize
      }, context), events[index2][1]);
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      (tail[1] || defaultOnError).call(context, void 0, tail[0]);
    }
    for (tree.position = {
      start: point(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, index2 = -1; ++index2 < config2.transforms.length; )
      tree = config2.transforms[index2](tree) || tree;
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1, containerBalance = -1, listSpread = !1, listItem3, lineIndex, firstBlankLineIndex, atMarker;
    for (; ++index2 <= length; ) {
      const event = events[index2];
      switch (event[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          event[0] === "enter" ? containerBalance++ : containerBalance--, atMarker = void 0;
          break;
        }
        case "lineEndingBlank": {
          event[0] === "enter" && (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex && (firstBlankLineIndex = index2), atMarker = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          for (lineIndex = void 0; tailIndex--; ) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit") continue;
              lineIndex && (events[lineIndex][1].type = "lineEndingBlank", listSpread = !0), tailEvent[1].type = "lineEnding", lineIndex = tailIndex;
            } else if (!(tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")) break;
          }
          firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex) && (listItem3._spread = !0), listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end), events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]), index2++, length++;
        }
        if (event[1].type === "listItemPrefix") {
          const item = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          listItem3 = item, events.splice(index2, 0, ["enter", item, event[2]]), index2++, length++, firstBlankLineIndex = void 0, atMarker = !0;
        }
      }
    }
    return events[start][1]._spread = listSpread, length;
  }
  function opener(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token), and && and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token, errorHandler) {
    this.stack[this.stack.length - 1].children.push(node2), this.stack.push(node2), this.tokenStack.push([token, errorHandler || void 0]), node2.position = {
      start: point(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      and && and.call(this, token), exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop(), open = this.tokenStack.pop();
    if (open)
      open[0].type !== token.type && (onExitError ? onExitError.call(this, token, open[0]) : (open[1] || defaultOnError).call(this, token, open[0]));
    else throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
      start: token.start,
      end: token.end
    }) + "): its not open");
    node2.position.end = point(token.end);
  }
  function resume() {
    return toString$1(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = !0;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function onexitcodefenced() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.label = label, node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const siblings = this.stack[this.stack.length - 1].children;
    let tail = siblings[siblings.length - 1];
    (!tail || tail.type !== "text") && (tail = text2(), tail.position = {
      start: point(token.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, siblings.push(tail)), this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token), tail.position.end = point(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point(token.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && config2.canContainEols.includes(context.type) && (onenterdata.call(this, token), onexitdata.call(this, token));
  }
  function onexithardbreak() {
    this.data.atHardBreak = !0;
  }
  function onexithtmlflow() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference", node2.referenceType = referenceType, delete node2.url, delete node2.title;
    } else
      delete node2.identifier, delete node2.label;
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference", node2.referenceType = referenceType, delete node2.url, delete node2.title;
    } else
      delete node2.identifier, delete node2.label;
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string2 = this.sliceSerialize(token), ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string2), ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1], value = this.resume(), node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else
      node2.alt = value;
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume(), node2 = this.stack[this.stack.length - 1];
    node2.label = label, node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase(), this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token), type = this.data.characterReferenceType;
    let value;
    type ? (value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : value = decodeNamedCharacterReference(data2);
    const tail = this.stack[this.stack.length - 1];
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    tail.position.end = point(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text2() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point(d2) {
  return {
    line: d2.line,
    column: d2.column,
    offset: d2.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  for (; ++index2 < extensions.length; ) {
    const value = extensions[index2];
    Array.isArray(value) ? configure(combined, value) : extension(combined, value);
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2)
    if (own$2.call(extension2, key))
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          right && combined[key].push(...right);
          break;
        }
        case "transforms": {
          const right = extension2[key];
          right && combined[key].push(...right);
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          right && Object.assign(combined[key], right);
          break;
        }
      }
}
function defaultOnError(left, right) {
  throw left ? new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
    start: left.start,
    end: left.end
  }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
    start: right.start,
    end: right.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
    start: right.start,
    end: right.end
  }) + ") is still open");
}
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), !0)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  return state.patch(node2, result), [state.applyData(node2, result), { type: "text", value: `
` }];
}
function code(state, node2) {
  const value = node2.value ? node2.value + `
` : "", properties = {};
  node2.lang && (properties.className = ["language-" + node2.lang]);
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  return node2.meta && (result.data = { meta: node2.meta }), state.patch(node2, result), result = state.applyData(node2, result), result = { type: "element", tagName: "pre", properties: {}, children: [result] }, state.patch(node2, result), result;
}
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function footnoteReference(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix == "string" ? state.options.clobberPrefix : "user-content-", id = String(node2.identifier).toUpperCase(), safeId = normalizeUri(id.toLowerCase()), index2 = state.footnoteOrder.indexOf(id);
  let counter, reuseCounter = state.footnoteCounts.get(id);
  reuseCounter === void 0 ? (reuseCounter = 0, state.footnoteOrder.push(id), counter = state.footnoteOrder.length) : counter = index2 + 1, reuseCounter += 1, state.footnoteCounts.set(id, reuseCounter);
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  return state.patch(node2, sup), state.applyData(node2, sup);
}
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function html(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    return state.patch(node2, result), state.applyData(node2, result);
  }
}
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed" ? suffix += "[]" : subtype === "full" && (suffix += "[" + (node2.label || node2.identifier) + "]"), node2.type === "imageReference")
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  const contents = state.all(node2), head = contents[0];
  head && head.type === "text" ? head.value = "[" + head.value : contents.unshift({ type: "text", value: "[" });
  const tail = contents[contents.length - 1];
  return tail && tail.type === "text" ? tail.value += suffix : contents.push({ type: "text", value: suffix }), contents;
}
function imageReference(state, node2) {
  const id = String(node2.identifier).toUpperCase(), definition2 = state.definitionById.get(id);
  if (!definition2)
    return revert(state, node2);
  const properties = { src: normalizeUri(definition2.url || ""), alt: node2.alt };
  definition2.title !== null && definition2.title !== void 0 && (properties.title = definition2.title);
  const result = { type: "element", tagName: "img", properties, children: [] };
  return state.patch(node2, result), state.applyData(node2, result);
}
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  node2.alt !== null && node2.alt !== void 0 && (properties.alt = node2.alt), node2.title !== null && node2.title !== void 0 && (properties.title = node2.title);
  const result = { type: "element", tagName: "img", properties, children: [] };
  return state.patch(node2, result), state.applyData(node2, result);
}
function inlineCode(state, node2) {
  const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text2);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text2]
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function linkReference(state, node2) {
  const id = String(node2.identifier).toUpperCase(), definition2 = state.definitionById.get(id);
  if (!definition2)
    return revert(state, node2);
  const properties = { href: normalizeUri(definition2.url || "") };
  definition2.title !== null && definition2.title !== void 0 && (properties.title = definition2.title);
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  node2.title !== null && node2.title !== void 0 && (properties.title = node2.title);
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function listItem(state, node2, parent) {
  const results = state.all(node2), loose = parent ? listLoose(parent) : listItemLoose(node2), properties = {}, children = [];
  if (typeof node2.checked == "boolean") {
    const head = results[0];
    let paragraph2;
    head && head.type === "element" && head.tagName === "p" ? paragraph2 = head : (paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] }, results.unshift(paragraph2)), paragraph2.children.length > 0 && paragraph2.children.unshift({ type: "text", value: " " }), paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: !0 },
      children: []
    }), properties.className = ["task-list-item"];
  }
  let index2 = -1;
  for (; ++index2 < results.length; ) {
    const child = results[index2];
    (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") && children.push({ type: "text", value: `
` }), child.type === "element" && child.tagName === "p" && !loose ? children.push(...child.children) : children.push(child);
  }
  const tail = results[results.length - 1];
  tail && (loose || tail.type !== "element" || tail.tagName !== "p") && children.push({ type: "text", value: `
` });
  const result = { type: "element", tagName: "li", properties, children };
  return state.patch(node2, result), state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = !1;
  if (node2.type === "list") {
    loose = node2.spread || !1;
    const children = node2.children;
    let index2 = -1;
    for (; !loose && ++index2 < children.length; )
      loose = listItemLoose(children[index2]);
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread ?? node2.children.length > 1;
}
function list(state, node2) {
  const properties = {}, results = state.all(node2);
  let index2 = -1;
  for (typeof node2.start == "number" && node2.start !== 1 && (properties.start = node2.start); ++index2 < results.length; ) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, !0)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  return state.patch(node2, result), state.applyData(node2, result);
}
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function table(state, node2) {
  const rows = state.all(node2), firstRow = rows.shift(), tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], !0)
    };
    state.patch(node2.children[0], head), tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, !0)
    }, start = pointStart(node2.children[1]), end = pointEnd(node2.children[node2.children.length - 1]);
    start && end && (body.position = { start, end }), tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, !0)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0, tagName = (siblings ? siblings.indexOf(node2) : 1) === 0 ? "th" : "td", align = parent && parent.type === "table" ? parent.align : void 0, length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  for (; ++cellIndex < length; ) {
    const cell = node2.children[cellIndex], properties = {}, alignValue = align ? align[cellIndex] : void 0;
    alignValue && (properties.align = alignValue);
    let result2 = { type: "element", tagName, properties, children: [] };
    cell && (result2.children = state.all(cell), state.patch(cell, result2), result2 = state.applyData(cell, result2)), cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, !0)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
const tab = 9, space = 32;
function trimLines(value) {
  const source = String(value), search2 = /\r?\n|\r/g;
  let match = search2.exec(source), last = 0;
  const lines = [];
  for (; match; )
    lines.push(
      trimLine(source.slice(last, match.index), last > 0, !0),
      match[0]
    ), last = match.index + match[0].length, match = search2.exec(source);
  return lines.push(trimLine(source.slice(last), last > 0, !1)), lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0, endIndex = value.length;
  if (start) {
    let code2 = value.codePointAt(startIndex);
    for (; code2 === tab || code2 === space; )
      startIndex++, code2 = value.codePointAt(startIndex);
  }
  if (end) {
    let code2 = value.codePointAt(endIndex - 1);
    for (; code2 === tab || code2 === space; )
      endIndex--, code2 = value.codePointAt(endIndex - 1);
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  return state.patch(node2, result), state.applyData(node2, result);
}
function thematicBreak(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
const handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading,
  html,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list,
  paragraph,
  // @ts-expect-error: root is different, but hard to type.
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
}
const VOID = -1, PRIMITIVE = 0, ARRAY = 1, OBJECT = 2, DATE = 3, REGEXP = 4, MAP = 5, SET = 6, ERROR = 7, BIGINT = 8, env = typeof self == "object" ? self : globalThis, deserializer = ($2, _2) => {
  const as = (out, index2) => ($2.set(index2, out), out), unpair = (index2) => {
    if ($2.has(index2))
      return $2.get(index2);
    const [type, value] = _2[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index2);
      case ARRAY: {
        const arr = as([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index2);
        for (const [key, index3] of value)
          object[unpair(key)] = unpair(index3);
        return object;
      }
      case DATE:
        return as(new Date(value), index2);
      case REGEXP: {
        const { source, flags } = value;
        return as(new RegExp(source, flags), index2);
      }
      case MAP: {
        const map = as(/* @__PURE__ */ new Map(), index2);
        for (const [key, index3] of value)
          map.set(unpair(key), unpair(index3));
        return map;
      }
      case SET: {
        const set = as(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set.add(unpair(index3));
        return set;
      }
      case ERROR: {
        const { name: name2, message } = value;
        return as(new env[name2](message), index2);
      }
      case BIGINT:
        return as(BigInt(value), index2);
      case "BigInt":
        return as(Object(BigInt(value)), index2);
      case "ArrayBuffer":
        return as(new Uint8Array(value).buffer, value);
      case "DataView": {
        const { buffer } = new Uint8Array(value);
        return as(new DataView(buffer), value);
      }
    }
    return as(new env[type](value), index2);
  };
  return unpair;
}, deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0), EMPTY = "", { toString } = {}, { keys } = Object, typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, asString];
  }
  return asString.includes("Array") ? [ARRAY, asString] : asString.includes("Error") ? [ERROR, asString] : [OBJECT, asString];
}, shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol"), serializer = (strict, json, $2, _2) => {
  const as = (out, value) => {
    const index2 = _2.push(out) - 1;
    return $2.set(value, index2), index2;
  }, pair = (value) => {
    if ($2.has(value))
      return $2.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT, entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread = value;
          return type === "DataView" ? spread = new Uint8Array(value.buffer) : type === "ArrayBuffer" && (spread = new Uint8Array(value)), as([type, [...spread]], value);
        }
        const arr = [], index2 = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type)
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [], index2 = as([TYPE, entries], value);
        for (const key of keys(value))
          (strict || !shouldSkip(typeOf(value[key]))) && entries.push([pair(key), pair(value[key])]);
        return index2;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [], index2 = as([TYPE, entries], value);
        for (const [key, entry] of value)
          (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry)))) && entries.push([pair(key), pair(entry)]);
        return index2;
      }
      case SET: {
        const entries = [], index2 = as([TYPE, entries], value);
        for (const entry of value)
          (strict || !shouldSkip(typeOf(entry))) && entries.push(pair(entry));
        return index2;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
}, serialize = (value, { json, lossy } = {}) => {
  const _2 = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _2)(value), _2;
}, structuredClone$1 = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize(any, options));
function defaultFootnoteBackContent(_2, rereferenceIndex) {
  const result = [{ type: "text", value: "" }];
  return rereferenceIndex > 1 && result.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(rereferenceIndex) }]
  }), result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix == "string" ? state.options.clobberPrefix : "user-content-", footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent, footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel, footnoteLabel = state.options.footnoteLabel || "Footnotes", footnoteLabelTagName = state.options.footnoteLabelTagName || "h2", footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, listItems = [];
  let referenceIndex = -1;
  for (; ++referenceIndex < state.footnoteOrder.length; ) {
    const definition2 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition2)
      continue;
    const content2 = state.all(definition2), id = String(definition2.identifier).toUpperCase(), safeId = normalizeUri(id.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [], counts = state.footnoteCounts.get(id);
    for (; counts !== void 0 && ++rereferenceIndex <= counts; ) {
      backReferences.length > 0 && backReferences.push({ type: "text", value: " " });
      let children = typeof footnoteBackContent == "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      typeof children == "string" && (children = { type: "text", value: children }), backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel == "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content2[content2.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      tailTail && tailTail.type === "text" ? tailTail.value += " " : tail.children.push({ type: "text", value: " " }), tail.children.push(...backReferences);
    } else
      content2.push(...backReferences);
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content2, !0)
    };
    state.patch(definition2, listItem2), listItems.push(listItem2);
  }
  if (listItems.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: footnoteLabelTagName,
          properties: {
            ...structuredClone$1(footnoteLabelProperties),
            id: "footnote-label"
          },
          children: [{ type: "text", value: footnoteLabel }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: state.wrap(listItems, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(test) {
    if (test == null)
      return ok;
    if (typeof test == "function")
      return castFactory(test);
    if (typeof test == "object")
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    if (typeof test == "string")
      return typeFactory(test);
    throw new Error("Expected function, string, or object as test");
  })
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  for (; ++index2 < tests.length; )
    checks2[index2] = convert(tests[index2]);
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    for (; ++index3 < checks2.length; )
      if (checks2[index3].apply(this, parameters)) return !0;
    return !1;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key;
    for (key in check)
      if (nodeAsRecord[key] !== checkAsRecord[key]) return !1;
    return !0;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return !!(looksLikeANode(value) && testFunction.call(
      this,
      value,
      typeof index2 == "number" ? index2 : void 0,
      parent || void 0
    ));
  }
}
function ok() {
  return !0;
}
function looksLikeANode(value) {
  return value !== null && typeof value == "object" && "type" in value;
}
const empty = [], CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  typeof test == "function" && typeof visitor != "function" ? (reverse = visitor, visitor = test) : check = test;
  const is = convert(check), step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 == "object" ? node2 : {}
    );
    if (typeof value.type == "string") {
      const name2 = (
        // `hast`
        typeof value.tagName == "string" ? value.tagName : (
          // `xast`
          typeof value.name == "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + (node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty, subresult, offset2, grandparents;
      if ((!test || is(node2, index2, parents[parents.length - 1] || void 0)) && (result = toResult(visitor(node2, parents)), result[0] === EXIT))
        return result;
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP)
          for (offset2 = (reverse ? nodeAsParent.children.length : -1) + step, grandparents = parents.concat(nodeAsParent); offset2 > -1 && offset2 < nodeAsParent.children.length; ) {
            const child = nodeAsParent.children[offset2];
            if (subresult = factory(child, offset2, grandparents)(), subresult[0] === EXIT)
              return subresult;
            offset2 = typeof subresult[1] == "number" ? subresult[1] : offset2 + step;
          }
      }
      return result;
    }
  }
}
function toResult(value) {
  return Array.isArray(value) ? value : typeof value == "number" ? [CONTINUE, value] : value == null ? empty : [value];
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse, test, visitor;
  typeof testOrVisitor == "function" && typeof visitorOrReverse != "function" ? (test = void 0, visitor = testOrVisitor, reverse = visitorOrReverse) : (test = testOrVisitor, visitor = visitorOrReverse, reverse = maybeReverse), visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1], index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}
const own$1 = {}.hasOwnProperty, emptyOptions = {};
function createState(tree, options) {
  const settings = options || emptyOptions, definitionById = /* @__PURE__ */ new Map(), footnoteById = /* @__PURE__ */ new Map(), footnoteCounts = /* @__PURE__ */ new Map(), handlers$1 = { ...handlers, ...settings.handlers }, state = {
    all: all2,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers$1,
    one: one2,
    options: settings,
    patch,
    wrap: wrap$1
  };
  return visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map = node2.type === "definition" ? definitionById : footnoteById, id = String(node2.identifier).toUpperCase();
      map.has(id) || map.set(id, node2);
    }
  }), state;
  function one2(node2, parent) {
    const type = node2.type, handle = state.handlers[type];
    if (own$1.call(state.handlers, type) && handle)
      return handle(state, node2, parent);
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2, result = structuredClone$1(shallow);
        return result.children = state.all(node2), result;
      }
      return structuredClone$1(node2);
    }
    return (state.options.unknownHandler || defaultUnknownHandler)(state, node2, parent);
  }
  function all2(parent) {
    const values = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      for (; ++index2 < nodes.length; ) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break" && (!Array.isArray(result) && result.type === "text" && (result.value = trimMarkdownSpaceStart(result.value)), !Array.isArray(result) && result.type === "element")) {
            const head = result.children[0];
            head && head.type === "text" && (head.value = trimMarkdownSpaceStart(head.value));
          }
          Array.isArray(result) ? values.push(...result) : values.push(result);
        }
      }
    }
    return values;
  }
}
function patch(from, to2) {
  from.position && (to2.position = position$1(from));
}
function applyData(from, to2) {
  let result = to2;
  if (from && from.data) {
    const hName = from.data.hName, hChildren = from.data.hChildren, hProperties = from.data.hProperties;
    if (typeof hName == "string")
      if (result.type === "element")
        result.tagName = hName;
      else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    result.type === "element" && hProperties && Object.assign(result.properties, structuredClone$1(hProperties)), "children" in result && result.children && hChildren !== null && hChildren !== void 0 && (result.children = hChildren);
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {}, result = "value" in node2 && !(own$1.call(data, "hProperties") || own$1.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  return state.patch(node2, result), state.applyData(node2, result);
}
function wrap$1(nodes, loose) {
  const result = [];
  let index2 = -1;
  for (loose && result.push({ type: "text", value: `
` }); ++index2 < nodes.length; )
    index2 && result.push({ type: "text", value: `
` }), result.push(nodes[index2]);
  return loose && nodes.length > 0 && result.push({ type: "text", value: `
` }), result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0, code2 = value.charCodeAt(index2);
  for (; code2 === 9 || code2 === 32; )
    index2++, code2 = value.charCodeAt(index2);
  return value.slice(index2);
}
function toHast(tree, options) {
  const state = createState(tree, options), node2 = state.one(tree, void 0), foot = footer(state), result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  return foot && result.children.push({ type: "text", value: `
` }, foot), result;
}
function remarkRehype(destination, options) {
  return destination && "run" in destination ? async function(tree, file) {
    const hastTree = (
      /** @type {HastRoot} */
      toHast(tree, { file, ...options })
    );
    await destination.run(hastTree, file);
  } : function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...destination || options })
    );
  };
}
function bail(error2) {
  if (error2)
    throw error2;
}
var extend$1, hasRequiredExtend;
function requireExtend() {
  if (hasRequiredExtend) return extend$1;
  hasRequiredExtend = 1;
  var hasOwn = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, defineProperty = Object.defineProperty, gOPD = Object.getOwnPropertyDescriptor, isArray = function(arr) {
    return typeof Array.isArray == "function" ? Array.isArray(arr) : toStr.call(arr) === "[object Array]";
  }, isPlainObject2 = function(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]")
      return !1;
    var hasOwnConstructor = hasOwn.call(obj, "constructor"), hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf)
      return !1;
    var key;
    for (key in obj)
      ;
    return typeof key > "u" || hasOwn.call(obj, key);
  }, setProperty = function(target, options) {
    defineProperty && options.name === "__proto__" ? defineProperty(target, options.name, {
      enumerable: !0,
      configurable: !0,
      value: options.newValue,
      writable: !0
    }) : target[options.name] = options.newValue;
  }, getProperty = function(obj, name2) {
    if (name2 === "__proto__")
      if (hasOwn.call(obj, name2)) {
        if (gOPD)
          return gOPD(obj, name2).value;
      } else return;
    return obj[name2];
  };
  return extend$1 = function extend2() {
    var options, name2, src, copy, copyIsArray, clone, target = arguments[0], i2 = 1, length = arguments.length, deep = !1;
    for (typeof target == "boolean" && (deep = target, target = arguments[1] || {}, i2 = 2), (target == null || typeof target != "object" && typeof target != "function") && (target = {}); i2 < length; ++i2)
      if (options = arguments[i2], options != null)
        for (name2 in options)
          src = getProperty(target, name2), copy = getProperty(options, name2), target !== copy && (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && isArray(src) ? src : []) : clone = src && isPlainObject2(src) ? src : {}, setProperty(target, { name: name2, newValue: extend2(deep, clone, copy) })) : typeof copy < "u" && setProperty(target, { name: name2, newValue: copy }));
    return target;
  }, extend$1;
}
var extendExports = requireExtend();
const extend = /* @__PURE__ */ getDefaultExportFromCjs(extendExports);
function isPlainObject(value) {
  if (typeof value != "object" || value === null)
    return !1;
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [], pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback != "function")
      throw new TypeError("Expected function as last argument, not " + callback);
    next(null, ...values);
    function next(error2, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error2) {
        callback(error2);
        return;
      }
      for (; ++index2 < values.length; )
        (output[index2] === null || output[index2] === void 0) && (output[index2] = values[index2]);
      values = output, fn ? wrap(fn, next)(...output) : callback(null, ...output);
    }
  }
  function use(middelware) {
    if (typeof middelware != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    return fns.push(middelware), pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    fnExpectsCallback && parameters.push(done);
    try {
      result = middleware.apply(this, parameters);
    } catch (error2) {
      const exception = (
        /** @type {Error} */
        error2
      );
      if (fnExpectsCallback && called)
        throw exception;
      return done(exception);
    }
    fnExpectsCallback || (result && result.then && typeof result.then == "function" ? result.then(then, done) : result instanceof Error ? done(result) : then(result));
  }
  function done(error2, ...output) {
    called || (called = !0, callback(error2, ...output));
  }
  function then(value) {
    done(null, value);
  }
}
const minpath = { basename, dirname, extname, join, sep: "/" };
function basename(path, extname2) {
  if (extname2 !== void 0 && typeof extname2 != "string")
    throw new TypeError('"ext" argument must be a string');
  assertPath$1(path);
  let start = 0, end = -1, index2 = path.length, seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path.length) {
    for (; index2--; )
      if (path.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else end < 0 && (seenNonSlash = !0, end = index2 + 1);
    return end < 0 ? "" : path.slice(start, end);
  }
  if (extname2 === path)
    return "";
  let firstNonSlashEnd = -1, extnameIndex = extname2.length - 1;
  for (; index2--; )
    if (path.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else
      firstNonSlashEnd < 0 && (seenNonSlash = !0, firstNonSlashEnd = index2 + 1), extnameIndex > -1 && (path.codePointAt(index2) === extname2.codePointAt(extnameIndex--) ? extnameIndex < 0 && (end = index2) : (extnameIndex = -1, end = firstNonSlashEnd));
  return start === end ? end = firstNonSlashEnd : end < 0 && (end = path.length), path.slice(start, end);
}
function dirname(path) {
  if (assertPath$1(path), path.length === 0)
    return ".";
  let end = -1, index2 = path.length, unmatchedSlash;
  for (; --index2; )
    if (path.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else unmatchedSlash || (unmatchedSlash = !0);
  return end < 0 ? path.codePointAt(0) === 47 ? "/" : "." : end === 1 && path.codePointAt(0) === 47 ? "//" : path.slice(0, end);
}
function extname(path) {
  assertPath$1(path);
  let index2 = path.length, end = -1, startPart = 0, startDot = -1, preDotState = 0, unmatchedSlash;
  for (; index2--; ) {
    const code2 = path.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    end < 0 && (unmatchedSlash = !0, end = index2 + 1), code2 === 46 ? startDot < 0 ? startDot = index2 : preDotState !== 1 && (preDotState = 1) : startDot > -1 && (preDotState = -1);
  }
  return startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1, joined;
  for (; ++index2 < segments.length; )
    assertPath$1(segments[index2]), segments[index2] && (joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2]);
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path) {
  assertPath$1(path);
  const absolute = path.codePointAt(0) === 47;
  let value = normalizeString(path, !absolute);
  return value.length === 0 && !absolute && (value = "."), value.length > 0 && path.codePointAt(path.length - 1) === 47 && (value += "/"), absolute ? "/" + value : value;
}
function normalizeString(path, allowAboveRoot) {
  let result = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, index2 = -1, code2, lastSlashIndex;
  for (; ++index2 <= path.length; ) {
    if (index2 < path.length)
      code2 = path.codePointAt(index2);
    else {
      if (code2 === 47)
        break;
      code2 = 47;
    }
    if (code2 === 47) {
      if (!(lastSlash === index2 - 1 || dots === 1)) if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            if (lastSlashIndex = result.lastIndexOf("/"), lastSlashIndex !== result.length - 1) {
              lastSlashIndex < 0 ? (result = "", lastSegmentLength = 0) : (result = result.slice(0, lastSlashIndex), lastSegmentLength = result.length - 1 - result.lastIndexOf("/")), lastSlash = index2, dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "", lastSegmentLength = 0, lastSlash = index2, dots = 0;
            continue;
          }
        }
        allowAboveRoot && (result = result.length > 0 ? result + "/.." : "..", lastSegmentLength = 2);
      } else
        result.length > 0 ? result += "/" + path.slice(lastSlash + 1, index2) : result = path.slice(lastSlash + 1, index2), lastSegmentLength = index2 - lastSlash - 1;
      lastSlash = index2, dots = 0;
    } else code2 === 46 && dots > -1 ? dots++ : dots = -1;
  }
  return result;
}
function assertPath$1(path) {
  if (typeof path != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path)
    );
}
const minproc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return !!(fileUrlOrPath !== null && typeof fileUrlOrPath == "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
  fileUrlOrPath.auth === void 0);
}
function urlToPath(path) {
  if (typeof path == "string")
    path = new URL(path);
  else if (!isUrl(path)) {
    const error2 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path + "`"
    );
    throw error2.code = "ERR_INVALID_ARG_TYPE", error2;
  }
  if (path.protocol !== "file:") {
    const error2 = new TypeError("The URL must be of scheme file");
    throw error2.code = "ERR_INVALID_URL_SCHEME", error2;
  }
  return getPathFromURLPosix(path);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error2 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw error2.code = "ERR_INVALID_FILE_URL_HOST", error2;
  }
  const pathname = url.pathname;
  let index2 = -1;
  for (; ++index2 < pathname.length; )
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error2 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw error2.code = "ERR_INVALID_FILE_URL_PATH", error2;
      }
    }
  return decodeURIComponent(pathname);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    value ? isUrl(value) ? options = { path: value } : typeof value == "string" || isUint8Array$1(value) ? options = { value } : options = value : options = {}, this.cwd = "cwd" in options ? "" : minproc.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let index2 = -1;
    for (; ++index2 < order.length; ) {
      const field2 = order[index2];
      field2 in options && options[field2] !== void 0 && options[field2] !== null && (this[field2] = field2 === "history" ? [...options[field2]] : options[field2]);
    }
    let field;
    for (field in options)
      order.includes(field) || (this[field] = options[field]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename"), assertPart(basename2, "basename"), this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname"), this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    if (assertPart(extname2, "extname"), assertPath(this.dirname, "extname"), extname2) {
      if (extname2.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (extname2.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path) {
    isUrl(path) && (path = urlToPath(path)), assertNonEmpty(path, "path"), this.path !== path && this.history.push(path);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem"), assertPart(stem, "stem"), this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    throw message.fatal = !0, message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    return message.fatal = void 0, message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    return this.path && (message.name = this.path + ":" + message.name, message.file = this.path), message.fatal = !1, this.messages.push(message), message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(encoding || void 0).decode(this.value);
  }
}
function assertPart(part, name2) {
  if (part && part.includes(minpath.sep))
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
}
function assertNonEmpty(part, name2) {
  if (!part)
    throw new Error("`" + name2 + "` cannot be empty");
}
function assertPath(path, name2) {
  if (!path)
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
}
function isUint8Array$1(value) {
  return !!(value && typeof value == "object" && "byteLength" in value && "byteOffset" in value);
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(property) {
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), value = proto[property], apply = function() {
      return value.apply(apply, arguments);
    };
    return Object.setPrototypeOf(apply, proto), apply;
  })
), own = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    for (; ++index2 < this.attachers.length; ) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    return destination.data(extend(!0, {}, this.namespace)), destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key, value) {
    return typeof key == "string" ? arguments.length === 2 ? (assertUnfrozen("data", this.frozen), this.namespace[key] = value, this) : own.call(this.namespace, key) && this.namespace[key] || void 0 : key ? (assertUnfrozen("data", this.frozen), this.namespace = key, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === !1)
        continue;
      options[0] === !0 && (options[0] = void 0);
      const transformer = attacher.call(self2, ...options);
      typeof transformer == "function" && this.transformers.use(transformer);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file), parser = this.parser || this.Parser;
    return assertParser("parse", parser), parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    return this.freeze(), assertParser("process", this.parser || this.Parser), assertCompiler("process", this.compiler || this.Compiler), done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file), parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error2, tree, file2) {
        if (error2 || !tree || !file2)
          return realDone(error2);
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        ), compileResult = self2.stringify(compileTree, file2);
        looksLikeAValue(compileResult) ? file2.value = compileResult : file2.result = compileResult, realDone(
          error2,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error2, file2) {
        error2 || !file2 ? reject(error2) : resolve ? resolve(file2) : done(void 0, file2);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = !1, result;
    return this.freeze(), assertParser("processSync", this.parser || this.Parser), assertCompiler("processSync", this.compiler || this.Compiler), this.process(file, realDone), assertDone("processSync", "process", complete), result;
    function realDone(error2, file2) {
      complete = !0, bail(error2), result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree), this.freeze();
    const transformers = this.transformers;
    return !done && typeof file == "function" && (done = file, file = void 0), done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error2, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        error2 ? reject(error2) : resolve ? resolve(resultingTree) : done(void 0, resultingTree, file2);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = !1, result;
    return this.run(tree, file, realDone), assertDone("runSync", "run", complete), result;
    function realDone(error2, tree2) {
      bail(error2), result = tree2, complete = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file), compiler2 = this.compiler || this.Compiler;
    return assertCompiler("stringify", compiler2), assertNode(tree), compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers, namespace = this.namespace;
    if (assertUnfrozen("use", this.frozen), value != null) if (typeof value == "function")
      addPlugin(value, parameters);
    else if (typeof value == "object")
      Array.isArray(value) ? addList(value) : addPreset(value);
    else
      throw new TypeError("Expected usable value, not `" + value + "`");
    return this;
    function add(value2) {
      if (typeof value2 == "function")
        addPlugin(value2, []);
      else if (typeof value2 == "object")
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else
          addPreset(value2);
      else
        throw new TypeError("Expected usable value, not `" + value2 + "`");
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      addList(result.plugins), result.settings && (namespace.settings = extend(!0, namespace.settings, result.settings));
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins != null) if (Array.isArray(plugins))
        for (; ++index2 < plugins.length; ) {
          const thing = plugins[index2];
          add(thing);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1, entryIndex = -1;
      for (; ++index2 < attachers.length; )
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      if (entryIndex === -1)
        attachers.push([plugin, ...parameters2]);
      else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        isPlainObject(currentPrimary) && isPlainObject(primary) && (primary = extend(!0, currentPrimary, primary)), attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value != "function")
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
}
function assertCompiler(name2, value) {
  if (typeof value != "function")
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
}
function assertUnfrozen(name2, frozen) {
  if (frozen)
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type != "string")
    throw new TypeError("Expected node, got `" + node2 + "`");
}
function assertDone(name2, asyncName, complete) {
  if (!complete)
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return !!(value && typeof value == "object" && "message" in value && "messages" in value);
}
function looksLikeAValue(value) {
  return typeof value == "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return !!(value && typeof value == "object" && "byteLength" in value && "byteOffset" in value);
}
const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", emptyPlugins = [], emptyRemarkRehypeOptions = { allowDangerousHtml: !0 }, safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i, deprecations = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Markdown(options) {
  const processor = createProcessor(options), file = createFile(options);
  return post(processor.runSync(processor.parse(file), file), options);
}
function createProcessor(options) {
  const rehypePlugins = options.rehypePlugins || emptyPlugins, remarkPlugins = options.remarkPlugins || emptyPlugins, remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
  return unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
}
function createFile(options) {
  const children = options.children || "", file = new VFile();
  return typeof children == "string" && (file.value = children), file;
}
function post(tree, options) {
  const allowedElements = options.allowedElements, allowElement = options.allowElement, components = options.components, disallowedElements = options.disallowedElements, skipHtml = options.skipHtml, unwrapDisallowed = options.unwrapDisallowed, urlTransform = options.urlTransform || defaultUrlTransform;
  for (const deprecation of deprecations)
    Object.hasOwn(options, deprecation.from) && ("" + deprecation.from + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + changelog + deprecation.id, void 0);
  return visit(tree, transform), toJsxRuntime(tree, {
    Fragment: Fragment$1,
    components,
    ignoreInvalidStyle: !0,
    jsx,
    jsxs,
    passKeys: !0,
    passNode: !0
  });
  function transform(node2, index2, parent) {
    if (node2.type === "raw" && parent && typeof index2 == "number")
      return skipHtml ? parent.children.splice(index2, 1) : parent.children[index2] = { type: "text", value: node2.value }, index2;
    if (node2.type === "element") {
      let key;
      for (key in urlAttributes)
        if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
          const value = node2.properties[key], test = urlAttributes[key];
          (test === null || test.includes(node2.tagName)) && (node2.properties[key] = urlTransform(String(value || ""), key, node2));
        }
    }
    if (node2.type === "element") {
      let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : !1;
      if (!remove && allowElement && typeof index2 == "number" && (remove = !allowElement(node2, index2, parent)), remove && parent && typeof index2 == "number")
        return unwrapDisallowed && node2.children ? parent.children.splice(index2, 1, ...node2.children) : parent.children.splice(index2, 1), index2;
    }
  }
}
function defaultUrlTransform(value) {
  const colon = value.indexOf(":"), questionMark = value.indexOf("?"), numberSign = value.indexOf("#"), slash = value.indexOf("/");
  return (
    // If there is no protocol, its relative.
    colon === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    slash !== -1 && colon > slash || questionMark !== -1 && colon > questionMark || numberSign !== -1 && colon > numberSign || // It is a protocol, it should be allowed.
    safeProtocol.test(value.slice(0, colon)) ? value : ""
  );
}
class Diff {
  diff(oldStr, newStr, options = {}) {
    let callback;
    typeof options == "function" ? (callback = options, options = {}) : "callback" in options && (callback = options.callback);
    const oldString = this.castInput(oldStr, options), newString = this.castInput(newStr, options), oldTokens = this.removeEmpty(this.tokenize(oldString, options)), newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a;
    const done = (value) => {
      if (value = this.postProcess(value, options), callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return;
      } else
        return value;
    }, newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1, maxEditLength = newLen + oldLen;
    options.maxEditLength != null && (maxEditLength = Math.min(maxEditLength, options.maxEditLength));
    const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : 1 / 0, abortAfterTimestamp = Date.now() + maxExecutionTime, bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen)
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    let minDiagonalToConsider = -1 / 0, maxDiagonalToConsider = 1 / 0;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        removePath && (bestPath[diagonalPath - 1] = void 0);
        let canAdd = !1;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos ? basePath = this.addToPath(addPath, !0, !1, 0, options) : basePath = this.addToPath(removePath, !1, !0, 1, options), newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options), basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen)
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || !0;
        bestPath[diagonalPath] = basePath, basePath.oldPos + 1 >= oldLen && (maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1)), newPos + 1 >= newLen && (minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1));
      }
      editLength++;
    };
    if (callback)
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp)
            return callback(void 0);
          execEditLength() || exec();
        }, 0);
      })();
    else
      for (; editLength <= maxEditLength && Date.now() <= abortAfterTimestamp; ) {
        const ret = execEditLength();
        if (ret)
          return ret;
      }
  }
  addToPath(path, added, removed, oldPosInc, options) {
    const last = path.lastComponent;
    return last && !options.oneChangePerToken && last.added === added && last.removed === removed ? {
      oldPos: path.oldPos + oldPosInc,
      lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
    } : {
      oldPos: path.oldPos + oldPosInc,
      lastComponent: { count: 1, added, removed, previousComponent: last }
    };
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    for (; newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options); )
      newPos++, oldPos++, commonCount++, options.oneChangePerToken && (basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: !1, removed: !1 });
    return commonCount && !options.oneChangePerToken && (basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: !1, removed: !1 }), basePath.oldPos = oldPos, newPos;
  }
  equals(left, right, options) {
    return options.comparator ? options.comparator(left, right) : left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
  }
  removeEmpty(array) {
    const ret = [];
    for (let i2 = 0; i2 < array.length; i2++)
      array[i2] && ret.push(array[i2]);
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value, options) {
    return value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return !1;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    for (; lastComponent; )
      components.push(lastComponent), nextComponent = lastComponent.previousComponent, delete lastComponent.previousComponent, lastComponent = nextComponent;
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (component.removed)
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count)), oldPos += component.count;
      else {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i2) {
            const oldValue = oldTokens[oldPos + i2];
            return oldValue.length > value2.length ? oldValue : value2;
          }), component.value = this.join(value);
        } else
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        newPos += component.count, component.added || (oldPos += component.count);
      }
    }
    return components;
  }
}
class LineDiff extends Diff {
  constructor() {
    super(...arguments), this.tokenize = tokenize;
  }
  equals(left, right, options) {
    return options.ignoreWhitespace ? ((!options.newlineIsToken || !left.includes(`
`)) && (left = left.trim()), (!options.newlineIsToken || !right.includes(`
`)) && (right = right.trim())) : options.ignoreNewlineAtEof && !options.newlineIsToken && (left.endsWith(`
`) && (left = left.slice(0, -1)), right.endsWith(`
`) && (right = right.slice(0, -1))), super.equals(left, right, options);
  }
}
const lineDiff = new LineDiff();
function diffLines(oldStr, newStr, options) {
  return lineDiff.diff(oldStr, newStr, options);
}
function tokenize(value, options) {
  options.stripTrailingCr && (value = value.replace(/\r\n/g, `
`));
  const retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  linesAndNewlines[linesAndNewlines.length - 1] || linesAndNewlines.pop();
  for (let i2 = 0; i2 < linesAndNewlines.length; i2++) {
    const line = linesAndNewlines[i2];
    i2 % 2 && !options.newlineIsToken ? retLines[retLines.length - 1] += line : retLines.push(line);
  }
  return retLines;
}
const isFileEditTool = (toolPart) => toolPart.type === "tool-deleteFileTool" || toolPart.type === "tool-multiEditTool" || toolPart.type === "tool-overwriteFileTool", getFallbackToolDescription = (toolPart) => /* @__PURE__ */ jsx("span", { className: "text-black/80 text-xs", children: getToolName(toolPart) }), getToolName = (toolPart) => {
  var _a, _b, _c, _d, _e2, _f;
  switch (toolPart.type) {
    case "tool-readFileTool":
      return "Reading Files";
    case "tool-listFilesTool":
      return "Listing Files";
    case "tool-grepSearchTool":
      return "Searching with Grep";
    case "tool-globTool":
      return "Searching with Glob";
    case "tool-overwriteFileTool":
      return `Overwriting ${getFileName(((_b = (_a = toolPart.output) == null ? void 0 : _a.diff) == null ? void 0 : _b.path) ?? "")}`;
    case "tool-multiEditTool":
      return `Editing ${getFileName(((_d = (_c = toolPart.output) == null ? void 0 : _c.diff) == null ? void 0 : _d.path) ?? "")}`;
    case "tool-deleteFileTool":
      return `Deleting ${getFileName(((_f = (_e2 = toolPart.output) == null ? void 0 : _e2.diff) == null ? void 0 : _f.path) ?? "")}`;
    case "dynamic-tool":
      return toolPart.toolName;
    default:
      return "Unknown Tool";
  }
}, getFileName = (path) => path.split("/").pop(), getToolDescription = (toolPart) => {
  if (!isFileEditTool(toolPart) || toolPart.state !== "output-available" || toolPart.output.diff === void 0)
    return getFallbackToolDescription(toolPart);
  switch (toolPart.output.diff.changeType) {
    case "create": {
      if (toolPart.output.diff.omitted === !0)
        return /* @__PURE__ */ jsxs("span", { className: "text-black/80 text-xs", children: [
          getFileName(toolPart.output.diff.path),
          /* @__PURE__ */ jsx("span", { className: "text-green-600 text-xs", children: " (new)" })
        ] });
      const newLineCount = diffLines("", toolPart.output.diff.after).filter((line) => line.added).reduce((sum, line) => sum + (line.count || 0), 0), fileName = getFileName(toolPart.output.diff.path);
      return /* @__PURE__ */ jsxs("span", { className: "text-black/80 text-xs", children: [
        fileName,
        /* @__PURE__ */ jsxs("span", { className: "text-green-600 text-xs", children: [
          " (new) +",
          newLineCount
        ] })
      ] });
    }
    case "delete": {
      const fileName = getFileName(toolPart.output.diff.path);
      if (toolPart.output.diff.omitted === !0)
        return /* @__PURE__ */ jsxs("span", { className: "text-black/80 text-xs", children: [
          fileName,
          /* @__PURE__ */ jsx("span", { className: "text-rose-600 text-xs", children: " (deleted)" })
        ] });
      const deletedLineCount = diffLines(toolPart.output.diff.before, "").filter((line) => line.removed).reduce((sum, line) => sum + (line.count || 0), 0);
      return /* @__PURE__ */ jsxs("span", { className: "text-black/80 text-xs", children: [
        fileName,
        /* @__PURE__ */ jsxs("span", { className: "text-rose-600 text-xs", children: [
          " ",
          "(deleted) -",
          deletedLineCount
        ] })
      ] });
    }
    case "modify": {
      if (toolPart.output.diff.afterOmitted === !0 || toolPart.output.diff.beforeOmitted === !0)
        return getFallbackToolDescription(toolPart);
      const lines = diffLines(
        toolPart.output.diff.before,
        toolPart.output.diff.after
      ), newLineCount = lines.filter((line) => line.added).reduce((sum, line) => sum + (line.count || 0), 0), deletedLineCount = lines.filter((line) => line.removed).reduce((sum, line) => sum + (line.count || 0), 0), fileName = getFileName(toolPart.output.diff.path);
      return /* @__PURE__ */ jsxs("span", { className: "text-black/80 text-xs", children: [
        fileName,
        " ",
        /* @__PURE__ */ jsxs("span", { className: "text-green-600 text-xs", children: [
          "+",
          newLineCount
        ] }),
        " ",
        /* @__PURE__ */ jsxs("span", { className: "text-rose-600 text-xs", children: [
          "-",
          deletedLineCount
        ] })
      ] });
    }
  }
};
function ChatBubble({
  message: msg,
  chatError,
  isLastMessage
}) {
  const retrySendingUserMessage = useKartonProcedure(
    (p2) => p2.retrySendingUserMessage
  ), undoToolCallsUntilUserMessage = useKartonProcedure(
    (p2) => p2.undoToolCallsUntilUserMessage
  ), undoToolCallsUntilLatestUserMessage = useKartonProcedure(
    (p2) => p2.undoToolCallsUntilLatestUserMessage
  ), assistantMadeCodeChangesUntilLatestUserMessage = useKartonProcedure(
    (p2) => p2.assistantMadeCodeChangesUntilLatestUserMessage
  ), activeChatId = useKartonState((s2) => s2.activeChatId), isWorking = useKartonState((s2) => s2.isWorking), { setChatInput } = useChatState(), [hasCodeChanges, setHasCodeChanges] = useState(!1);
  useEffect(() => {
    msg.role === "assistant" && isLastMessage && !isWorking && activeChatId ? (async () => {
      try {
        const hasChanges = await assistantMadeCodeChangesUntilLatestUserMessage(activeChatId);
        setHasCodeChanges(hasChanges);
      } catch (error2) {
        console.warn("Failed to check for code changes:", error2), setHasCodeChanges(!1);
      }
    })() : setHasCodeChanges(!1);
  }, [
    msg.role,
    isLastMessage,
    isWorking,
    activeChatId,
    assistantMadeCodeChangesUntilLatestUserMessage
  ]);
  const confirmRestore = useCallback(async () => {
    if (!msg.id || !activeChatId) return;
    const textContent = msg.parts.filter((part) => part.type === "text").map((part) => part.text).join(`
`);
    setChatInput(textContent);
    try {
      await undoToolCallsUntilUserMessage(msg.id, activeChatId);
    } catch (error2) {
      console.warn("Failed to undo tool calls:", error2);
    }
  }, [msg.id, activeChatId, setChatInput, undoToolCallsUntilUserMessage]), confirmUndo = useCallback(async () => {
    if (activeChatId)
      try {
        const latestUserMessage = await undoToolCallsUntilLatestUserMessage(activeChatId);
        if (!latestUserMessage) {
          console.warn("Could not find latest user message");
          return;
        }
        const textContent = latestUserMessage.parts.filter((part) => part.type === "text").map((part) => part.text).join(`
`);
        setChatInput(textContent);
      } catch (error2) {
        console.warn("Failed to undo tool calls:", error2);
      }
  }, [activeChatId, setChatInput, undoToolCallsUntilLatestUserMessage]);
  return /* @__PURE__ */ jsx("div", { className: "flex flex-col gap-1", children: /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "mt-2 flex w-full shrink-0 items-center justify-start gap-2",
        msg.role === "assistant" ? "flex-row" : "flex-row-reverse"
      ),
      children: [
        /* @__PURE__ */ jsxs("div", { className: "flex max-w-full flex-col items-end gap-2", children: [
          /* @__PURE__ */ jsxs(
            "div",
            {
              className: cn(
                "group relative min-h-8 max-w-full animate-chat-bubble-appear space-y-3 break-words rounded-2xl bg-white/5 px-2.5 py-1.5 font-normal text-sm shadow-lg shadow-zinc-950/10 ring-1 ring-inset last:mb-0.5",
                msg.role === "assistant" ? "min-w-48 origin-bottom-left rounded-bl-xs bg-zinc-100/60 text-zinc-950 ring-zinc-950/5" : "origin-bottom-right rounded-br-xs bg-blue-600/90 text-white ring-white/5"
              ),
              children: [
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    className: cn(
                      "group-hover:-top-3 -top-2 absolute z-20 w-max rounded-full bg-white/90 px-1.5 py-0.5 text-xs text-zinc-950/80 opacity-0 shadow-sm ring-1 ring-zinc-500/10 ring-inset transition-all duration-150 ease-out group-hover:opacity-100",
                      msg.role === "assistant" ? "left-1" : "right-1"
                    ),
                    children: /* @__PURE__ */ jsx(TimeAgo, { date: msg.metadata.createdAt })
                  }
                ),
                msg.parts.map((part, index2) => {
                  if (part.type === "dynamic-tool" || part.type.startsWith("tool-"))
                    return /* @__PURE__ */ jsx(
                      ToolPartItem,
                      {
                        toolPart: part
                      },
                      `content_part_${index2.toString()}`
                    );
                  switch (part.type) {
                    case "text":
                      return /* @__PURE__ */ jsx(
                        TextPartItem,
                        {
                          textPart: part
                        },
                        `content_part_${index2.toString()}`
                      );
                    case "reasoning":
                      return /* @__PURE__ */ jsx(
                        ReasoningPartItem,
                        {
                          reasoningPart: part
                        },
                        `content_part_${index2.toString()}`
                      );
                    case "file":
                      return /* @__PURE__ */ jsx(
                        FilePartItem,
                        {
                          filePart: part
                        },
                        `content_part_${index2.toString()}`
                      );
                    default:
                      return null;
                  }
                })
              ]
            }
          ),
          msg.role === "assistant" && isLastMessage && !isWorking && hasCodeChanges && /* @__PURE__ */ jsx(ao, { className: "relative", children: ({ close }) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
            /* @__PURE__ */ jsxs(
              At,
              {
                type: "button",
                "aria-label": "Undo changes",
                className: "flex cursor-pointer flex-row items-center gap-1 text-xs text-zinc-600 transition-colors hover:text-zinc-900 focus:outline-none",
                children: [
                  "Undo changes",
                  /* @__PURE__ */ jsx(Undo2, { className: "size-3" })
                ]
              }
            ),
            /* @__PURE__ */ jsx(
              ze$1,
              {
                as: Fragment,
                enter: "transition ease-out duration-200",
                enterFrom: "opacity-0 translate-y-1 scale-95",
                enterTo: "opacity-100 translate-y-0 scale-100",
                leave: "transition ease-in duration-150",
                leaveFrom: "opacity-100 translate-y-0 scale-100",
                leaveTo: "opacity-0 translate-y-1 scale-95",
                children: /* @__PURE__ */ jsx(
                  Bt,
                  {
                    anchor: "top end",
                    className: "!overflow-visible z-[9999] w-64 p-1 [--anchor-gap:8px]",
                    children: /* @__PURE__ */ jsxs("div", { className: "rounded-xl bg-white/95 p-3 shadow-xl ring-1 ring-zinc-950/10 ring-inset backdrop-blur-lg", children: [
                      /* @__PURE__ */ jsx("p", { className: "font-medium text-sm text-zinc-950", children: "Undo changes?" }),
                      /* @__PURE__ */ jsx("p", { className: "mt-1 text-xs text-zinc-600", children: "This will undo all changes the assistant made since your last message." }),
                      /* @__PURE__ */ jsxs("div", { className: "mt-3 flex justify-end gap-2", children: [
                        /* @__PURE__ */ jsx(
                          Button,
                          {
                            variant: "secondary",
                            size: "sm",
                            onClick: () => close(),
                            className: "h-7 px-2 py-1 text-xs",
                            children: "Cancel"
                          }
                        ),
                        /* @__PURE__ */ jsx(
                          Button,
                          {
                            variant: "primary",
                            size: "sm",
                            onClick: () => {
                              confirmUndo(), close();
                            },
                            className: "h-7 px-2 py-1 text-xs",
                            children: "Undo"
                          }
                        )
                      ] })
                    ] })
                  }
                )
              }
            )
          ] }) })
        ] }),
        msg.role === "user" && msg.id && !isWorking && /* @__PURE__ */ jsx(ao, { className: "relative", children: ({ close }) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
          /* @__PURE__ */ jsx(
            At,
            {
              type: "button",
              "aria-label": "Restore checkpoint",
              className: "mr-1 cursor-pointer text-zinc-600 transition-colors hover:text-zinc-900 focus:outline-none",
              children: /* @__PURE__ */ jsx(Redo2, { className: "size-4" })
            }
          ),
          /* @__PURE__ */ jsx(
            ze$1,
            {
              as: Fragment,
              enter: "transition ease-out duration-200",
              enterFrom: "opacity-0 translate-y-1 scale-95",
              enterTo: "opacity-100 translate-y-0 scale-100",
              leave: "transition ease-in duration-150",
              leaveFrom: "opacity-100 translate-y-0 scale-100",
              leaveTo: "opacity-0 translate-y-1 scale-95",
              children: /* @__PURE__ */ jsx(
                Bt,
                {
                  anchor: "top start",
                  className: "overflow-visible! z-[9999] w-64 p-1 [--anchor-gap:8px]",
                  children: /* @__PURE__ */ jsxs("div", { className: "rounded-xl bg-white/95 p-3 shadow-xl ring-1 ring-zinc-950/10 ring-inset backdrop-blur-lg", children: [
                    /* @__PURE__ */ jsx("p", { className: "font-medium text-sm text-zinc-950", children: "Restore checkpoint?" }),
                    /* @__PURE__ */ jsx("p", { className: "mt-1 text-xs text-zinc-600", children: "This will clear the chat history and undo file changes after this point." }),
                    /* @__PURE__ */ jsxs("div", { className: "mt-3 flex justify-end gap-2", children: [
                      /* @__PURE__ */ jsx(
                        Button,
                        {
                          variant: "secondary",
                          size: "sm",
                          onClick: () => close(),
                          className: "h-7 px-2 py-1 text-xs",
                          children: "Cancel"
                        }
                      ),
                      /* @__PURE__ */ jsx(
                        Button,
                        {
                          variant: "primary",
                          size: "sm",
                          onClick: () => {
                            confirmRestore(), close();
                          },
                          className: "h-7 px-2 py-1 text-xs",
                          children: "Restore"
                        }
                      )
                    ] })
                  ] })
                }
              )
            }
          )
        ] }) }),
        /* @__PURE__ */ jsx("div", { className: "flex h-full min-w-12 grow flex-row items-center justify-start", children: msg.role === "assistant" && (chatError == null ? void 0 : chatError.type) === AgentErrorType.AGENT_ERROR && /* @__PURE__ */ jsx(
          Button,
          {
            "aria-label": "Retry",
            variant: "secondary",
            glassy: !0,
            onClick: () => void retrySendingUserMessage(),
            className: "!opacity-100 z-10 size-8 cursor-pointer rounded-full p-1 shadow-md backdrop-blur-lg hover:bg-white/60 active:bg-zinc-50/60 disabled:bg-transparent disabled:shadow-none disabled:*:stroke-zinc-500/50",
            children: /* @__PURE__ */ jsx(RefreshCcw, { className: "size-4" })
          }
        ) })
      ]
    }
  ) });
}
const TextPartItem = memo(({ textPart }) => /* @__PURE__ */ jsx("div", { className: "markdown", children: /* @__PURE__ */ jsx(Markdown, { children: textPart.text }) })), ReasoningPartItem = memo(
  ({ reasoningPart }) => /* @__PURE__ */ jsx("div", { className: "-mx-1 block min-w-32 rounded-xl border-border/20 bg-zinc-500/5 px-2 py-0.5", children: /* @__PURE__ */ jsxs(je, { children: [
    /* @__PURE__ */ jsxs(Ce, { className: "group flex w-full flex-row items-center justify-between gap-2 text-black/60 hover:text-black/90", children: [
      /* @__PURE__ */ jsx(Brain, { className: "size-3" }),
      /* @__PURE__ */ jsx("span", { className: "block flex-1 text-start text-xs", children: "Thinking..." }),
      /* @__PURE__ */ jsx(
        ChevronDown,
        {
          className: "size-3 transition-all duration-150 ease-out group-hover:stroke-black group-data-open:rotate-180"
        }
      )
    ] }),
    /* @__PURE__ */ jsx(Re, { className: "markdown pt-1.5 pb-0.5 pl-1 opacity-80", children: /* @__PURE__ */ jsx(Markdown, { children: reasoningPart.text }) })
  ] }) })
), FilePartItem = memo(({ filePart }) => {
  const isImage = filePart.mediaType.startsWith("image/");
  return /* @__PURE__ */ jsxs(
    "div",
    {
      role: "button",
      className: "flex w-full cursor-pointer items-center gap-2 rounded-lg bg-black/5 p-2 hover:bg-black/10",
      onClick: () => {
        openFileUrl(filePart.url, filePart.filename);
      },
      children: [
        isImage ? /* @__PURE__ */ jsx(
          "img",
          {
            src: filePart.url,
            alt: filePart.filename ?? "Generated file",
            className: "size-4 rounded object-cover"
          }
        ) : /* @__PURE__ */ jsx(File, { className: "size-4" }),
        /* @__PURE__ */ jsx("span", { className: "text-xs", children: filePart.filename ?? "Generated file" })
      ]
    }
  );
}), DiffDisplay = memo(
  ({ toolPart }) => {
    var _a;
    if (!isFileEditTool(toolPart) || !((_a = toolPart.output) != null && _a.diff)) return null;
    const { diff } = toolPart.output;
    let beforeContent = "", afterContent = "", isOmitted = !1;
    if (diff.changeType === "create" ? "omitted" in diff && diff.omitted ? isOmitted = !0 : "after" in diff && (afterContent = diff.after) : diff.changeType === "delete" ? "omitted" in diff && diff.omitted ? isOmitted = !0 : "before" in diff && (beforeContent = diff.before) : diff.changeType === "modify" && (diff.beforeOmitted && diff.afterOmitted ? isOmitted = !0 : ("before" in diff && !diff.beforeOmitted && (beforeContent = diff.before), "after" in diff && !diff.afterOmitted && (afterContent = diff.after), (diff.beforeOmitted || diff.afterOmitted) && (isOmitted = !0))), isOmitted)
      return /* @__PURE__ */ jsx("div", { className: "mt-2 rounded-lg bg-zinc-100/50 p-2 text-xs text-zinc-600", children: /* @__PURE__ */ jsx("span", { className: "italic", children: "Diff content omitted (file too large)" }) });
    const changes = diffLines(beforeContent, afterContent), processedChanges = [];
    return changes.forEach((part, index2) => {
      const lines = (part.value || "").split(`
`).filter((l2, i2, arr) => !(i2 === arr.length - 1 && l2 === ""));
      if (part.added)
        processedChanges.push({ type: "add", lines });
      else if (part.removed)
        processedChanges.push({ type: "remove", lines });
      else if (lines.length > 0) {
        const contextLines = [];
        index2 === 0 && lines.length > 0 ? contextLines.push(lines[lines.length - 1]) : index2 === changes.length - 1 && lines.length > 0 || lines.length === 1 ? contextLines.push(lines[0]) : lines.length > 1 && (contextLines.push(lines[lines.length - 1]), index2 < changes.length - 1 && contextLines.push(lines[0])), contextLines.length > 0 && processedChanges.push({ type: "context", lines: contextLines });
      }
    }), /* @__PURE__ */ jsx("div", { className: "mt-2 overflow-x-auto rounded-lg bg-zinc-900 font-mono text-xs", children: /* @__PURE__ */ jsx("div", { className: "min-w-fit", children: processedChanges.map((change, idx) => /* @__PURE__ */ jsx("div", { children: change.lines.map((line, lineIdx) => /* @__PURE__ */ jsxs(
      "div",
      {
        className: cn(
          "whitespace-pre px-2 py-0.5",
          change.type === "add" && "bg-green-900/30 text-green-300",
          change.type === "remove" && "bg-red-900/30 text-red-300",
          change.type === "context" && "text-zinc-400"
        ),
        children: [
          /* @__PURE__ */ jsx("span", { className: "select-none opacity-50", children: change.type === "add" ? "+" : change.type === "remove" ? "-" : " " }),
          " ",
          line
        ]
      },
      `${change.type}-${idx}-${lineIdx}-${line.slice(0, 20)}`
    )) }, `${change.type}-${idx}-${change.lines.length}`)) }) });
  }
), ToolPartItem = memo(
  ({ toolPart }) => {
    const approveToolCall = useKartonProcedure((p2) => p2.approveToolCall), rejectToolCall = useKartonProcedure((p2) => p2.rejectToolCall), toolCallApprovalRequests = useKartonState(
      (s2) => s2.toolCallApprovalRequests
    ), [isExpanded, setIsExpanded] = useState(!1), requiresApproval = useMemo(
      () => toolCallApprovalRequests.includes(toolPart.toolCallId) && (toolPart.state === "output-available" || toolPart.state === "output-error"),
      [toolCallApprovalRequests, toolPart.toolCallId, toolPart.state]
    ), canShowDiff = useMemo(
      () => {
        var _a;
        return isFileEditTool(toolPart) && toolPart.state === "output-available" && ((_a = toolPart.output) == null ? void 0 : _a.diff) && (toolPart.output.diff.changeType === "modify" || toolPart.output.diff.changeType === "create" || toolPart.output.diff.changeType === "delete");
      },
      [toolPart]
    ), handleContainerClick = useCallback(() => {
      canShowDiff && setIsExpanded(!isExpanded);
    }, [canShowDiff, isExpanded]), handleKeyDown = useCallback(
      (e2) => {
        canShowDiff && (e2.key === "Enter" || e2.key === " ") && (e2.preventDefault(), setIsExpanded(!isExpanded));
      },
      [canShowDiff, isExpanded]
    ), containerProps = {
      className: cn(
        "-mx-1 flex flex-col gap-2 rounded-xl bg-zinc-500/5 px-2 py-0.5",
        canShowDiff && "cursor-pointer"
      ),
      ...canShowDiff && {
        onClick: handleContainerClick,
        onKeyDown: handleKeyDown,
        role: "button",
        tabIndex: 0
      }
    };
    return /* @__PURE__ */ jsxs("div", { ...containerProps, children: [
      /* @__PURE__ */ jsxs("div", { className: "flex w-full flex-row items-center justify-between gap-2 stroke-black/60", children: [
        getToolIcon(toolPart),
        /* @__PURE__ */ jsxs("div", { className: "flex flex-1 flex-col items-start gap-0", children: [
          getToolDescription(toolPart),
          toolPart.state === "output-error" && /* @__PURE__ */ jsx("span", { className: "text-rose-600 text-xs", children: toolPart.errorText }),
          requiresApproval && /* @__PURE__ */ jsx("span", { className: "text-black/50 text-xs italic", children: "Waiting for approval" })
        ] }),
        requiresApproval && /* @__PURE__ */ jsxs("div", { className: "flex flex-row items-center gap-1", children: [
          /* @__PURE__ */ jsx(
            Button,
            {
              type: "button",
              variant: "outline",
              size: "sm",
              className: "h-4 w-5",
              onClick: (e2) => {
                e2.stopPropagation(), rejectToolCall(toolPart.toolCallId);
              },
              children: /* @__PURE__ */ jsx(X, { className: "size-4" })
            }
          ),
          /* @__PURE__ */ jsx(
            Button,
            {
              type: "button",
              variant: "outline",
              size: "sm",
              className: "h-4 w-5",
              onClick: (e2) => {
                e2.stopPropagation(), approveToolCall(toolPart.toolCallId);
              },
              children: /* @__PURE__ */ jsx(Check, { className: "size-4" })
            }
          )
        ] }),
        toolPart.state === "output-available" && /* @__PURE__ */ jsxs(Fragment$1, { children: [
          /* @__PURE__ */ jsx(Check, { className: "size-3 text-green-600" }),
          canShowDiff && /* @__PURE__ */ jsx("div", { className: "transition-transform duration-150", children: /* @__PURE__ */ jsx(
            ChevronRight,
            {
              className: cn(
                "size-3 text-zinc-600 transition-transform",
                isExpanded && "rotate-90"
              )
            }
          ) })
        ] }),
        toolPart.state === "output-error" && /* @__PURE__ */ jsx(X, { className: "size-3 text-rose-600" }),
        (toolPart.state === "input-streaming" || toolPart.state === "input-available") && !requiresApproval && /* @__PURE__ */ jsx(Cog, { className: "size-3 animate-spin text-blue-600" })
      ] }),
      isExpanded && canShowDiff && /* @__PURE__ */ jsx(DiffDisplay, { toolPart })
    ] });
  }
), getToolIcon = (toolPart) => {
  switch (toolPart.type) {
    case "tool-readFileTool":
    case "tool-listFilesTool":
      return /* @__PURE__ */ jsx(Eye, { className: "size-3" });
    case "tool-grepSearchTool":
    case "tool-globTool":
      return /* @__PURE__ */ jsx(Search, { className: "size-3" });
    case "tool-overwriteFileTool":
    case "tool-multiEditTool":
      return /* @__PURE__ */ jsx(Pencil, { className: "size-3" });
    case "tool-deleteFileTool":
      return /* @__PURE__ */ jsx(Trash, { className: "size-3" });
    case "dynamic-tool":
      return /* @__PURE__ */ jsx(Cog, { className: "size-3" });
    default:
      return /* @__PURE__ */ jsx(Cog, { className: "size-3" });
  }
}, formatDuration = (minutes) => {
  if (minutes < 60)
    return `${minutes} minute${minutes !== 1 ? "s" : ""}`;
  const hours = Math.floor(minutes / 60), remainingMinutes = minutes % 60;
  if (hours >= 24) {
    const days = Math.floor(hours / 24), remainingHours = hours % 24;
    return days === 1 && remainingHours === 0 ? "1 day" : remainingHours === 0 ? `${days} days` : days === 1 ? `1 day and ${remainingHours} hour${remainingHours !== 1 ? "s" : ""}` : `${days} days and ${remainingHours} hour${remainingHours !== 1 ? "s" : ""}`;
  }
  return remainingMinutes === 0 ? `${hours} hour${hours !== 1 ? "s" : ""}` : `${hours} hour${hours !== 1 ? "s" : ""} and ${remainingMinutes} minute${remainingMinutes !== 1 ? "s" : ""}`;
}, needsExtraCreditsMessage = `Oh no, you ran out of credits!

You can [buy extra credits here](https://console.stagewise.io/billing/checkout-extra-credits) so we can continue working on your app `, needsSubscriptionMessage = `Wow, looks like you ran out of included credits in your trial!

Let's [setup your subscription](https://console.stagewise.io/billing/checkout) so we can continue working on your app `, freeTrialPlanLimitExceededMessage = (minutes) => minutes !== void 0 ? `Wow, looks like you ran out of your daily prompts in your trial!

You can [setup a subscription](https://console.stagewise.io/billing/checkout) or wait ${formatDuration(minutes)} before your next request ` : `Wow, looks like you ran out of your daily prompts in your trial!

You can [setup a subscription](https://console.stagewise.io/billing/checkout) so we can continue working on your app `, paidPlanLimitExceededMessage = (minutes) => minutes !== void 0 ? `Wow, looks like you ran out of your daily prompts in your subscription!

You need to wait ${formatDuration(minutes)} before your next request or [ping the stagewise team on Discord](https://discord.gg/gkdGsDYaKA) ` : `Wow, looks like you ran out of your daily prompts in your subscription!

You can wait until the cooldown period ends (max 24 hours) or [ping the stagewise team on Discord](https://discord.gg/gkdGsDYaKA) `;
function ChatErrorBubble({ error: error2 }) {
  const retrySendingUserMessage = useKartonProcedure(
    (p2) => p2.retrySendingUserMessage
  ), subscription = useKartonState((s2) => s2.subscription), errorMessage = useMemo(() => {
    switch (error2.type) {
      case AgentErrorType.INSUFFICIENT_CREDITS:
        return subscription != null && subscription.hasSubscription ? needsExtraCreditsMessage : needsSubscriptionMessage;
      case AgentErrorType.PLAN_LIMITS_EXCEEDED:
        return subscription != null && subscription.hasSubscription ? paidPlanLimitExceededMessage(error2.error.cooldownMinutes) : freeTrialPlanLimitExceededMessage(error2.error.cooldownMinutes);
      default:
        return error2.error.message;
    }
  }, [error2, subscription == null ? void 0 : subscription.hasSubscription]), isHandledError = useMemo(() => error2.type === AgentErrorType.INSUFFICIENT_CREDITS || error2.type === AgentErrorType.PLAN_LIMITS_EXCEEDED, [error2.type]);
  return /* @__PURE__ */ jsx("div", { className: "flex flex-col gap-1", children: /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "mt-2 flex w-full shrink-0 flex-row items-center justify-start gap-2"
      ),
      children: [
        /* @__PURE__ */ jsxs(
          "div",
          {
            className: cn(
              "markdown group relative min-h-8 animate-chat-bubble-appear space-y-3 break-words rounded-2xl bg-white/5 px-2.5 py-1.5 font-normal text-sm shadow-lg shadow-zinc-950/10 ring-1 ring-inset last:mb-0.5",
              isHandledError ? "min-w-48 origin-bottom-left rounded-bl-xs bg-zinc-100/60 text-zinc-950 ring-zinc-950/5" : "min-w-48 origin-bottom-left rounded-bl-xs bg-rose-600/90 text-white ring-rose-100/5"
            ),
            children: [
              /* @__PURE__ */ jsx(Markdown, { children: errorMessage }),
              !isHandledError && /* @__PURE__ */ jsxs("span", { className: "mt-2 block text-xs italic", children: [
                error2.type,
                ": ",
                error2.error.name
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsx("div", { className: "flex h-full min-w-12 grow flex-row items-center justify-start", children: /* @__PURE__ */ jsx(
          Button,
          {
            "aria-label": "Retry",
            variant: "secondary",
            glassy: !0,
            onClick: () => void retrySendingUserMessage(),
            className: "!opacity-100 z-10 size-8 cursor-pointer rounded-full p-1 shadow-md backdrop-blur-lg hover:bg-white/60 active:bg-zinc-50/60 disabled:bg-transparent disabled:shadow-none disabled:*:stroke-zinc-500/50",
            children: /* @__PURE__ */ jsx(RefreshCcw, { className: "size-4" })
          }
        ) })
      ]
    }
  ) });
}
function ChatHistory({ ref }) {
  const wasAtBottomRef = useRef(!0), { activeChatId, isWorking, chats } = useKartonState(
    useComparingSelector((s2) => ({
      activeChatId: s2.activeChatId,
      isWorking: s2.isWorking,
      chats: s2.chats
    }))
  ), activeChat = useMemo(() => activeChatId ? chats[activeChatId] : null, [activeChatId, chats]), scrollToBottom = () => {
    const container = ref.current;
    container && setTimeout(() => {
      container.scrollTop = container.scrollHeight;
    }, 0);
  }, checkIfAtBottom = () => {
    const container = ref.current;
    return container ? container.scrollTop + container.clientHeight >= container.scrollHeight - 10 : !0;
  }, handleScroll = () => {
    const isAtBottom = checkIfAtBottom();
    wasAtBottomRef.current = isAtBottom;
  };
  useEffect(() => {
    ref.current && wasAtBottomRef.current && scrollToBottom();
  }, [activeChat]), useEffect(() => {
    const container = ref.current;
    if (container)
      return container.addEventListener("scroll", handleScroll), scrollToBottom(), wasAtBottomRef.current = !0, () => {
        container.removeEventListener("scroll", handleScroll);
      };
  }, []);
  const renderedMessages = useMemo(() => activeChat != null && activeChat.messages ? activeChat.messages.filter((message) => message.role === "user" || message.role === "assistant") : [], [activeChat]);
  return /* @__PURE__ */ jsxs(
    "section",
    {
      ref,
      "aria-label": "Agent message display",
      className: "scrollbar-thin scrollbar-thumb-black/15 scrollbar-track-transparent pointer-events-auto block h-full min-h-[inherit] overflow-y-scroll overscroll-contain py-4 pt-16 pr-0 pb-14 pl-3 text-foreground text-sm focus-within:outline-none hover:bg-white/0 focus:outline-none",
      onScroll: handleScroll,
      onMouseEnter: () => {
        var _a;
        (_a = ref.current) == null || _a.focus();
      },
      children: [
        renderedMessages.map((message, index2) => /* @__PURE__ */ jsx(
          ChatBubble,
          {
            message,
            isLastMessage: index2 === renderedMessages.length - 1
          },
          `${message.role}-${index2}`
        )) ?? [],
        (activeChat == null ? void 0 : activeChat.error) && /* @__PURE__ */ jsx(ChatErrorBubble, { error: activeChat.error }),
        /* @__PURE__ */ jsx(
          "div",
          {
            className: cn(
              "mt-4 flex h-0 w-full flex-row items-center justify-start gap-2 pl-1 text-xs text-zinc-500 opacity-0",
              isWorking && "h-auto opacity-100"
            ),
            children: /* @__PURE__ */ jsx(LoaderCircle, { className: "size-4 animate-spin stroke-blue-600" })
          }
        ),
        renderedMessages.length === 0 && /* @__PURE__ */ jsxs("div", { className: "flex flex-col items-center justify-center gap-3 px-4 py-2 text-black/30 text-sm", children: [
          /* @__PURE__ */ jsx(Sparkles, { className: "size-8 stroke-black opacity-10" }),
          /* @__PURE__ */ jsx("span", { children: "Start by writing a message" })
        ] })
      ]
    }
  );
}
function ContextElementsChipsFlexible({
  domContextElements,
  removeChatDomContext
}) {
  const { setHoveredElement } = useContextChipHover();
  return domContextElements.length === 0 ? null : /* @__PURE__ */ jsx(Fragment$1, { children: domContextElements.map((contextElement, index2) => /* @__PURE__ */ jsx(
    ContextElementChip,
    {
      element: contextElement.element,
      pluginContext: contextElement.pluginContext,
      onDelete: () => removeChatDomContext(contextElement.element),
      onHover: setHoveredElement,
      onUnhover: () => setHoveredElement(null)
    },
    `${contextElement.element.tagName}-${index2}`
  )) });
}
function ContextElementChip({
  element: element2,
  pluginContext,
  onDelete,
  onHover,
  onUnhover
}) {
  const chipLabel = useMemo(() => {
    var _a, _b;
    const firstAnnotation = (_b = (_a = pluginContext.find(
      (plugin) => {
        var _a2;
        return (_a2 = plugin.context) == null ? void 0 : _a2.annotation;
      }
    )) == null ? void 0 : _a.context) == null ? void 0 : _b.annotation;
    if (firstAnnotation)
      return firstAnnotation;
    const tagName = element2.tagName.toLowerCase(), id = element2.id ? `#${element2.id}` : "";
    return `${tagName}${id}`;
  }, [element2, pluginContext]);
  return /* @__PURE__ */ jsxs(
    "button",
    {
      type: "button",
      tabIndex: -1,
      className: cn(
        "flex min-w-fit shrink-0 items-center gap-1 rounded-lg border border-border/20 bg-white/30 px-2 py-1 text-xs shadow-sm backdrop-blur-lg transition-all hover:border-border/40 hover:bg-white/80"
      ),
      onMouseEnter: () => onHover(element2),
      onMouseLeave: () => onUnhover(),
      children: [
        /* @__PURE__ */ jsx(SquareDashedMousePointer, { className: "size-3 text-foreground/60" }),
        /* @__PURE__ */ jsx("span", { className: "max-w-24 truncate font-medium text-foreground/80", children: chipLabel }),
        /* @__PURE__ */ jsx(
          "button",
          {
            type: "button",
            onClick: (e2) => {
              e2.stopPropagation(), onDelete();
            },
            className: "text-muted-foreground transition-colors hover:text-red-500",
            children: /* @__PURE__ */ jsx(X, { className: "size-3" })
          }
        )
      ]
    }
  );
}
const Tooltip = ({
  children
}) => /* @__PURE__ */ jsx(TooltipRoot, { delay: 200, children }), TooltipTrigger = ({ children }) => /* @__PURE__ */ jsx(TooltipTrigger$1, { render: children }), TooltipContent = ({ children }) => /* @__PURE__ */ jsx(TooltipPortal, { children: /* @__PURE__ */ jsx(TooltipPositioner, { sideOffset: 2, alignOffset: 2, children: /* @__PURE__ */ jsx(TooltipPopup, { className: "rounded-lg border border-border/20 bg-gradient-to-b from-white/40 to-zinc-50/60 px-1.5 py-0.5 text-xs text-zinc-950/80 shadow-md backdrop-blur-sm", children }) }) });
function FileAttachmentChips({
  fileAttachments,
  removeFileAttachment
}) {
  return fileAttachments.length === 0 ? null : /* @__PURE__ */ jsx(Fragment$1, { children: fileAttachments.map((attachment) => /* @__PURE__ */ jsx(
    FileAttachmentChip,
    {
      attachment,
      onDelete: () => removeFileAttachment(attachment.id)
    },
    attachment.id
  )) });
}
function FileAttachmentChip({ attachment, onDelete }) {
  const isImage = useMemo(() => attachment.file.type.startsWith("image/"), [attachment.file.type]), validation = useMemo(() => isAnthropicSupportedFile(attachment.file), [attachment.file]), fileName = useMemo(() => {
    const name2 = attachment.file.name;
    if (name2.length > 20) {
      const lastDot = name2.lastIndexOf("."), base = lastDot > 0 ? name2.substring(0, lastDot) : name2, ext = lastDot > 0 ? name2.substring(lastDot) : "";
      return base.length > 15 ? `${base.substring(0, 15)}...${ext}` : `${base}${ext}`;
    }
    return name2;
  }, [attachment.file.name]), chipContent = /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "flex min-w-fit shrink-0 items-center gap-1 rounded-lg border border-border/20 bg-white/30 px-2 py-1 shadow-sm backdrop-blur-lg transition-all",
        validation.supported ? "hover:border-border/40 hover:bg-white/80" : "opacity-50 hover:opacity-70"
      ),
      children: [
        isImage ? /* @__PURE__ */ jsx("div", { className: "relative size-4 overflow-hidden rounded", children: /* @__PURE__ */ jsx(
          "img",
          {
            src: attachment.url,
            alt: attachment.file.name,
            className: "size-full object-cover"
          }
        ) }) : /* @__PURE__ */ jsx(File, { className: "size-3 text-foreground/60" }),
        /* @__PURE__ */ jsx("span", { className: "max-w-24 truncate font-medium text-foreground/80 text-xs", children: fileName }),
        /* @__PURE__ */ jsx(
          "button",
          {
            type: "button",
            onClick: (e2) => {
              e2.stopPropagation(), onDelete();
            },
            className: "text-muted-foreground transition-colors hover:text-red-500",
            children: /* @__PURE__ */ jsx(X, { className: "size-3" })
          }
        )
      ]
    }
  );
  return validation.supported ? chipContent : /* @__PURE__ */ jsxs(Tooltip, { children: [
    /* @__PURE__ */ jsx(TooltipTrigger, { children: chipContent }),
    /* @__PURE__ */ jsx(TooltipContent, { children: validation.reason })
  ] });
}
const textSlideshowVariants = cva(
  "relative block h-[1.2em] h-full overflow-hidden"
);
function TextSlideshow({
  className,
  texts,
  changeEveryMs = 3e3,
  ...props
}) {
  const [currentIndex, setCurrentIndex] = React.useState(0), [isAnimating, setIsAnimating] = React.useState(!1);
  return React.useEffect(() => {
    if (texts.length <= 1) return;
    const interval = setInterval(() => {
      setIsAnimating(!0), setTimeout(() => {
        setCurrentIndex((prevIndex) => (prevIndex + 1) % texts.length), setIsAnimating(!1);
      }, 300);
    }, changeEveryMs);
    return () => clearInterval(interval);
  }, [texts.length, changeEveryMs]), texts.length === 0 ? null : /* @__PURE__ */ jsxs(
    "span",
    {
      "data-slot": "text-slideshow",
      className: cn(textSlideshowVariants(), className),
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "span",
          {
            className: cn(
              "absolute inset-0 transition-all duration-300 ease-in-out",
              isAnimating ? "-translate-y-2 transform opacity-0 blur-sm" : "translate-y-0 transform opacity-100"
            ),
            children: texts[currentIndex]
          },
          `current-${currentIndex}`
        ),
        /* @__PURE__ */ jsx(
          "span",
          {
            className: cn(
              "absolute inset-0 transition-all duration-300 ease-in-out",
              isAnimating ? "translate-y-0 opacity-100" : "translate-y-2 opacity-0 blur-sm"
            ),
            children: texts[(currentIndex + 1) % texts.length]
          },
          `next-${(currentIndex + 1) % texts.length}`
        )
      ]
    }
  );
}
const BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua))
      return _const;
  }
  static getWindowsVersionName(version) {
    switch (version) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version) {
    const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    if (v2.push(0), v2[0] === 10)
      switch (v2[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version) {
    const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    if (v2.push(0), !(v2[0] === 1 && v2[1] < 5)) {
      if (v2[0] === 1 && v2[1] < 6) return "Cupcake";
      if (v2[0] === 1 && v2[1] >= 6) return "Donut";
      if (v2[0] === 2 && v2[1] < 2) return "Eclair";
      if (v2[0] === 2 && v2[1] === 2) return "Froyo";
      if (v2[0] === 2 && v2[1] > 2) return "Gingerbread";
      if (v2[0] === 3) return "Honeycomb";
      if (v2[0] === 4 && v2[1] < 1) return "Ice Cream Sandwich";
      if (v2[0] === 4 && v2[1] < 4) return "Jelly Bean";
      if (v2[0] === 4 && v2[1] >= 4) return "KitKat";
      if (v2[0] === 5) return "Lollipop";
      if (v2[0] === 6) return "Marshmallow";
      if (v2[0] === 7) return "Nougat";
      if (v2[0] === 8) return "Oreo";
      if (v2[0] === 9) return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version) {
    return version.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = !1) {
    const versionAPrecision = Utils.getVersionPrecision(versionA), versionBPrecision = Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision), lastPrecision = 0;
    const chunks = Utils.map([versionA, versionB], (version) => {
      const delta = precision - Utils.getVersionPrecision(version), _version = version + new Array(delta + 1).join(".0");
      return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    for (isLoose && (lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision)), precision -= 1; precision >= lastPrecision; ) {
      if (chunks[0][precision] > chunks[1][precision])
        return 1;
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision)
          return 0;
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator) {
    const result = [];
    let i2;
    if (Array.prototype.map)
      return Array.prototype.map.call(arr, iterator);
    for (i2 = 0; i2 < arr.length; i2 += 1)
      result.push(iterator(arr[i2]));
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i2, l2;
    if (Array.prototype.find)
      return Array.prototype.find.call(arr, predicate);
    for (i2 = 0, l2 = arr.length; i2 < l2; i2 += 1) {
      const value = arr[i2];
      if (predicate(value, i2))
        return value;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i2, l2;
    if (Object.assign)
      return Object.assign(obj, ...assigners);
    for (i2 = 0, l2 = assigners.length; i2 < l2; i2 += 1) {
      const assigner = assigners[i2];
      typeof assigner == "object" && assigner !== null && Object.keys(assigner).forEach((key) => {
        result[key] = assigner[key];
      });
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i, browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      }, version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      }, version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      }, version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      }, version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      }, version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      }, version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      }, version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      }, version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      }, version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      }, version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      }, version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      }, version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      }, version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      }, version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      }, version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      }, version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      }, version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      }, version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      }, version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      }, version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      }, version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      }, version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      }, version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      }, version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      }, version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      }, version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      }, version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i), butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      }, version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      return version && (browser.version = version), browser;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /, regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/, regexp = ua.search("\\(") !== -1 ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
], osParsersList = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua) {
      const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua), versionName = Utils.getWindowsVersionName(version);
      return {
        name: OS_MAP.Windows,
        version,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      }, version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      return version && (result.version = version), result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, "."), versionName = Utils.getMacOSVersionName(version), os = {
        name: OS_MAP.MacOS,
        version
      };
      return versionName && (os.versionName = versionName), os;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i), butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua), versionName = Utils.getAndroidVersionName(version), os = {
        name: OS_MAP.Android,
        version
      };
      return versionName && (os.versionName = versionName), os;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua), os = {
        name: OS_MAP.WebOS
      };
      return version && version.length && (os.version = version), os;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version
      };
    }
  }
], platformParsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova", platform2 = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      return model && (platform2.model = model), platform2;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i), likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(!0) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
], enginesParsersList = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(!0) === "microsoft edge";
    },
    describe(ua) {
      if (/\sedg\//i.test(ua))
        return {
          name: ENGINE_MAP.Blink
        };
      const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      }, version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (engine.version = version), engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      }, version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (engine.version = version), engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i), likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      }, version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (engine.version = version), engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      }, version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      return version && (engine.version = version), engine;
    }
  }
];
class Parser {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA, skipParsing = !1) {
    if (UA == null || UA === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = UA, this.parsedResult = {}, skipParsing !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex) {
    return regex.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(browsersList, (_browser) => {
      if (typeof _browser.test == "function")
        return _browser.test(this);
      if (_browser.test instanceof Array)
        return _browser.test.some((condition) => this.test(condition));
      throw new Error("Browser's test function is not valid");
    });
    return browserDescriptor && (this.parsedResult.browser = browserDescriptor.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    return toLowerCase ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(osParsersList, (_os) => {
      if (typeof _os.test == "function")
        return _os.test(this);
      if (_os.test instanceof Array)
        return _os.test.some((condition) => this.test(condition));
      throw new Error("Browser's test function is not valid");
    });
    return os && (this.parsedResult.os = os.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name: name2 } = this.getOS();
    return toLowerCase ? String(name2).toLowerCase() || "" : name2 || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = !1) {
    const { type } = this.getPlatform();
    return toLowerCase ? String(type).toLowerCase() || "" : type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform2 = Utils.find(platformParsersList, (_platform) => {
      if (typeof _platform.test == "function")
        return _platform.test(this);
      if (_platform.test instanceof Array)
        return _platform.test.some((condition) => this.test(condition));
      throw new Error("Browser's test function is not valid");
    });
    return platform2 && (this.parsedResult.platform = platform2.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    return toLowerCase ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(enginesParsersList, (_engine) => {
      if (typeof _engine.test == "function")
        return _engine.test(this);
      if (_engine.test instanceof Array)
        return _engine.test.some((condition) => this.test(condition));
      throw new Error("Browser's test function is not valid");
    });
    return engine && (this.parsedResult.engine = engine.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    if (Object.keys(checkTree).forEach((key) => {
      const currentDefinition = checkTree[key];
      typeof currentDefinition == "string" ? (browsers[key] = currentDefinition, browsersCounter += 1) : typeof currentDefinition == "object" && (platformsAndOSes[key] = currentDefinition, platformsAndOSCounter += 1);
    }), platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes), OSMatchingDefinition = Utils.find(platformsAndOSNames, (name2) => this.isOS(name2));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0)
          return osResult;
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name2) => this.isPlatform(name2)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0)
          return platformResult;
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers), matchingDefinition = Utils.find(browserNames, (name2) => this.isBrowser(name2, !0));
      if (matchingDefinition !== void 0)
        return this.compareVersion(browsers[matchingDefinition]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = !1) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    return includingAlias && alias && (browserNameLower = alias.toLowerCase()), browserNameLower === defaultBrowserName;
  }
  compareVersion(version) {
    let expectedResults = [0], comparableVersion = version, isLoose = !1;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion == "string")
      return version[0] === ">" || version[0] === "<" ? (comparableVersion = version.substr(1), version[1] === "=" ? (isLoose = !0, comparableVersion = version.substr(2)) : expectedResults = [], version[0] === ">" ? expectedResults.push(1) : expectedResults.push(-1)) : version[0] === "=" ? comparableVersion = version.substr(1) : version[0] === "~" && (isLoose = !0, comparableVersion = version.substr(1)), expectedResults.indexOf(
        Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
      ) > -1;
  }
  isOS(osName) {
    return this.getOSName(!0) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(!0) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(!0) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = !1) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA, skipParsing = !1) {
    if (typeof UA != "string")
      throw new Error("UserAgent should be a string");
    return new Parser(UA, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA) {
    return new Parser(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
const useBrowserInfo = () => useMemo(() => {
  const iframeWindow = getIFrameWindow(), userAgent2 = (iframeWindow == null ? void 0 : iframeWindow.navigator.userAgent) || window.navigator.userAgent, result = Bowser.parse(userAgent2);
  return {
    browser: result.browser,
    engine: result.engine,
    os: result.os
  };
}, []);
function HotkeyComboText({ action }) {
  return useBrowserInfo().os.name.toLowerCase().includes("mac") ? hotkeyActionDefinitions[action].keyComboMac : hotkeyActionDefinitions[action].keyComboDefault;
}
const GlassyTextInputClassNames = "origin-center rounded-xl border border-black/10 ring-1 ring-white/20 transition-all duration-150 ease-out after:absolute after:inset-0 after:size-full after:content-normal after:rounded-[inherit] after:bg-gradient-to-b after:from-white/5 after:to-white/0 after:transition-colors after:duration-150 after:ease-out disabled:pointer-events-none disabled:bg-black/5 disabled:text-foreground/60 disabled:opacity-30";
function ChatPanelFooter({
  ref,
  inputRef
}) {
  const chatState = useChatState(), isWorking = useKartonState((s2) => s2.isWorking), activeChatId = useKartonState((s2) => s2.activeChatId), stopAgent = useKartonProcedure((p2) => p2.abortAgentCall), canStop = useKartonState((s2) => s2.isWorking), chats = useKartonState((s2) => s2.chats), isConnected = useKartonConnected(), abortAgent = useCallback(() => {
    stopAgent();
  }, [stopAgent]), activeChat = useMemo(() => activeChatId ? chats[activeChatId] : null, [activeChatId, chats]), [isComposing, setIsComposing] = useState(!1), enableInputField = useMemo(() => isConnected ? !isWorking : !1, [isWorking, isConnected]), canSendMessage = useMemo(() => enableInputField && chatState.chatInput.trim().length > 2 && chatState.isPromptCreationActive, [enableInputField, chatState]), handleSubmit = useCallback(() => {
    canSendMessage && chatState.sendMessage();
  }, [chatState, canSendMessage]), handleKeyDown = useCallback(
    (e2) => {
      e2.key === "Enter" && !e2.shiftKey && !isComposing && (e2.preventDefault(), handleSubmit());
    },
    [handleSubmit, isComposing]
  ), handlePaste = useCallback(
    (e2) => {
      const items = e2.clipboardData.items, files = [];
      for (let i2 = 0; i2 < items.length; i2++) {
        const item = items[i2];
        if (item.kind === "file") {
          const file = item.getAsFile();
          file && files.push(file);
        }
      }
      files.length > 0 && (e2.preventDefault(), files.forEach((file) => {
        chatState.addFileAttachment(file);
      }), chatState.isPromptCreationActive || (chatState.startPromptCreation(), chatState.startContextSelector()));
    },
    [chatState]
  ), handleCompositionStart = useCallback(() => {
    setIsComposing(!0);
  }, []), handleCompositionEnd = useCallback(() => {
    setIsComposing(!1);
  }, []), showMultiLineTextArea = useMemo(() => chatState.chatInput.includes(`
`) || chatState.chatInput.length > 40, [chatState.chatInput]), showTextSlideshow = useMemo(() => ((activeChat == null ? void 0 : activeChat.messages.length) ?? 0) === 0 && chatState.chatInput.length === 0, [activeChat == null ? void 0 : activeChat.messages.length, chatState.chatInput]);
  return /* @__PURE__ */ jsxs(
    PanelFooter,
    {
      clear: !0,
      className: "absolute right-px bottom-px left-px z-10 flex flex-col items-stretch gap-1 px-3 pt-2 pb-3",
      ref,
      children: [
        (chatState.fileAttachments.length > 0 || chatState.domContextElements.length > 0) && /* @__PURE__ */ jsxs("div", { className: "scrollbar-thin flex gap-2 overflow-x-auto pb-1", children: [
          /* @__PURE__ */ jsx(
            FileAttachmentChips,
            {
              fileAttachments: chatState.fileAttachments,
              removeFileAttachment: chatState.removeFileAttachment
            }
          ),
          /* @__PURE__ */ jsx(
            ContextElementsChipsFlexible,
            {
              domContextElements: chatState.domContextElements,
              removeChatDomContext: chatState.removeChatDomContext
            }
          )
        ] }),
        /* @__PURE__ */ jsxs("div", { className: "flex h-fit flex-1 flex-row items-end justify-between gap-1", children: [
          /* @__PURE__ */ jsxs("div", { className: "relative flex flex-1 pr-1", children: [
            /* @__PURE__ */ jsx(
              J,
              {
                ref: inputRef,
                value: chatState.chatInput,
                onChange: (e2) => {
                  chatState.setChatInput(e2.target.value);
                },
                onFocus: () => {
                  chatState.isPromptCreationActive || (chatState.startPromptCreation(), chatState.startContextSelector());
                },
                onKeyDown: handleKeyDown,
                onPaste: handlePaste,
                onCompositionStart: handleCompositionStart,
                onCompositionEnd: handleCompositionEnd,
                disabled: !enableInputField,
                className: cn(
                  GlassyTextInputClassNames,
                  "scrollbar-thin scrollbar-thumb-black/20 scrollbar-track-transparent z-10 w-full resize-none rounded-2xl bg-zinc-500/5 px-2 py-1 text-zinc-950 shadow-md backdrop-blur-lg transition-all duration-300 ease-out placeholder:text-foreground/40 focus:bg-blue-200/20 focus:shadow-blue-400/10 focus:shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
                  showMultiLineTextArea && !isWorking ? "h-26" : "h-8",
                  chatState.isPromptCreationActive && "pr-8"
                  // Add padding for context button
                ),
                placeholder: !showTextSlideshow && "Type a message..."
              }
            ),
            /* @__PURE__ */ jsx("div", { className: "pointer-events-none absolute inset-0 z-20 size-full px-[9px] py-[5px]", children: /* @__PURE__ */ jsx(
              TextSlideshow,
              {
                className: cn(
                  "text-foreground/40 text-sm",
                  !showTextSlideshow && "opacity-0"
                ),
                texts: [
                  "Try: Add a new button into the top right corner",
                  "Try: Convert these cards into accordions",
                  "Try: Add a gradient to the background"
                ]
              }
            ) }),
            chatState.isPromptCreationActive && /* @__PURE__ */ jsx("div", { className: "-translate-y-1/2 absolute top-1/2 right-2 z-30", children: /* @__PURE__ */ jsxs(Tooltip, { children: [
              /* @__PURE__ */ jsx(TooltipTrigger, { children: /* @__PURE__ */ jsx(
                Button,
                {
                  onMouseDown: (e2) => {
                    e2.preventDefault();
                  },
                  onClick: (e2) => {
                    var _a;
                    e2.preventDefault(), e2.stopPropagation(), chatState.isContextSelectorActive ? chatState.stopContextSelector() : chatState.startContextSelector(), (_a = inputRef.current) == null || _a.focus();
                  },
                  "aria-label": "Select context elements",
                  variant: "ghost",
                  className: cn(
                    "z-10 size-6 cursor-pointer rounded-full border-none bg-transparent p-0 backdrop-blur-lg",
                    chatState.isContextSelectorActive ? "bg-blue-600/10 text-blue-600" : "text-zinc-500 opacity-70"
                  ),
                  children: /* @__PURE__ */ jsx(MousePointer, { className: "size-4" })
                }
              ) }),
              /* @__PURE__ */ jsx(TooltipContent, { children: chatState.isContextSelectorActive ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
                "Stop selecting elements (",
                /* @__PURE__ */ jsx(HotkeyComboText, { action: HotkeyActions.ESC }),
                ")"
              ] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
                "Add reference elements (",
                /* @__PURE__ */ jsx(HotkeyComboText, { action: HotkeyActions.CTRL_ALT_PERIOD }),
                ")"
              ] }) })
            ] }) })
          ] }),
          canStop && /* @__PURE__ */ jsxs(Tooltip, { children: [
            /* @__PURE__ */ jsx(TooltipTrigger, { children: /* @__PURE__ */ jsx(
              Button,
              {
                onClick: abortAgent,
                "aria-label": "Stop agent",
                glassy: !0,
                variant: "secondary",
                className: "!opacity-100 group z-10 size-8 cursor-pointer rounded-full p-1 shadow-md backdrop-blur-lg !disabled:*:opacity-10 hover:bg-rose-600/20",
                children: /* @__PURE__ */ jsx(Square, { className: "size-3 fill-zinc-500 stroke-zinc-500 group-hover:fill-zinc-800 group-hover:stroke-zinc-800" })
              }
            ) }),
            /* @__PURE__ */ jsx(TooltipContent, { children: "Stop agent" })
          ] }),
          /* @__PURE__ */ jsxs(Tooltip, { children: [
            /* @__PURE__ */ jsx(TooltipTrigger, { children: /* @__PURE__ */ jsx(
              Button,
              {
                disabled: !canSendMessage,
                onClick: handleSubmit,
                "aria-label": "Send message",
                glassy: !0,
                variant: "primary",
                className: "!opacity-100 z-10 size-8 cursor-pointer rounded-full p-1 shadow-md backdrop-blur-lg disabled:bg-transparent disabled:shadow-none disabled:*:stroke-zinc-500/50",
                children: /* @__PURE__ */ jsx(ArrowUp, { className: "size-4 stroke-3" })
              }
            ) }),
            /* @__PURE__ */ jsx(TooltipContent, { children: "Send message" })
          ] })
        ] })
      ]
    }
  );
}
function ChatList({ onClose }) {
  const { chats, activeChatId, isWorking } = useKartonState(
    useComparingSelector((s2) => ({
      chats: s2.chats,
      activeChatId: s2.activeChatId,
      isWorking: s2.isWorking
    }))
  );
  return useEffect(() => {
    (Object.keys(chats).length === 0 || isWorking) && onClose();
  }, [chats, isWorking, onClose]), /* @__PURE__ */ jsx("div", { className: "flex flex-col divide-y divide-zinc-500/10", children: Object.entries(chats).map(([chatId, chat]) => /* @__PURE__ */ jsx(
    ChatListEntry,
    {
      chatId,
      chat,
      isActive: chatId === activeChatId,
      isOnly: Object.keys(chats).length === 1,
      onClose
    },
    chatId
  )) });
}
function ChatListEntry({
  chat,
  chatId,
  isActive,
  onClose,
  isOnly
}) {
  const deleteChat = useKartonProcedure((p2) => p2.deleteChat), switchChat = useKartonProcedure((p2) => p2.switchChat);
  return /* @__PURE__ */ jsx("div", { className: "py-0.5", children: /* @__PURE__ */ jsxs(
    "div",
    {
      className: "flex shrink-0 cursor-pointer flex-row items-center justify-between gap-4 rounded-lg px-2 py-2 transition-colors duration-150 hover:bg-zinc-500/5",
      role: "button",
      onClick: () => {
        switchChat(chatId), onClose();
      },
      children: [
        /* @__PURE__ */ jsxs("div", { className: "flex flex-1 flex-col items-start justify-start gap-0", children: [
          /* @__PURE__ */ jsx(
            "span",
            {
              className: cn(
                "truncate font-medium text-sm text-zinc-950",
                isActive && "text-blue-600"
              ),
              children: chat.title
            }
          ),
          /* @__PURE__ */ jsx("span", { className: "text-xs text-zinc-600", children: /* @__PURE__ */ jsx(TimeAgo, { date: chat.createdAt }) })
        ] }),
        /* @__PURE__ */ jsx("div", { className: "flex flex-row gap-1", children: /* @__PURE__ */ jsx(
          "button",
          {
            className: "pointer-cursor flex size-8 items-center justify-center rounded-full text-zinc-500 transition-all duration-150 hover:bg-rose-600/10 hover:text-rose-600",
            type: "button",
            onClick: (ev) => {
              ev.stopPropagation(), deleteChat(chatId), isOnly && onClose();
            },
            children: /* @__PURE__ */ jsx(Trash2, { className: "size-4" })
          }
        ) })
      ]
    }
  ) });
}
function ChatPanelHeader() {
  const [chatListOpen, setChatListOpen] = useState(!1), createChatProcedure = useKartonProcedure((p2) => p2.createChat), chats = useKartonState((s2) => s2.chats), activeChatId = useKartonState((s2) => s2.activeChatId), isWorking = useKartonState((s2) => s2.isWorking), { startPromptCreation } = useChatState(), createChat = useCallback(() => {
    createChatProcedure().then(() => {
      setChatListOpen(!1), startPromptCreation();
    });
  }, [createChatProcedure, setChatListOpen, startPromptCreation]), emptyChatExists = useMemo(
    () => Object.values(chats).length === 0 || Object.values(chats).some((chat) => chat.messages.length === 0),
    [chats]
  ), showChatListButton = Object.keys(chats).length > 1, showNewChatButton = activeChatId && !emptyChatExists;
  return /* @__PURE__ */ jsx(
    PanelHeader,
    {
      className: cn(
        "pointer-events-none absolute top-px right-px left-px z-20 mb-0 origin-bottom px-3 py-3 pl-4.5 transition-all duration-300 ease-out *:pointer-events-auto",
        chatListOpen ? "h-[calc(100%-2px)] rounded-[inherit] bg-white/60 backdrop-blur-lg" : "!h-[calc-size(auto,size)] h-auto"
      ),
      title: chatListOpen && /* @__PURE__ */ jsx("span", { className: "mt-0.5", children: "Chats" }),
      clear: !0,
      actionArea: /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsxs("div", { className: "flex flex-row-reverse gap-1", children: [
          (showChatListButton || chatListOpen) && /* @__PURE__ */ jsxs(Tooltip, { children: [
            /* @__PURE__ */ jsx(TooltipTrigger, { children: /* @__PURE__ */ jsx(
              Button,
              {
                "aria-label": chatListOpen ? "Close chat list" : "Open chat list",
                variant: "secondary",
                glassy: !0,
                className: "!opacity-100 z-10 size-8 cursor-pointer rounded-full p-1 shadow-md backdrop-blur-lg hover:bg-white/60 active:bg-zinc-50/60 disabled:bg-transparent disabled:shadow-none disabled:*:stroke-zinc-500/50",
                onClick: () => setChatListOpen(!chatListOpen),
                disabled: isWorking,
                children: chatListOpen ? /* @__PURE__ */ jsx(X, { className: "size-4 stroke-2" }) : /* @__PURE__ */ jsx(AlignJustify, { className: "size-4 stroke-2" })
              }
            ) }),
            /* @__PURE__ */ jsx(TooltipContent, { children: chatListOpen ? "Close chat list" : "Open chat list" })
          ] }),
          showNewChatButton && /* @__PURE__ */ jsxs(Tooltip, { children: [
            /* @__PURE__ */ jsx(TooltipTrigger, { children: /* @__PURE__ */ jsxs(
              Button,
              {
                "aria-label": "New chat",
                variant: "secondary",
                glassy: !0,
                className: cn(
                  "!opacity-100 z-10 size-8 cursor-pointer rounded-full p-1 shadow-md backdrop-blur-lg transition-all duration-150 ease-out hover:bg-white/60 active:bg-zinc-50/60 disabled:bg-transparent disabled:shadow-none disabled:*:stroke-zinc-500/50",
                  chatListOpen && "w-fit px-2.5"
                ),
                disabled: isWorking,
                onClick: createChat,
                children: [
                  chatListOpen && /* @__PURE__ */ jsx("span", { className: "mr-1", children: "New chat" }),
                  /* @__PURE__ */ jsx(Plus, { className: "size-4 stroke-2" })
                ]
              }
            ) }),
            /* @__PURE__ */ jsx(TooltipContent, { children: "New chat" })
          ] })
        ] }),
        chatListOpen && /* @__PURE__ */ jsx("div", { className: "mask-alpha mask-[linear-gradient(to_bottom,transparent_0px,black_16px,black_calc(100%-16px),transparent_100%)] scrollbar-thin scrollbar-thumb-black/10 scrollbar-track-transparent absolute top-16 right-4 bottom-4 left-4 overflow-hidden overflow-y-auto rounded-md py-4", children: /* @__PURE__ */ jsx(ChatList, { onClose: () => setChatListOpen(!1) }) })
      ] })
    }
  );
}
function ChatPanel() {
  const chatState = useChatState(), [isDragging, setIsDragging] = useState(!1), { activeChatId, isWorking, chats } = useKartonState(
    useComparingSelector((s2) => ({
      activeChatId: s2.activeChatId,
      isWorking: s2.isWorking,
      chats: s2.chats
    }))
  ), isConnected = useKartonConnected(), activeChat = useMemo(() => activeChatId ? chats[activeChatId] ?? null : null, [activeChatId, chats]), enableInputField = useMemo(() => isConnected ? !isWorking : !1, [isWorking, isConnected]), anyMessageInChat = useMemo(() => {
    var _a;
    return ((_a = activeChat == null ? void 0 : activeChat.messages) == null ? void 0 : _a.length) > 0;
  }, [activeChat == null ? void 0 : activeChat.messages]), inputRef = useRef(null), focusIntervalRef = useRef(null), shouldMaintainFocusRef = useRef(!1);
  useEffect(() => {
    enableInputField && chatState.startPromptCreation();
  }, []), useEffect(() => {
    var _a;
    return chatState.isPromptCreationActive && enableInputField ? (shouldMaintainFocusRef.current = !0, setTimeout(() => {
      var _a2;
      (_a2 = inputRef.current) == null || _a2.focus();
    }, 0), focusIntervalRef.current = setInterval(() => {
      var _a2;
      if (shouldMaintainFocusRef.current && chatState.isPromptCreationActive) {
        const activeElement2 = document.activeElement, inputElement = inputRef.current;
        inputElement && activeElement2 !== inputElement && ((_a2 = footerRef.current) != null && _a2.contains(
          activeElement2
        ) || inputElement.focus());
      }
    }, 100)) : (shouldMaintainFocusRef.current = !1, focusIntervalRef.current && (clearInterval(focusIntervalRef.current), focusIntervalRef.current = null), (_a = inputRef.current) == null || _a.blur()), () => {
      focusIntervalRef.current && (clearInterval(focusIntervalRef.current), focusIntervalRef.current = null);
    };
  }, [chatState.isPromptCreationActive, enableInputField]);
  const footerRef = useRef(null), chatHistoryRef = useRef(null), panelRef = useRef(null), handleDragEnter = useCallback((e2) => {
    e2.preventDefault(), e2.stopPropagation(), e2.dataTransfer.items && e2.dataTransfer.items.length > 0 && setIsDragging(!0);
  }, []), handleDragLeave = useCallback((e2) => {
    var _a;
    e2.preventDefault(), e2.stopPropagation();
    const relatedTarget = e2.relatedTarget;
    (_a = panelRef.current) != null && _a.contains(relatedTarget) || setIsDragging(!1);
  }, []), handleDragOver = useCallback((e2) => {
    e2.preventDefault(), e2.stopPropagation();
  }, []), handleDrop = useCallback(
    (e2) => {
      e2.preventDefault(), e2.stopPropagation(), setIsDragging(!1), Array.from(e2.dataTransfer.files).forEach((file) => {
        chatState.addFileAttachment(file);
      }), !chatState.isPromptCreationActive && enableInputField && chatState.startPromptCreation();
    },
    [chatState, enableInputField]
  );
  return useEffect(() => {
    const handleClick = (e2) => {
      if (!chatState.isPromptCreationActive) return;
      const target = e2.target;
      footerRef.current && !footerRef.current.contains(target) && (shouldMaintainFocusRef.current = !1, chatState.stopPromptCreation());
    }, handleDocumentClick = (e2) => {
      if (!chatState.isPromptCreationActive) return;
      const target = e2.target;
      (target.id === "user-app-iframe" || target.tagName === "IFRAME") && setTimeout(() => {
        var _a;
        chatState.isPromptCreationActive && shouldMaintainFocusRef.current && ((_a = inputRef.current) == null || _a.focus());
      }, 50);
    };
    return panelRef.current && chatState.isPromptCreationActive && (panelRef.current.addEventListener("click", handleClick), document.addEventListener("click", handleDocumentClick, !0)), () => {
      var _a;
      (_a = panelRef.current) == null || _a.removeEventListener("click", handleClick), document.removeEventListener("click", handleDocumentClick, !0);
    };
  }, [chatState.isPromptCreationActive, chatState.stopPromptCreation]), useEffect(() => {
    if (chatHistoryRef.current && footerRef.current) {
      const resizeObserver = new ResizeObserver(() => {
        const heightDifference = Number.parseInt(
          window.getComputedStyle(footerRef.current).getPropertyValue("padding-bottom")
        ) - chatHistoryRef.current.clientHeight;
        chatHistoryRef.current.style.paddingBottom = `${footerRef.current.clientHeight}px`, chatHistoryRef.current.scrollTop -= heightDifference;
      });
      return resizeObserver.observe(footerRef.current), () => {
        resizeObserver.disconnect();
      };
    }
  }, [chatHistoryRef.current]), /* @__PURE__ */ jsx(
    Panel,
    {
      ref: panelRef,
      className: cn(
        anyMessageInChat ? "h-[35vh] max-h-[50vh] min-h-[20vh]" : "!h-auto min-h-0",
        isDragging && "ring-1 ring-blue-500/50"
      ),
      children: /* @__PURE__ */ jsxs(
        "div",
        {
          className: "relative flex size-full flex-col rounded-3xl bg-transparent",
          onDragEnter: handleDragEnter,
          onDragLeave: handleDragLeave,
          onDragOver: handleDragOver,
          onDrop: handleDrop,
          role: "region",
          "aria-label": "Chat panel drop zone",
          children: [
            /* @__PURE__ */ jsx(ChatPanelHeader, {}),
            /* @__PURE__ */ jsx(
              PanelContent,
              {
                className: cn(
                  "block px-1 py-0",
                  "h-full max-h-96 min-h-64",
                  "mask-alpha mask-[linear-gradient(to_bottom,transparent_0px,black_48px,black_calc(95%_-_16px),transparent_calc(100%_-_16px))]",
                  "overflow-hidden rounded-[inherit]"
                ),
                children: /* @__PURE__ */ jsx(ChatHistory, { ref: chatHistoryRef })
              }
            ),
            /* @__PURE__ */ jsx(ChatPanelFooter, { ref: footerRef, inputRef }),
            isDragging && /* @__PURE__ */ jsx("div", { className: "pointer-events-none absolute inset-0 z-50 flex items-center justify-center rounded-3xl bg-blue-500/10 backdrop-blur-[1px]" })
          ]
        }
      )
    }
  );
}
function AgentConnectivityPanel() {
  const isConnected = useKartonConnected();
  return /* @__PURE__ */ jsxs(
    Panel,
    {
      className: "[--color-foreground:var(--color-orange-700)] [--color-muted-foreground:var(--color-orange-700)] before:bg-orange-50/80",
      children: [
        /* @__PURE__ */ jsx(
          PanelHeader,
          {
            title: "CLI disconnected",
            actionArea: /* @__PURE__ */ jsx(WifiOff, { className: "size-6" })
          }
        ),
        /* @__PURE__ */ jsx(PanelContent, { children: /* @__PURE__ */ jsxs("div", { className: "space-y-3", children: [
          /* @__PURE__ */ jsx("p", { className: "text-muted-foreground text-sm", children: isConnected ? "Establishing connection to the Stagewise CLI..." : "The connection to the Stagewise CLI has been lost. The toolbar is attempting to reconnect automatically." }),
          /* @__PURE__ */ jsx("p", { className: "text-muted-foreground text-sm", children: "Please ensure that:" }),
          /* @__PURE__ */ jsxs("ul", { className: "list-inside list-disc space-y-1 text-muted-foreground text-sm", children: [
            /* @__PURE__ */ jsx("li", { children: "The CLI application is still running" }),
            /* @__PURE__ */ jsx("li", { children: "The development server hasn't crashed" }),
            /* @__PURE__ */ jsx("li", { children: "Your network connection is stable" })
          ] }),
          /* @__PURE__ */ jsx("p", { className: "text-muted-foreground text-sm", children: "If the problem persists, try restarting the CLI application." })
        ] }) }),
        /* @__PURE__ */ jsx(PanelFooter, { children: /* @__PURE__ */ jsxs(DropdownMenu, { children: [
          /* @__PURE__ */ jsx(DropdownMenuButton, { children: /* @__PURE__ */ jsxs(Button, { glassy: !0, size: "sm", variant: "secondary", children: [
            /* @__PURE__ */ jsx(MessageCircleQuestionMark, { className: "mr-2 size-4" }),
            "Need help?"
          ] }) }),
          /* @__PURE__ */ jsxs(DropdownMenuContent, { children: [
            /* @__PURE__ */ jsx(
              DropdownMenuLinkItem,
              {
                href: "https://stagewise.io/docs",
                target: "_blank",
                children: "Read the docs"
              }
            ),
            /* @__PURE__ */ jsx(
              DropdownMenuLinkItem,
              {
                href: "https://discord.gg/gkdGsDYaKA",
                target: "_blank",
                children: "Ask the community"
              }
            )
          ] })
        ] }) })
      ]
    }
  );
}
const flappyGame = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy stage</title>
    <style>
        /* Basic reset and page styling */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            overflow: hidden;
        }
        /* Canvas styling to maintain a portrait 9:16 aspect ratio */
        canvas {
            background-color: #70c5ce;
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <!-- The canvas element where the game will be rendered -->
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set a base resolution for the game
        const gameWidth = 500;
        const gameHeight = 750;
        canvas.width = gameWidth;
        canvas.height = gameHeight;

        // --- SVG Bird Character ---
        const birdImage = new Image();
        // The user-provided SVG, formatted as a data URI
        const svgString = \`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 2048 2048" fill="white"><ellipse id="path1" ry="624" rx="624" cy="1024" cx="1024" stroke="black" stroke-width="100px" /><ellipse id="path2" ry="160" rx="160" cy="1024" cx="1450" fill="black" /><path id="path3" fill="black" d="M 1024 0 A 1024 1024 0 0 0 0 1024 A 1024 1024 0 0 0 1024 2048 L 1736 2048 L 1848 2048 C 1958.7998 2048 2048 1958.7998 2048 1848 L 2048 1736 L 2048 1024 A 1024 1024 0 0 0 1024 0 z M 1024.9414 200 A 824 824 0 0 1 1848.9414 1024 A 824 824 0 0 1 1024.9414 1848 A 824 824 0 0 1 200.94141 1024 A 824 824 0 0 1 1024.9414 200 z " /></svg>\`;
        birdImage.src = 'data:image/svg+xml,' + encodeURIComponent(svgString.replace(/\\s+/g, ' ').trim());


        // --- Game State and Variables ---
        let bird, pipes, clouds, score, isGameOver, frameCount, currentSpeed;
        let hasStarted; 
        let gameOverTimeout; 

        // --- Game Constants ---
        const BIRD_PROPS = {
            x: 60,
            y: 250,
            radius: 18, // Slightly increased radius to better fit the new character
            gravity: 0.3, 
            lift: -7,   
            velocity: 0
        };

        const PIPE_PROPS = {
            width: 60,
            capWidth: 70, 
            capHeight: 25, 
            gap: 160,
            speed: 2, // Initial speed
        };
        
        const SPAWN_DISTANCE = 220;
        const FLOOR_HEIGHT = 50;
        const CLOUD_SPEED = 0.5;

        // --- Game Initialization ---
        function initializeGame() {
            bird = { ...BIRD_PROPS };
            pipes = [];
            score = 0;
            isGameOver = false;
            hasStarted = false; 
            frameCount = 0;
            currentSpeed = PIPE_PROPS.speed;
            
            if (!clouds || clouds.length === 0) {
                clouds = [];
                for (let i = 0; i < 5; i++) {
                    clouds.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * (canvas.height / 2),
                        radius: Math.random() * 20 + 20
                    });
                }
            }
        }

        // --- Drawing Functions ---

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
            clouds.forEach(cloud => {
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.radius * 0.8, cloud.y, cloud.radius * 1.2, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.radius * 0.8, cloud.y, cloud.radius * 1.1, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPipes() {
            pipes.forEach(pipe => {
                ctx.fillStyle = '#73bf2e';
                ctx.strokeStyle = '#4f8220';
                ctx.lineWidth = 4;

                ctx.fillRect(pipe.x, 0, PIPE_PROPS.width, pipe.topHeight);
                ctx.strokeRect(pipe.x, 0, PIPE_PROPS.width, pipe.topHeight);
                
                const topCapX = pipe.x - (PIPE_PROPS.capWidth - PIPE_PROPS.width) / 2;
                ctx.fillRect(topCapX, pipe.topHeight - PIPE_PROPS.capHeight, PIPE_PROPS.capWidth, PIPE_PROPS.capHeight);
                ctx.strokeRect(topCapX, pipe.topHeight - PIPE_PROPS.capHeight, PIPE_PROPS.capWidth, PIPE_PROPS.capHeight);

                ctx.fillRect(pipe.x, pipe.bottomY, PIPE_PROPS.width, canvas.height - pipe.bottomY - FLOOR_HEIGHT);
                ctx.strokeRect(pipe.x, pipe.bottomY, PIPE_PROPS.width, canvas.height - pipe.bottomY - FLOOR_HEIGHT);

                const bottomCapX = pipe.x - (PIPE_PROPS.capWidth - PIPE_PROPS.width) / 2;
                ctx.fillRect(bottomCapX, pipe.bottomY, PIPE_PROPS.capWidth, PIPE_PROPS.capHeight);
                ctx.strokeRect(bottomCapX, pipe.bottomY, PIPE_PROPS.capWidth, PIPE_PROPS.capHeight);
            });
        }

        function drawFloor() {
            ctx.fillStyle = '#4a7f2a'; 
            ctx.strokeStyle = '#3b6221';
            ctx.lineWidth = 4;
            ctx.fillRect(0, canvas.height - FLOOR_HEIGHT, canvas.width, FLOOR_HEIGHT);
            ctx.strokeRect(0, canvas.height - FLOOR_HEIGHT, canvas.width, FLOOR_HEIGHT);
        }

        function drawBird() {
            ctx.save();
            ctx.translate(bird.x, bird.y);

            if (hasStarted) {
                const maxRotation = Math.PI / 2; 
                const minRotation = -Math.PI / 6; 
                const rotation = Math.max(minRotation, Math.min(maxRotation, bird.velocity * 0.08));
                ctx.rotate(rotation);
            }

            // Draw the SVG image, centered on the bird's new origin
            ctx.drawImage(birdImage, -bird.radius, -bird.radius, bird.radius * 2, bird.radius * 2);

            ctx.restore();
        }

        // --- Update Functions ---

        function updateClouds() {
            clouds.forEach(cloud => {
                cloud.x -= CLOUD_SPEED;
            });

            if (frameCount % 200 === 0) {
                 clouds.push({
                    x: canvas.width + 50,
                    y: Math.random() * (canvas.height / 2),
                    radius: Math.random() * 20 + 20
                });
            }

            clouds = clouds.filter(cloud => cloud.x + cloud.radius * 2 > 0);
        }

        function updateBird() {
            bird.velocity += bird.gravity;
            bird.y += bird.velocity;

            if (bird.y - bird.radius < 0) {
                bird.y = bird.radius;
                bird.velocity = 0;
            }

            if (bird.y + bird.radius > canvas.height - FLOOR_HEIGHT) {
                endGame();
            }
        }

        function flap() {
            if (isGameOver) {
                clearTimeout(gameOverTimeout);
                initializeGame();
                return;
            }

            if (!hasStarted) {
                hasStarted = true;
            }
            
            bird.velocity = bird.lift;
        }

        function updatePipes() {
            if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - SPAWN_DISTANCE) {
                const topHeight = Math.random() * (canvas.height - PIPE_PROPS.gap - 200 - FLOOR_HEIGHT) + 100;
                pipes.push({
                    x: canvas.width,
                    topHeight: topHeight,
                    bottomY: topHeight + PIPE_PROPS.gap,
                    passed: false
                });
            }

            pipes.forEach(pipe => {
                pipe.x -= currentSpeed;
                if (!pipe.passed && pipe.x + PIPE_PROPS.width < bird.x) {
                    score++;
                    pipe.passed = true;
                }
            });

            pipes = pipes.filter(pipe => pipe.x + PIPE_PROPS.capWidth > 0);
        }

        // --- Collision and Game State ---
        function checkCollisions() {
            for (let pipe of pipes) {
                const capX = pipe.x - (PIPE_PROPS.capWidth - PIPE_PROPS.width) / 2;
                const capWidth = PIPE_PROPS.capWidth;

                if (bird.x + bird.radius > capX && bird.x - bird.radius < capX + capWidth) {
                    if (bird.y - bird.radius < pipe.topHeight || bird.y + bird.radius > pipe.bottomY) {
                        endGame();
                        return;
                    }
                }
            }
        }

        function endGame() {
            if (!isGameOver) {
                isGameOver = true;
                gameOverTimeout = setTimeout(initializeGame, 3000);
            }
        }

        // --- Main Game Loop ---
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!isGameOver) {
                if (hasStarted) {
                    updateBird();
                    updatePipes();
                    checkCollisions();
                    currentSpeed += 0.001;
                }
                updateClouds();
                frameCount++;
            }

            drawClouds();
            if(hasStarted || isGameOver) {
                drawPipes();
            }
            drawFloor();
            drawBird();
            
            if (!isGameOver) {
                if (hasStarted) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 45px sans-serif';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 5;
                    ctx.textAlign = 'center';
                    ctx.strokeText(score, canvas.width / 2, 60);
                    ctx.fillText(score, canvas.width / 2, 60);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 30px sans-serif';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 4;
                    ctx.textAlign = 'center';
                    ctx.strokeText('Tap to Start', canvas.width / 2, canvas.height / 2);
                    ctx.fillText('Tap to Start', canvas.width / 2, canvas.height / 2);
                }
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 50px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 40);
                ctx.font = 'bold 30px sans-serif';
                ctx.fillText(\`Score: \${score}\`, canvas.width / 2, canvas.height / 2 + 20);
            }

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') flap();
        });
        window.addEventListener('mousedown', flap);
        window.addEventListener('touchstart', (e) => {
            e.preventDefault();
            flap();
        }, { passive: false });

        // --- Start the game ---
        initializeGame();
        gameLoop();
    <\/script>
</body>
</html>
`;
function EddyModePanel() {
  return /* @__PURE__ */ jsx(Panel, { children: /* @__PURE__ */ jsx(PanelContent, { className: "flex items-center justify-center", children: /* @__PURE__ */ jsx(
    "iframe",
    {
      srcDoc: flappyGame,
      title: "Flappy Game",
      className: "aspect-[1/1.5] max-h-[50vh] w-3/4 rounded-2xl ring-2 ring-black"
    }
  ) }) });
}
const TOOLBAR_POSITION_KEY = "stagewise_toolbar_toolbar_position";
function getStoredToolbarPosition() {
  try {
    const stored = localStorage.getItem(TOOLBAR_POSITION_KEY);
    if (stored)
      return stored;
  } catch (error2) {
    console.warn("Failed to load toolbar position from localStorage:", error2);
  }
  return null;
}
function saveToolbarPosition(position2) {
  try {
    position2 && localStorage.setItem(TOOLBAR_POSITION_KEY, position2);
  } catch (error2) {
    console.warn("Failed to save toolbar position to localStorage:", error2);
  }
}
function DefaultLayout() {
  return /* @__PURE__ */ jsx(ContextChipHoverProvider, { children: /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "root pointer-events-none fixed inset-0 h-screen w-screen"
      ),
      children: [
        /* @__PURE__ */ jsx(DOMContextSelector, {}),
        /* @__PURE__ */ jsx(DraggingArea, {})
      ]
    }
  ) });
}
function DraggingArea() {
  const containerRef = useRef(null), [isDragging, setIsDragging] = useState(!1);
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: cn(
        "absolute z-50 size-full transition-all duration-150 ease-out",
        isDragging ? "pointer-events-auto bg-black/10 backdrop-blur-[2px]" : ""
      ),
      children: /* @__PURE__ */ jsx("div", { className: "absolute inset-4", ref: containerRef, children: /* @__PURE__ */ jsx(
        DraggableProvider,
        {
          containerRef,
          snapAreas: {
            topLeft: !0,
            topRight: !0,
            bottomLeft: !0,
            bottomRight: !0,
            topCenter: !1,
            bottomCenter: !1
          },
          onDragStart: () => setIsDragging(!0),
          onDragEnd: () => setIsDragging(!1),
          children: /* @__PURE__ */ jsx(ToolbarAndPanelArea, {})
        }
      ) })
    }
  );
}
function ToolbarAndPanelArea() {
  const onNewSnapArea = useCallback(
    (snapArea) => {
      saveToolbarPosition(snapArea);
    },
    []
  ), initialSnapArea = useMemo(() => getStoredToolbarPosition() || "bottomRight", []), draggable = useDraggable({
    startThreshold: 5,
    initialSnapArea,
    onDragEnd: onNewSnapArea
  }), clickHandleRef = useRef(null);
  return useEffect(() => {
    const listener = (e2) => {
      if (draggable.wasDragged) {
        e2.preventDefault(), e2.stopPropagation();
        return;
      }
    };
    return window.addEventListener("click", listener, { capture: !0 }), () => {
      window.removeEventListener("click", listener, { capture: !0 });
    };
  }, [draggable]), /* @__PURE__ */ jsxs("div", { className: "absolute inset-0 z-50 size-full", children: [
    /* @__PURE__ */ jsx(
      Toolbar,
      {
        draggableHandleRef: (ref) => {
          draggable.handleRef(ref), draggable.draggableRef(ref), clickHandleRef.current = ref;
        },
        isDragged: draggable.isDragging,
        position: draggable.position
      }
    ),
    /* @__PURE__ */ jsx(
      PanelsArea,
      {
        position: draggable.position,
        isToolbarDragged: draggable.isDragging
      }
    )
  ] });
}
function PanelsArea({
  position: position2,
  isToolbarDragged
}) {
  const {
    isChatOpen,
    isSettingsOpen,
    isAgentConnectivityOpen,
    openPluginName,
    isEddyModeOpen
  } = usePanels(), plugins = usePlugins(), pluginPanel = useMemo(() => {
    if (!openPluginName)
      return null;
    const plugin = plugins.plugins.find(
      (plugin2) => plugin2.pluginName === openPluginName
    );
    if (!plugin)
      return null;
    const panelResult = plugin.onActionClick();
    return panelResult || null;
  }, [openPluginName, plugins]);
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "absolute z-0 flex h-full w-96 max-w-[calc(100%-48px)] transition-all duration-500 ease-spring",
        position2.isLeftHalf ? "left-12" : "right-12",
        position2.isTopHalf ? "top-0 flex-col" : "bottom-0 flex-col-reverse",
        isToolbarDragged ? "scale-95 opacity-50 blur-md brightness-90" : "opacity-100"
      ),
      children: [
        /* @__PURE__ */ jsx(PanelWrapper, { position: position2, isOpen: isChatOpen, children: /* @__PURE__ */ jsx(ChatPanel, {}) }),
        /* @__PURE__ */ jsx(PanelWrapper, { position: position2, isOpen: isEddyModeOpen, children: /* @__PURE__ */ jsx(EddyModePanel, {}) }),
        /* @__PURE__ */ jsx(PanelWrapper, { position: position2, isOpen: isSettingsOpen, children: /* @__PURE__ */ jsx(SettingsPanel, {}) }),
        /* @__PURE__ */ jsx(PanelWrapper, { position: position2, isOpen: isAgentConnectivityOpen, children: /* @__PURE__ */ jsx(AgentConnectivityPanel, {}) }),
        /* @__PURE__ */ jsx(PanelWrapper, { position: position2, isOpen: !!pluginPanel, children: pluginPanel })
      ]
    }
  );
}
function PanelWrapper({
  children,
  position: position2,
  isOpen
}) {
  const [shouldRender, setShouldRender] = useState(isOpen), stopRenderTimeoutRef = useRef(null), isAgentPanel = children && typeof children == "object" && "type" in children && typeof children.type == "function" && children.type.name === "AgentConnectivityPanel";
  return useEffect(() => {
    isAgentPanel && console.debug("[PanelWrapper] AgentConnectivityPanel isOpen changed:", {
      isOpen,
      shouldRender,
      hasTimeout: !!stopRenderTimeoutRef.current
    }), isOpen ? (isAgentPanel && console.debug(
      "[PanelWrapper] AgentConnectivityPanel setting shouldRender to true immediately"
    ), setShouldRender(!0), stopRenderTimeoutRef.current && (clearTimeout(stopRenderTimeoutRef.current), stopRenderTimeoutRef.current = null)) : stopRenderTimeoutRef.current = setTimeout(() => {
      isAgentPanel && console.debug(
        "[PanelWrapper] AgentConnectivityPanel setting shouldRender to false after timeout"
      ), setShouldRender(!1);
    }, 500);
  }, [isOpen, isAgentPanel]), useEffect(() => () => {
    stopRenderTimeoutRef.current && clearTimeout(stopRenderTimeoutRef.current);
  }, []), /* @__PURE__ */ jsx(
    "div",
    {
      className: cn(
        "h-[calc-size(auto,size)] transition-all duration-150 ease-out",
        position2.isTopHalf ? "mb-3" : "mt-3",
        position2.isLeftHalf ? "origin-left" : "origin-right",
        isOpen ? "" : "mt-0 mb-0 h-0 scale-0 opacity-0 blur-md"
      ),
      children: shouldRender && children
    }
  );
}
function MainAppBlocker() {
  const { isMainAppBlocked } = useAppState();
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: cn(
        "fixed inset-0 h-screen w-screen",
        isMainAppBlocked ? "pointer-events-auto" : "pointer-events-none"
      ),
      role: "button",
      tabIndex: 0
    }
  );
}
function UrlSynchronizer({
  appPort,
  urlSyncConfig
}) {
  const iframeRef = useRef(null), navigationState = useRef({
    isNavigating: !1,
    source: null,
    navigationId: null,
    timestamp: 0
  }), navigationQueue = useRef(Promise.resolve());
  return useEffect(() => {
    var _a;
    const iframe = document.getElementById(
      "user-app-iframe"
    );
    if (!iframe) return;
    iframeRef.current = iframe;
    const generateNavigationId = () => `nav-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`, lockNavigation = (source) => {
      const navId = generateNavigationId();
      return navigationState.current = {
        isNavigating: !0,
        source,
        navigationId: navId,
        timestamp: Date.now()
      }, navId;
    }, unlockNavigation = (navId) => {
      navigationState.current.navigationId === navId && (navigationState.current = {
        isNavigating: !1,
        source: null,
        navigationId: null,
        timestamp: 0
      });
    }, isNavigationLocked = (source) => {
      const state = navigationState.current;
      if (!state.isNavigating || state.source === source) return !1;
      const timeout = (urlSyncConfig == null ? void 0 : urlSyncConfig.navigationTimeout) || 500;
      return Date.now() - state.timestamp > timeout ? (navigationState.current = {
        isNavigating: !1,
        source: null,
        navigationId: null,
        timestamp: 0
      }, !1) : !0;
    }, syncParentToIframe = async () => {
      if (isNavigationLocked("parent")) return;
      const iframeWindow = iframe.contentWindow;
      if (!iframeWindow) return;
      const parentPath = window.location.pathname, parentSearch = window.location.search, parentHash = window.location.hash, newUrl = parentPath + parentSearch + parentHash;
      try {
        if (iframeWindow.location.href === "about:blank")
          return;
        if (iframeWindow.location.pathname + iframeWindow.location.search + iframeWindow.location.hash !== newUrl) {
          const navId = lockNavigation("parent");
          navigationQueue.current = navigationQueue.current.then(async () => {
            var _a2;
            try {
              (_a2 = iframeWindow.history) != null && _a2.replaceState ? iframeWindow.history.replaceState(null, "", newUrl) : iframeWindow.location.href = newUrl, await new Promise((resolve) => setTimeout(resolve, 150));
            } finally {
              unlockNavigation(navId);
            }
          }), await navigationQueue.current;
        }
      } catch (e2) {
        e2 instanceof DOMException && e2.name === "SecurityError" ? console.warn("Cannot sync to cross-origin iframe:", newUrl) : console.error("Failed to sync URL to iframe:", e2);
      }
    }, syncIframeToParent = async () => {
      if (console.debug("syncIframeToParent called"), isNavigationLocked("iframe")) {
        console.debug("Navigation locked by iframe, skipping sync");
        return;
      }
      const iframeWindow = iframe.contentWindow;
      if (!iframeWindow) {
        console.debug("No iframe contentWindow");
        return;
      }
      try {
        const iframePath = iframeWindow.location.pathname, iframeSearch = iframeWindow.location.search, iframeHash = iframeWindow.location.hash, newUrl = iframePath + iframeSearch + iframeHash, currentParentUrl = window.location.pathname + window.location.search + window.location.hash;
        if (console.debug("Comparing URLs:", { currentParentUrl, newUrl }), currentParentUrl !== newUrl) {
          console.debug("URLs differ, syncing parent to:", newUrl);
          const navId = lockNavigation("iframe");
          navigationQueue.current = navigationQueue.current.then(async () => {
            try {
              window.history.replaceState(null, "", newUrl), console.debug("Parent URL updated to:", newUrl), await new Promise((resolve) => setTimeout(resolve, 50));
            } finally {
              unlockNavigation(navId);
            }
          }), await navigationQueue.current;
        } else
          console.debug("URLs already in sync");
      } catch (e2) {
        e2 instanceof DOMException && e2.name === "SecurityError" ? console.warn("Cannot read cross-origin iframe URL") : console.error("Failed to sync URL from iframe:", e2);
      }
    }, handleIframeLoad = () => {
      syncParentToIframe();
      const shouldPatchLocation = (urlSyncConfig == null ? void 0 : urlSyncConfig.enableLocationPatching) !== !1;
      if (appPort && shouldPatchLocation)
        try {
          monkeyPatchLocation(iframe.contentWindow, appPort);
        } catch (e2) {
          console.warn("Failed to patch iframe location object:", e2);
        }
    }, handlePopState = () => {
      syncParentToIframe();
    }, debounce = (func, wait) => {
      let timeout;
      return (...args) => {
        clearTimeout(timeout), timeout = setTimeout(() => func(...args), wait);
      };
    };
    let lastIframeUrl = ((_a = iframe.contentWindow) == null ? void 0 : _a.location.href) || "";
    const checkIframeNavigation = debounce(() => {
      var _a2;
      try {
        const currentUrl = (_a2 = iframe.contentWindow) == null ? void 0 : _a2.location.href;
        currentUrl && currentUrl !== lastIframeUrl && (console.debug(
          "Iframe navigation detected:",
          lastIframeUrl,
          "->",
          currentUrl
        ), lastIframeUrl = currentUrl, syncIframeToParent());
      } catch (e2) {
        e2 instanceof DOMException && e2.name === "SecurityError" && console.warn(
          "Cross-origin navigation detected, synchronization paused"
        );
      }
    }, (urlSyncConfig == null ? void 0 : urlSyncConfig.debounceDelay) || 50);
    iframe.addEventListener("load", handleIframeLoad), window.addEventListener("popstate", handlePopState);
    const setupIframeNavigationListeners = () => {
      try {
        const iframeWindow = iframe.contentWindow;
        if (!iframeWindow) return;
        iframeWindow.addEventListener("hashchange", () => {
          console.debug("Iframe hashchange detected"), checkIframeNavigation();
        }), iframeWindow.addEventListener("popstate", () => {
          console.debug("Iframe popstate detected"), checkIframeNavigation();
        });
        const originalPushState = iframeWindow.history.pushState, originalReplaceState = iframeWindow.history.replaceState;
        iframeWindow.history.pushState = function(...args) {
          const result = originalPushState.apply(this, args);
          return console.debug("Iframe pushState detected"), checkIframeNavigation(), result;
        }, iframeWindow.history.replaceState = function(...args) {
          const result = originalReplaceState.apply(this, args);
          return console.debug("Iframe replaceState detected"), checkIframeNavigation(), result;
        };
      } catch (e2) {
        console.debug("Failed to setup iframe navigation listeners:", e2);
      }
    };
    iframe.addEventListener("load", setupIframeNavigationListeners);
    let cleanupNavMonitoring = null;
    try {
      if (iframe.contentWindow && iframe.contentDocument) {
        const MutationObserverConstructor = window.MutationObserver || window.WebKitMutationObserver;
        if (MutationObserverConstructor) {
          const observer = new MutationObserverConstructor(() => {
            checkIframeNavigation();
          });
          observer.observe(iframe.contentDocument.documentElement, {
            childList: !0,
            subtree: !0,
            attributes: !0,
            attributeFilter: ["href"]
          }), cleanupNavMonitoring = () => observer.disconnect();
        }
      }
    } catch (e2) {
      console.debug("MutationObserver setup failed, using polling:", e2);
    }
    const intervalId = cleanupNavMonitoring ? null : setInterval(checkIframeNavigation, 100);
    return iframe.contentWindow && (handleIframeLoad(), setupIframeNavigationListeners()), () => {
      iframe.removeEventListener("load", handleIframeLoad), iframe.removeEventListener("load", setupIframeNavigationListeners), window.removeEventListener("popstate", handlePopState), intervalId && clearInterval(intervalId), cleanupNavMonitoring && cleanupNavMonitoring();
    };
  }, [appPort, urlSyncConfig]), null;
}
function monkeyPatchLocation(iframeWindow, appPort) {
  try {
    const originalLocation = iframeWindow.location, descriptor = Object.getOwnPropertyDescriptor(
      iframeWindow,
      "location"
    );
    if (!descriptor || descriptor.configurable === !1) {
      patchLocationProperties(iframeWindow, appPort);
      return;
    }
    const locationProxy = new Proxy(originalLocation, {
      get(target, prop) {
        if (prop === "port")
          return String(appPort);
        if (prop === "host")
          return `${target.hostname}:${appPort}`;
        if (prop === "origin")
          return `${target.protocol}//${target.hostname}:${appPort}`;
        if (prop === "href") {
          const url = new URL(target.href);
          return url.port = String(appPort), url.toString();
        }
        return target[prop];
      }
    });
    Object.defineProperty(iframeWindow, "location", {
      get() {
        return locationProxy;
      },
      configurable: !0
    });
  } catch (e2) {
    console.error("Failed to monkey-patch location:", e2), patchLocationProperties(iframeWindow, appPort);
  }
}
function patchLocationProperties(iframeWindow, appPort) {
  try {
    const originalLocation = iframeWindow.location, createGetter = (originalGetter, modifier) => function() {
      const value = originalGetter.call(this);
      return modifier(value);
    };
    Object.defineProperty(originalLocation, "port", {
      get: () => String(appPort),
      configurable: !0
    });
    const originalHostDescriptor = Object.getOwnPropertyDescriptor(
      originalLocation,
      "host"
    );
    originalHostDescriptor != null && originalHostDescriptor.get && Object.defineProperty(originalLocation, "host", {
      get: createGetter(
        originalHostDescriptor.get,
        () => `${originalLocation.hostname}:${appPort}`
      ),
      configurable: !0
    });
    const originalOriginDescriptor = Object.getOwnPropertyDescriptor(
      originalLocation,
      "origin"
    );
    originalOriginDescriptor != null && originalOriginDescriptor.get && Object.defineProperty(originalLocation, "origin", {
      get: createGetter(
        originalOriginDescriptor.get,
        () => `${originalLocation.protocol}//${originalLocation.hostname}:${appPort}`
      ),
      configurable: !0
    });
    const originalHrefDescriptor = Object.getOwnPropertyDescriptor(
      originalLocation,
      "href"
    );
    originalHrefDescriptor != null && originalHrefDescriptor.get && Object.defineProperty(originalLocation, "href", {
      get: createGetter(originalHrefDescriptor.get, (href) => {
        const url = new URL(href);
        return url.port = String(appPort), url.toString();
      }),
      configurable: !0
    });
  } catch (e2) {
    console.error("Failed to patch location properties:", e2);
  }
}
function useMetaSync() {
  const syncedElementsRef = useRef(/* @__PURE__ */ new Set()), observerRef = useRef(null);
  useEffect(() => {
    var _a;
    const iframe = document.getElementById(
      "user-app-iframe"
    );
    if (!iframe) return;
    const syncMetaElements = () => {
      try {
        const iframeWindow = iframe.contentWindow, iframeDocument = iframe.contentDocument;
        if (!iframeWindow || !iframeDocument) return;
        const metaElements = [], iframeTitle = iframeDocument.title;
        iframeTitle && (document.title = iframeTitle), iframeDocument.querySelectorAll(
          'link[rel="icon"], link[rel="shortcut icon"], link[rel="apple-touch-icon"]'
        ).forEach((link2) => {
          var _a2;
          const linkEl = link2;
          metaElements.push({
            tag: "link",
            attributes: {
              rel: linkEl.rel,
              href: linkEl.href,
              type: linkEl.type || "",
              sizes: ((_a2 = linkEl.sizes) == null ? void 0 : _a2.toString()) || ""
            }
          });
        }), iframeDocument.querySelectorAll(
          'meta[property^="og:"], meta[property^="article:"], meta[property^="book:"], meta[property^="profile:"], meta[property^="video:"], meta[property^="music:"]'
        ).forEach((meta) => {
          const metaEl = meta;
          metaElements.push({
            tag: "meta",
            attributes: {
              property: metaEl.getAttribute("property") || "",
              content: metaEl.content
            }
          });
        }), iframeDocument.querySelectorAll(
          'meta[name^="twitter:"]'
        ).forEach((meta) => {
          const metaEl = meta;
          metaElements.push({
            tag: "meta",
            attributes: {
              name: metaEl.name,
              content: metaEl.content
            }
          });
        }), iframeDocument.querySelectorAll(
          'meta[name="description"], meta[name="keywords"], meta[name="author"]'
        ).forEach((meta) => {
          const metaEl = meta, attributes = {};
          metaEl.name && (attributes.name = metaEl.name), metaEl.content && (attributes.content = metaEl.content), metaElements.push({
            tag: "meta",
            attributes
          });
        });
        const canonicalLink = iframeDocument.querySelector(
          'link[rel="canonical"]'
        );
        if (canonicalLink) {
          const linkEl = canonicalLink;
          metaElements.push({
            tag: "link",
            attributes: {
              rel: "canonical",
              href: linkEl.href
            }
          });
        }
        syncedElementsRef.current.forEach((element2) => {
          element2.remove();
        }), syncedElementsRef.current.clear();
        const fragment = document.createDocumentFragment();
        metaElements.forEach((metaInfo) => {
          var _a2;
          if (metaInfo.tag === "meta")
            metaInfo.attributes.property ? document.querySelectorAll(
              `meta[property="${metaInfo.attributes.property}"]`
            ).forEach((el) => {
              syncedElementsRef.current.has(el) || el.remove();
            }) : metaInfo.attributes.name && document.querySelectorAll(
              `meta[name="${metaInfo.attributes.name}"]`
            ).forEach((el) => {
              syncedElementsRef.current.has(el) || el.remove();
            });
          else if (metaInfo.tag === "link") {
            if ((_a2 = metaInfo.attributes.rel) != null && _a2.includes("icon"))
              document.querySelectorAll('link[rel*="icon"]').forEach((el) => {
                syncedElementsRef.current.has(el) || el.remove();
              });
            else if (metaInfo.attributes.rel === "canonical") {
              const existing = document.querySelector('link[rel="canonical"]');
              existing && !syncedElementsRef.current.has(existing) && existing.remove();
            }
          }
          const element2 = document.createElement(metaInfo.tag);
          Object.entries(metaInfo.attributes).forEach(([key, value]) => {
            value && element2.setAttribute(key, value);
          }), fragment.appendChild(element2), syncedElementsRef.current.add(element2);
        }), document.head.appendChild(fragment);
      } catch (e2) {
        e2 instanceof DOMException && e2.name === "SecurityError" ? console.debug("Cannot access cross-origin iframe head") : console.error("Failed to sync meta tags:", e2);
      }
    }, setupObserver = () => {
      try {
        const iframeDocument = iframe.contentDocument;
        if (!iframeDocument) return;
        observerRef.current && observerRef.current.disconnect(), observerRef.current = new MutationObserver((mutations) => {
          mutations.some((mutation) => {
            if (mutation.target === iframeDocument.head || mutation.target.nodeName === "TITLE" || mutation.target.nodeName === "META" || mutation.target.nodeName === "LINK") return !0;
            if (mutation.type === "characterData") {
              const parentNode = mutation.target.parentNode;
              if (parentNode && parentNode.nodeName === "TITLE")
                return !0;
            }
            for (const node2 of mutation.addedNodes)
              if (node2.nodeName === "META" || node2.nodeName === "LINK" || node2.nodeName === "TITLE")
                return !0;
            for (const node2 of mutation.removedNodes)
              if (node2.nodeName === "META" || node2.nodeName === "LINK" || node2.nodeName === "TITLE")
                return !0;
            return !1;
          }) && syncMetaElements();
        }), iframeDocument.head && observerRef.current.observe(iframeDocument.head, {
          childList: !0,
          subtree: !0,
          attributes: !0,
          attributeFilter: [
            "content",
            "href",
            "property",
            "name",
            "rel",
            "sizes",
            "type"
          ],
          characterData: !0
        }), observerRef.current.observe(iframeDocument.documentElement, {
          childList: !0,
          subtree: !1
        }), syncMetaElements();
      } catch (e2) {
        console.debug("Failed to setup meta observer:", e2);
      }
    }, handleIframeLoad = () => {
      setupObserver();
    };
    return iframe.addEventListener("load", handleIframeLoad), ((_a = iframe.contentDocument) == null ? void 0 : _a.readyState) === "complete" && setupObserver(), () => {
      iframe.removeEventListener("load", handleIframeLoad), observerRef.current && observerRef.current.disconnect(), syncedElementsRef.current.forEach((element2) => {
        element2.remove();
      }), syncedElementsRef.current.clear();
    };
  }, []);
}
function MetaSynchronizer() {
  return useMetaSync(), null;
}
function App(config2) {
  const pathname = window.location.pathname || "/", search2 = window.location.search || "", hash = window.location.hash || "", initialUrl = pathname + search2 + hash;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      "iframe",
      {
        src: initialUrl,
        title: "Main user app",
        className: "fixed inset-0 m-0 size-full p-0",
        id: "user-app-iframe"
      }
    ),
    /* @__PURE__ */ jsx(
      UrlSynchronizer,
      {
        appPort: config2 == null ? void 0 : config2.appPort,
        urlSyncConfig: config2 == null ? void 0 : config2.urlSync
      }
    ),
    /* @__PURE__ */ jsx(MetaSynchronizer, {}),
    /* @__PURE__ */ jsxs(AppStateProvider, { children: [
      /* @__PURE__ */ jsx(MainAppBlocker, {}),
      /* @__PURE__ */ jsxs(ContextProviders, { config: config2, children: [
        /* @__PURE__ */ jsx(HotkeyListener, {}),
        /* @__PURE__ */ jsx(DefaultLayout, {})
      ] })
    ] })
  ] });
}
const styleNode = document.createElement("style");
styleNode.textContent = appStyle;
document.head.appendChild(styleNode);
createRoot(document.body).render(
  createElement(StrictMode, null, createElement(App, config))
);
