import { jsxs as c, jsx as a } from "react/jsx-runtime";
function g() {
  return /* @__PURE__ */ c(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 960 960",
      fill: "currentColor",
      stroke: "currentColor",
      children: [
        /* @__PURE__ */ a("title", { children: "Angular Logo" }),
        /* @__PURE__ */ c("g", { children: [
          /* @__PURE__ */ a("polygon", { points: "562.6,109.8 804.1,629.5 829.2,233.1 	" }),
          /* @__PURE__ */ a("polygon", { points: "624.9,655.9 334.3,655.9 297.2,745.8 479.6,849.8 662,745.8 	" }),
          /* @__PURE__ */ a("polygon", { points: "384.1,539.3 575.2,539.3 479.6,307 	" }),
          /* @__PURE__ */ a("polygon", { points: "396.6,109.8 130,233.1 155.1,629.5 	" })
        ] })
      ]
    }
  );
}
function f() {
  const n = document.getElementById(
    "user-app-iframe"
  );
  return n ? n.contentWindow : null;
}
function d(n) {
  const e = {};
  for (const t of Object.getOwnPropertyNames(n))
    e[t] = n[t];
  return e;
}
function h(n) {
  const e = d(n);
  return u(e, n);
}
function w(n) {
  return u(n.ownProperties, null);
}
function u(n, e) {
  const t = f();
  if (!t || !t.ng || !t.ng.getComponent)
    return [];
  const o = [];
  let r = e;
  const s = 3;
  if (r)
    for (; r && o.length < s; ) {
      try {
        const l = t.ng.getComponent(r);
        if (l) {
          let i = l.constructor.name;
          i.startsWith("_") && (i = i.substring(1)), i && i !== "Object" && (o.some((p) => p.name === i) || o.push({ name: i }));
        }
      } catch {
      }
      if (r.parentElement && r.parentElement !== document.body)
        r = r.parentElement;
      else
        break;
    }
  return o;
}
function m(n) {
  if (!n)
    return { annotation: null };
  const e = h(n);
  return e.length > 0 && e[0] ? {
    annotation: `${e[0].name}`
  } : { annotation: null };
}
function y(n) {
  if (!n || n.length === 0)
    return null;
  const e = n.map(
    (t) => w(t)
  );
  return e.some((t) => t.length > 0) ? `This is additional information on the elements that the user selected. Use this information to find the correct element in the codebase.

  ${e.map((o, r) => {
    const s = o.length === 0 ? "No Angular component detected for this element" : `Angular component tree (from closest to farthest, ${o.length} closest element${o.length > 1 ? "s" : ""}): ${o.map((l) => `{name: ${l.name}}`).join(" child of ")}`;
    return `
<element index="${r + 1}">
  ${s}
</element>
    `;
  }).join("")}
  ` : null;
}
const A = {
  displayName: "Angular",
  description: "This plugin adds additional information and metadata for apps using Angular as a UI framework",
  iconSvg: /* @__PURE__ */ a(g, {}),
  pluginName: "angular",
  onContextElementHover: m,
  onContextElementSelect: m,
  onPromptSend: (n) => {
    const e = y(
      n.metadata.browserData?.selectedElements
    );
    return e ? {
      contextSnippets: [
        {
          promptContextName: "elements-angular-component-info",
          content: e
        }
      ]
    } : { contextSnippets: [] };
  }
};
export {
  A as default
};
